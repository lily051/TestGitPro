/* soapStub.h
   Generated by gSOAP 2.8.3 from CfnXwebApi.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"urn:CfnXwebApi"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__ChannelCfg
#define SOAP_TYPE_ns1__ChannelCfg (7)
/* ns1:ChannelCfg */
class SOAP_CMAC ns1__ChannelCfg
{
public:
	int iChID;	/* required element of type xsd:int */
	int iRecType;	/* required element of type xsd:int */
	int iRecDir;	/* required element of type xsd:int */
	int iLongRecInterval;	/* required element of type xsd:int */
	int iMaxReclen;	/* required element of type xsd:int */
	int iRecvDtmfTime;	/* required element of type xsd:int */
	char *szBindPhoneNum;	/* required element of type xsd:string */
	char *szStartDtmf;	/* required element of type xsd:string */
	char *szStopDtmf;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_ns1__ChannelCfg */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ChannelCfg() { ns1__ChannelCfg::soap_default(NULL); }
	virtual ~ns1__ChannelCfg() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ChRunStatus
#define SOAP_TYPE_ns1__ChRunStatus (8)
/* ns1:ChRunStatus */
class SOAP_CMAC ns1__ChRunStatus
{
public:
	int cChID;	/* required element of type xsd:int */
	int cChStatus;	/* required element of type xsd:int */
	int cRecDir;	/* required element of type xsd:int */
	char *szDtmf;	/* required element of type xsd:string */
	int iRecLen;	/* required element of type xsd:int */
	char *szRingTime;	/* required element of type xsd:string */
	int cRingCnt;	/* required element of type xsd:int */
	char *szCallerID;	/* required element of type xsd:string */
	char *szCalleeID;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__ChRunStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ChRunStatus() { ns1__ChRunStatus::soap_default(NULL); }
	virtual ~ns1__ChRunStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TotalChStatus
#define SOAP_TYPE_ns1__TotalChStatus (9)
/* ns1:TotalChStatus */
class SOAP_CMAC ns1__TotalChStatus
{
public:
	int cTotalCh;	/* required element of type xsd:int */
	int iStartCh;	/* required element of type xsd:int */
	char *arrChStatus;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__TotalChStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TotalChStatus() { ns1__TotalChStatus::soap_default(NULL); }
	virtual ~ns1__TotalChStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DiskSpace
#define SOAP_TYPE_ns1__DiskSpace (10)
/* ns1:DiskSpace */
class SOAP_CMAC ns1__DiskSpace
{
public:
	char *szDiskType1;	/* required element of type xsd:string */
	char *szDiskName1;	/* required element of type xsd:string */
	int iDiskTotalSpace1;	/* required element of type xsd:int */
	int iDiskFreeSpace1;	/* required element of type xsd:int */
	char *szDiskType2;	/* required element of type xsd:string */
	char *szDiskName2;	/* required element of type xsd:string */
	int iDiskTotalSpace2;	/* required element of type xsd:int */
	int iDiskFreeSpace2;	/* required element of type xsd:int */
	char *szDiskType3;	/* required element of type xsd:string */
	char *szDiskName3;	/* required element of type xsd:string */
	int iDiskTotalSpace3;	/* required element of type xsd:int */
	int iDiskFreeSpace3;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__DiskSpace */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DiskSpace() { ns1__DiskSpace::soap_default(NULL); }
	virtual ~ns1__DiskSpace() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GlobalCfg
#define SOAP_TYPE_ns1__GlobalCfg (11)
/* ns1:GlobalCfg */
class SOAP_CMAC ns1__GlobalCfg
{
public:
	int icompress;	/* required element of type xsd:int */
	int ifileformat;	/* required element of type xsd:int */
	char *szrecpath;	/* required element of type xsd:string */
	char *szdevreboottime;	/* required element of type xsd:string */
	int istartch;	/* required element of type xsd:int */
	int itotalch;	/* required element of type xsd:int */
	int cSetReboot;	/* required element of type xsd:int */
	int iRebootHour;	/* required element of type xsd:int */
	int iRebootMin;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__GlobalCfg */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GlobalCfg() { ns1__GlobalCfg::soap_default(NULL); }
	virtual ~ns1__GlobalCfg() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HardwareInfo
#define SOAP_TYPE_ns1__HardwareInfo (12)
/* ns1:HardwareInfo */
class SOAP_CMAC ns1__HardwareInfo
{
public:
	int TotalChannels;	/* required element of type xsd:int */
	char *BoardType;	/* required element of type xsd:string */
	char *IpAddress;	/* required element of type xsd:string */
	char *Gateway;	/* required element of type xsd:string */
	char *Macaddress;	/* required element of type xsd:string */
	char *Mask;	/* required element of type xsd:string */
	char *Dns;	/* required element of type xsd:string */
	char *DevID;	/* required element of type xsd:string */
	char *WebVersion;	/* required element of type xsd:string */
	char *RecSvrVersion;	/* required element of type xsd:string */
	char *SqlVersion;	/* required element of type xsd:string */
	char *kernelVersion;	/* required element of type xsd:string */
	char *CpldVersion;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__HardwareInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HardwareInfo() { ns1__HardwareInfo::soap_default(NULL); }
	virtual ~ns1__HardwareInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TotalChVol
#define SOAP_TYPE_ns1__TotalChVol (13)
/* ns1:TotalChVol */
class SOAP_CMAC ns1__TotalChVol
{
public:
	int iTotalCh;	/* required element of type xsd:int */
	int iStartCh;	/* required element of type xsd:int */
	char *szChVol;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__TotalChVol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TotalChVol() { ns1__TotalChVol::soap_default(NULL); }
	virtual ~ns1__TotalChVol() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NetCfg
#define SOAP_TYPE_ns1__NetCfg (14)
/* ns1:NetCfg */
class SOAP_CMAC ns1__NetCfg
{
public:
	char *szIPAddr;	/* required element of type xsd:string */
	char *szMask;	/* required element of type xsd:string */
	char *szGateway;	/* required element of type xsd:string */
	char *szDns;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__NetCfg */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NetCfg() { ns1__NetCfg::soap_default(NULL); }
	virtual ~ns1__NetCfg() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MonitorInfo
#define SOAP_TYPE_ns1__MonitorInfo (15)
/* ns1:MonitorInfo */
class SOAP_CMAC ns1__MonitorInfo
{
public:
	int ChID;	/* required element of type xsd:int */
	char *szRemoteIP;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__MonitorInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MonitorInfo() { ns1__MonitorInfo::soap_default(NULL); }
	virtual ~ns1__MonitorInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SqlResult
#define SOAP_TYPE_ns1__SqlResult (16)
/* ns1:SqlResult */
class SOAP_CMAC ns1__SqlResult
{
public:
	int result;	/* required element of type xsd:int */
	char *sqlinfo;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__SqlResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SqlResult() { ns1__SqlResult::soap_default(NULL); }
	virtual ~ns1__SqlResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CalculateInput
#define SOAP_TYPE_ns1__CalculateInput (17)
/* ns1:CalculateInput */
class SOAP_CMAC ns1__CalculateInput
{
public:
	int SelectType;	/* required element of type xsd:int */
	int start_USCOREyear;	/* required element of type xsd:int */
	int start_USCOREmonth;	/* required element of type xsd:int */
	int start_USCOREday;	/* required element of type xsd:int */
	int end_USCOREyear;	/* required element of type xsd:int */
	int end_USCOREmonth;	/* required element of type xsd:int */
	int end_USCOREday;	/* required element of type xsd:int */
	int monthwise_USCOREyear;	/* required element of type xsd:int */
	int monthwise_USCOREmonth;	/* required element of type xsd:int */
	int monthwise_USCOREday;	/* required element of type xsd:int */
	int mediaType;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__CalculateInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CalculateInput() { ns1__CalculateInput::soap_default(NULL); }
	virtual ~ns1__CalculateInput() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CalculateRet
#define SOAP_TYPE_ns1__CalculateRet (18)
/* ns1:CalculateRet */
class SOAP_CMAC ns1__CalculateRet
{
public:
	int totalcalls;	/* required element of type xsd:int */
	int totalsizeM;	/* required element of type xsd:int */
	int totalsizeKB;	/* required element of type xsd:int */
	int sizeAvailable;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__CalculateRet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CalculateRet() { ns1__CalculateRet::soap_default(NULL); }
	virtual ~ns1__CalculateRet() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DeleteFileResponse
#define SOAP_TYPE_ns1__DeleteFileResponse (23)
/* ns1:DeleteFileResponse */
struct ns1__DeleteFileResponse
{
public:
	bool DeleteFileReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__DeleteFile
#define SOAP_TYPE_ns1__DeleteFile (24)
/* ns1:DeleteFile */
struct ns1__DeleteFile
{
public:
	char *filename;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__DelRecordFileResponse
#define SOAP_TYPE_ns1__DelRecordFileResponse (27)
/* ns1:DelRecordFileResponse */
struct ns1__DelRecordFileResponse
{
public:
	int DelRecordFileReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__DelRecordFile
#define SOAP_TYPE_ns1__DelRecordFile (28)
/* ns1:DelRecordFile */
struct ns1__DelRecordFile
{
public:
	char *StartDate;	/* optional element of type xsd:string */
	char *StartTime;	/* optional element of type xsd:string */
	char *EndDate;	/* optional element of type xsd:string */
	char *EndTime;	/* optional element of type xsd:string */
	int StartChnl;	/* required element of type xsd:int */
	int EndChnl;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__ExecuteSQLResponse
#define SOAP_TYPE_ns1__ExecuteSQLResponse (29)
/* ns1:ExecuteSQLResponse */
struct ns1__ExecuteSQLResponse
{
public:
	ns1__SqlResult *ExecuteSQLReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:SqlResult */
};
#endif

#ifndef SOAP_TYPE_ns1__ExecuteSQL
#define SOAP_TYPE_ns1__ExecuteSQL (33)
/* ns1:ExecuteSQL */
struct ns1__ExecuteSQL
{
public:
	char *SqlQuerymsg;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__GetChannelCfgResponse
#define SOAP_TYPE_ns1__GetChannelCfgResponse (34)
/* ns1:GetChannelCfgResponse */
struct ns1__GetChannelCfgResponse
{
public:
	ns1__ChannelCfg *GetChannelCfgReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ChannelCfg */
};
#endif

#ifndef SOAP_TYPE_ns1__GetChannelCfg
#define SOAP_TYPE_ns1__GetChannelCfg (38)
/* ns1:GetChannelCfg */
struct ns1__GetChannelCfg
{
public:
	int ChID;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__GetChannelRunningStatusResponse
#define SOAP_TYPE_ns1__GetChannelRunningStatusResponse (39)
/* ns1:GetChannelRunningStatusResponse */
struct ns1__GetChannelRunningStatusResponse
{
public:
	ns1__ChRunStatus *GetChannelRunningStatusReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ChRunStatus */
};
#endif

#ifndef SOAP_TYPE_ns1__GetChannelRunningStatus
#define SOAP_TYPE_ns1__GetChannelRunningStatus (43)
/* ns1:GetChannelRunningStatus */
struct ns1__GetChannelRunningStatus
{
public:
	int ChID;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__GetChannelStatusResponse
#define SOAP_TYPE_ns1__GetChannelStatusResponse (44)
/* ns1:GetChannelStatusResponse */
struct ns1__GetChannelStatusResponse
{
public:
	ns1__TotalChStatus *GetChannelStatusReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:TotalChStatus */
};
#endif

#ifndef SOAP_TYPE_ns1__GetChannelStatus
#define SOAP_TYPE_ns1__GetChannelStatus (48)
/* ns1:GetChannelStatus */
struct ns1__GetChannelStatus
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__GetDeviceTimeResponse
#define SOAP_TYPE_ns1__GetDeviceTimeResponse (51)
/* ns1:GetDeviceTimeResponse */
struct ns1__GetDeviceTimeResponse
{
public:
	char *GetDeviceTimeReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__GetDeviceTime
#define SOAP_TYPE_ns1__GetDeviceTime (52)
/* ns1:GetDeviceTime */
struct ns1__GetDeviceTime
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__GetDevIDResponse
#define SOAP_TYPE_ns1__GetDevIDResponse (54)
/* ns1:GetDevIDResponse */
struct ns1__GetDevIDResponse
{
public:
	char *GetDevIDReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__GetDevID
#define SOAP_TYPE_ns1__GetDevID (55)
/* ns1:GetDevID */
struct ns1__GetDevID
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__GetDiskFreeSpaceResponse
#define SOAP_TYPE_ns1__GetDiskFreeSpaceResponse (56)
/* ns1:GetDiskFreeSpaceResponse */
struct ns1__GetDiskFreeSpaceResponse
{
public:
	ns1__DiskSpace *GetDiskFreeSpaceReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:DiskSpace */
};
#endif

#ifndef SOAP_TYPE_ns1__GetDiskFreeSpace
#define SOAP_TYPE_ns1__GetDiskFreeSpace (60)
/* ns1:GetDiskFreeSpace */
struct ns1__GetDiskFreeSpace
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__GetGlobalCfgResponse
#define SOAP_TYPE_ns1__GetGlobalCfgResponse (61)
/* ns1:GetGlobalCfgResponse */
struct ns1__GetGlobalCfgResponse
{
public:
	ns1__GlobalCfg *GetGlobalCfgReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GlobalCfg */
};
#endif

#ifndef SOAP_TYPE_ns1__GetGlobalCfg
#define SOAP_TYPE_ns1__GetGlobalCfg (65)
/* ns1:GetGlobalCfg */
struct ns1__GetGlobalCfg
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__GetHardwareInfoResponse
#define SOAP_TYPE_ns1__GetHardwareInfoResponse (66)
/* ns1:GetHardwareInfoResponse */
struct ns1__GetHardwareInfoResponse
{
public:
	ns1__HardwareInfo *GetHardwareInfoReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:HardwareInfo */
};
#endif

#ifndef SOAP_TYPE_ns1__GetHardwareInfo
#define SOAP_TYPE_ns1__GetHardwareInfo (70)
/* ns1:GetHardwareInfo */
struct ns1__GetHardwareInfo
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__GetLineVolResponse
#define SOAP_TYPE_ns1__GetLineVolResponse (71)
/* ns1:GetLineVolResponse */
struct ns1__GetLineVolResponse
{
public:
	ns1__TotalChVol *GetLineVolReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:TotalChVol */
};
#endif

#ifndef SOAP_TYPE_ns1__GetLineVol
#define SOAP_TYPE_ns1__GetLineVol (75)
/* ns1:GetLineVol */
struct ns1__GetLineVol
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__QueryRecordResponse
#define SOAP_TYPE_ns1__QueryRecordResponse (76)
/* ns1:QueryRecordResponse */
struct ns1__QueryRecordResponse
{
public:
	ns1__SqlResult *QueryRecordReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:SqlResult */
};
#endif

#ifndef SOAP_TYPE_ns1__QueryRecord
#define SOAP_TYPE_ns1__QueryRecord (79)
/* ns1:QueryRecord */
struct ns1__QueryRecord
{
public:
	char *StartDate;	/* optional element of type xsd:string */
	char *StartTime;	/* optional element of type xsd:string */
	char *EndDate;	/* optional element of type xsd:string */
	char *EndTime;	/* optional element of type xsd:string */
	int StartChnl;	/* required element of type xsd:int */
	int EndChnl;	/* required element of type xsd:int */
	int startindex;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__RebootDeviceResponse
#define SOAP_TYPE_ns1__RebootDeviceResponse (81)
/* ns1:RebootDeviceResponse */
struct ns1__RebootDeviceResponse
{
public:
	bool RebootDeviceReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__RebootDevice
#define SOAP_TYPE_ns1__RebootDevice (82)
/* ns1:RebootDevice */
struct ns1__RebootDevice
{
public:
	int cmd;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__SetAdminPasswordResponse
#define SOAP_TYPE_ns1__SetAdminPasswordResponse (84)
/* ns1:SetAdminPasswordResponse */
struct ns1__SetAdminPasswordResponse
{
public:
	bool SetAdminPasswordReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__SetAdminPassword
#define SOAP_TYPE_ns1__SetAdminPassword (85)
/* ns1:SetAdminPassword */
struct ns1__SetAdminPassword
{
public:
	char *OldPassword;	/* optional element of type xsd:string */
	char *NewPassword;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__SetChannelCfgResponse
#define SOAP_TYPE_ns1__SetChannelCfgResponse (87)
/* ns1:SetChannelCfgResponse */
struct ns1__SetChannelCfgResponse
{
public:
	bool SetChannelCfgReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__SetChannelCfg
#define SOAP_TYPE_ns1__SetChannelCfg (88)
/* ns1:SetChannelCfg */
struct ns1__SetChannelCfg
{
public:
	ns1__ChannelCfg *channelcfg;	/* optional element of type ns1:ChannelCfg */
};
#endif

#ifndef SOAP_TYPE_ns1__SetDateTimeResponse
#define SOAP_TYPE_ns1__SetDateTimeResponse (90)
/* ns1:SetDateTimeResponse */
struct ns1__SetDateTimeResponse
{
public:
	bool SetDateTimeReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__SetDateTime
#define SOAP_TYPE_ns1__SetDateTime (91)
/* ns1:SetDateTime */
struct ns1__SetDateTime
{
public:
	char *time;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__SetGlobalCfgResponse
#define SOAP_TYPE_ns1__SetGlobalCfgResponse (93)
/* ns1:SetGlobalCfgResponse */
struct ns1__SetGlobalCfgResponse
{
public:
	bool SetGlobalCfgReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__SetGlobalCfg
#define SOAP_TYPE_ns1__SetGlobalCfg (94)
/* ns1:SetGlobalCfg */
struct ns1__SetGlobalCfg
{
public:
	ns1__GlobalCfg *globalset;	/* optional element of type ns1:GlobalCfg */
};
#endif

#ifndef SOAP_TYPE_ns1__SetNetCfgResponse
#define SOAP_TYPE_ns1__SetNetCfgResponse (97)
/* ns1:SetNetCfgResponse */
struct ns1__SetNetCfgResponse
{
public:
	bool SetNetCfgReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__SetNetCfg
#define SOAP_TYPE_ns1__SetNetCfg (98)
/* ns1:SetNetCfg */
struct ns1__SetNetCfg
{
public:
	ns1__NetCfg *NetCfg;	/* optional element of type ns1:NetCfg */
};
#endif

#ifndef SOAP_TYPE_ns1__StartMonitorResponse
#define SOAP_TYPE_ns1__StartMonitorResponse (101)
/* ns1:StartMonitorResponse */
struct ns1__StartMonitorResponse
{
public:
	bool StartMonitorReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__StartMonitor
#define SOAP_TYPE_ns1__StartMonitor (102)
/* ns1:StartMonitor */
struct ns1__StartMonitor
{
public:
	ns1__MonitorInfo *monitorInfo;	/* optional element of type ns1:MonitorInfo */
};
#endif

#ifndef SOAP_TYPE_ns1__StopMonitorResponse
#define SOAP_TYPE_ns1__StopMonitorResponse (104)
/* ns1:StopMonitorResponse */
struct ns1__StopMonitorResponse
{
public:
	bool StopMonitorReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__StopMonitor
#define SOAP_TYPE_ns1__StopMonitor (105)
/* ns1:StopMonitor */
struct ns1__StopMonitor
{
public:
	ns1__MonitorInfo *monitorInfo;	/* optional element of type ns1:MonitorInfo */
};
#endif

#ifndef SOAP_TYPE_ns1__CheckMediaConnectedResponse
#define SOAP_TYPE_ns1__CheckMediaConnectedResponse (107)
/* ns1:CheckMediaConnectedResponse */
struct ns1__CheckMediaConnectedResponse
{
public:
	int CheckMediaConnectedResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__CheckMediaConnected
#define SOAP_TYPE_ns1__CheckMediaConnected (108)
/* ns1:CheckMediaConnected */
struct ns1__CheckMediaConnected
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__CheckMediaAvailableResponse
#define SOAP_TYPE_ns1__CheckMediaAvailableResponse (110)
/* ns1:CheckMediaAvailableResponse */
struct ns1__CheckMediaAvailableResponse
{
public:
	int CheckMediaAvailableResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__CheckMediaAvailable
#define SOAP_TYPE_ns1__CheckMediaAvailable (111)
/* ns1:CheckMediaAvailable */
struct ns1__CheckMediaAvailable
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__CalculateDataResponse
#define SOAP_TYPE_ns1__CalculateDataResponse (112)
/* ns1:CalculateDataResponse */
struct ns1__CalculateDataResponse
{
public:
	ns1__CalculateRet *CalculateDataResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:CalculateRet */
};
#endif

#ifndef SOAP_TYPE_ns1__CalculateData
#define SOAP_TYPE_ns1__CalculateData (117)
/* ns1:CalculateData */
struct ns1__CalculateData
{
public:
	ns1__CalculateInput *calInput;	/* optional element of type ns1:CalculateInput */
};
#endif

#ifndef SOAP_TYPE_ns1__WriteDVDResponse
#define SOAP_TYPE_ns1__WriteDVDResponse (119)
/* ns1:WriteDVDResponse */
struct ns1__WriteDVDResponse
{
public:
	int WriteDVDResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__WriteDVD
#define SOAP_TYPE_ns1__WriteDVD (120)
/* ns1:WriteDVD */
struct ns1__WriteDVD
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__SetWebPortResponse
#define SOAP_TYPE_ns1__SetWebPortResponse (122)
/* ns1:SetWebPortResponse */
struct ns1__SetWebPortResponse
{
public:
	bool SetWebPortResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
};
#endif

#ifndef SOAP_TYPE_ns1__SetWebPort
#define SOAP_TYPE_ns1__SetWebPort (123)
/* ns1:SetWebPort */
struct ns1__SetWebPort
{
public:
	int WebPort;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__GetWebPortResponse
#define SOAP_TYPE_ns1__GetWebPortResponse (125)
/* ns1:GetWebPortResponse */
struct ns1__GetWebPortResponse
{
public:
	int GetWebPortResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__GetWebPort
#define SOAP_TYPE_ns1__GetWebPort (126)
/* ns1:GetWebPort */
struct ns1__GetWebPort
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (127)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (128)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (130)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (133)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (134)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
