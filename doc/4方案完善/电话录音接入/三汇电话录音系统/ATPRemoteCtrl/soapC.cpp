/* soapC.cpp
   Generated by gSOAP 2.8.3 from CfnXwebApi.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.3 2016-02-18 03:07:44 GMT")

char g_szDefaultEndPoint[200]="http://201.123.115.5:80/server.php";
char g_szDefaultServer[100];

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__CalculateRet:
		return soap_in_ns1__CalculateRet(soap, NULL, NULL, "ns1:CalculateRet");
	case SOAP_TYPE_ns1__CalculateInput:
		return soap_in_ns1__CalculateInput(soap, NULL, NULL, "ns1:CalculateInput");
	case SOAP_TYPE_ns1__SqlResult:
		return soap_in_ns1__SqlResult(soap, NULL, NULL, "ns1:SqlResult");
	case SOAP_TYPE_ns1__MonitorInfo:
		return soap_in_ns1__MonitorInfo(soap, NULL, NULL, "ns1:MonitorInfo");
	case SOAP_TYPE_ns1__NetCfg:
		return soap_in_ns1__NetCfg(soap, NULL, NULL, "ns1:NetCfg");
	case SOAP_TYPE_ns1__TotalChVol:
		return soap_in_ns1__TotalChVol(soap, NULL, NULL, "ns1:TotalChVol");
	case SOAP_TYPE_ns1__HardwareInfo:
		return soap_in_ns1__HardwareInfo(soap, NULL, NULL, "ns1:HardwareInfo");
	case SOAP_TYPE_ns1__GlobalCfg:
		return soap_in_ns1__GlobalCfg(soap, NULL, NULL, "ns1:GlobalCfg");
	case SOAP_TYPE_ns1__DiskSpace:
		return soap_in_ns1__DiskSpace(soap, NULL, NULL, "ns1:DiskSpace");
	case SOAP_TYPE_ns1__TotalChStatus:
		return soap_in_ns1__TotalChStatus(soap, NULL, NULL, "ns1:TotalChStatus");
	case SOAP_TYPE_ns1__ChRunStatus:
		return soap_in_ns1__ChRunStatus(soap, NULL, NULL, "ns1:ChRunStatus");
	case SOAP_TYPE_ns1__ChannelCfg:
		return soap_in_ns1__ChannelCfg(soap, NULL, NULL, "ns1:ChannelCfg");
	case SOAP_TYPE_ns1__GetWebPort:
		return soap_in_ns1__GetWebPort(soap, NULL, NULL, "ns1:GetWebPort");
	case SOAP_TYPE_ns1__GetWebPortResponse:
		return soap_in_ns1__GetWebPortResponse(soap, NULL, NULL, "ns1:GetWebPortResponse");
	case SOAP_TYPE_ns1__SetWebPort:
		return soap_in_ns1__SetWebPort(soap, NULL, NULL, "ns1:SetWebPort");
	case SOAP_TYPE_ns1__SetWebPortResponse:
		return soap_in_ns1__SetWebPortResponse(soap, NULL, NULL, "ns1:SetWebPortResponse");
	case SOAP_TYPE_ns1__WriteDVD:
		return soap_in_ns1__WriteDVD(soap, NULL, NULL, "ns1:WriteDVD");
	case SOAP_TYPE_ns1__WriteDVDResponse:
		return soap_in_ns1__WriteDVDResponse(soap, NULL, NULL, "ns1:WriteDVDResponse");
	case SOAP_TYPE_ns1__CalculateData:
		return soap_in_ns1__CalculateData(soap, NULL, NULL, "ns1:CalculateData");
	case SOAP_TYPE_ns1__CalculateDataResponse:
		return soap_in_ns1__CalculateDataResponse(soap, NULL, NULL, "ns1:CalculateDataResponse");
	case SOAP_TYPE_ns1__CheckMediaAvailable:
		return soap_in_ns1__CheckMediaAvailable(soap, NULL, NULL, "ns1:CheckMediaAvailable");
	case SOAP_TYPE_ns1__CheckMediaAvailableResponse:
		return soap_in_ns1__CheckMediaAvailableResponse(soap, NULL, NULL, "ns1:CheckMediaAvailableResponse");
	case SOAP_TYPE_ns1__CheckMediaConnected:
		return soap_in_ns1__CheckMediaConnected(soap, NULL, NULL, "ns1:CheckMediaConnected");
	case SOAP_TYPE_ns1__CheckMediaConnectedResponse:
		return soap_in_ns1__CheckMediaConnectedResponse(soap, NULL, NULL, "ns1:CheckMediaConnectedResponse");
	case SOAP_TYPE_ns1__StopMonitor:
		return soap_in_ns1__StopMonitor(soap, NULL, NULL, "ns1:StopMonitor");
	case SOAP_TYPE_ns1__StopMonitorResponse:
		return soap_in_ns1__StopMonitorResponse(soap, NULL, NULL, "ns1:StopMonitorResponse");
	case SOAP_TYPE_ns1__StartMonitor:
		return soap_in_ns1__StartMonitor(soap, NULL, NULL, "ns1:StartMonitor");
	case SOAP_TYPE_ns1__StartMonitorResponse:
		return soap_in_ns1__StartMonitorResponse(soap, NULL, NULL, "ns1:StartMonitorResponse");
	case SOAP_TYPE_ns1__SetNetCfg:
		return soap_in_ns1__SetNetCfg(soap, NULL, NULL, "ns1:SetNetCfg");
	case SOAP_TYPE_ns1__SetNetCfgResponse:
		return soap_in_ns1__SetNetCfgResponse(soap, NULL, NULL, "ns1:SetNetCfgResponse");
	case SOAP_TYPE_ns1__SetGlobalCfg:
		return soap_in_ns1__SetGlobalCfg(soap, NULL, NULL, "ns1:SetGlobalCfg");
	case SOAP_TYPE_ns1__SetGlobalCfgResponse:
		return soap_in_ns1__SetGlobalCfgResponse(soap, NULL, NULL, "ns1:SetGlobalCfgResponse");
	case SOAP_TYPE_ns1__SetDateTime:
		return soap_in_ns1__SetDateTime(soap, NULL, NULL, "ns1:SetDateTime");
	case SOAP_TYPE_ns1__SetDateTimeResponse:
		return soap_in_ns1__SetDateTimeResponse(soap, NULL, NULL, "ns1:SetDateTimeResponse");
	case SOAP_TYPE_ns1__SetChannelCfg:
		return soap_in_ns1__SetChannelCfg(soap, NULL, NULL, "ns1:SetChannelCfg");
	case SOAP_TYPE_ns1__SetChannelCfgResponse:
		return soap_in_ns1__SetChannelCfgResponse(soap, NULL, NULL, "ns1:SetChannelCfgResponse");
	case SOAP_TYPE_ns1__SetAdminPassword:
		return soap_in_ns1__SetAdminPassword(soap, NULL, NULL, "ns1:SetAdminPassword");
	case SOAP_TYPE_ns1__SetAdminPasswordResponse:
		return soap_in_ns1__SetAdminPasswordResponse(soap, NULL, NULL, "ns1:SetAdminPasswordResponse");
	case SOAP_TYPE_ns1__RebootDevice:
		return soap_in_ns1__RebootDevice(soap, NULL, NULL, "ns1:RebootDevice");
	case SOAP_TYPE_ns1__RebootDeviceResponse:
		return soap_in_ns1__RebootDeviceResponse(soap, NULL, NULL, "ns1:RebootDeviceResponse");
	case SOAP_TYPE_ns1__QueryRecord:
		return soap_in_ns1__QueryRecord(soap, NULL, NULL, "ns1:QueryRecord");
	case SOAP_TYPE_ns1__QueryRecordResponse:
		return soap_in_ns1__QueryRecordResponse(soap, NULL, NULL, "ns1:QueryRecordResponse");
	case SOAP_TYPE_ns1__GetLineVol:
		return soap_in_ns1__GetLineVol(soap, NULL, NULL, "ns1:GetLineVol");
	case SOAP_TYPE_ns1__GetLineVolResponse:
		return soap_in_ns1__GetLineVolResponse(soap, NULL, NULL, "ns1:GetLineVolResponse");
	case SOAP_TYPE_ns1__GetHardwareInfo:
		return soap_in_ns1__GetHardwareInfo(soap, NULL, NULL, "ns1:GetHardwareInfo");
	case SOAP_TYPE_ns1__GetHardwareInfoResponse:
		return soap_in_ns1__GetHardwareInfoResponse(soap, NULL, NULL, "ns1:GetHardwareInfoResponse");
	case SOAP_TYPE_ns1__GetGlobalCfg:
		return soap_in_ns1__GetGlobalCfg(soap, NULL, NULL, "ns1:GetGlobalCfg");
	case SOAP_TYPE_ns1__GetGlobalCfgResponse:
		return soap_in_ns1__GetGlobalCfgResponse(soap, NULL, NULL, "ns1:GetGlobalCfgResponse");
	case SOAP_TYPE_ns1__GetDiskFreeSpace:
		return soap_in_ns1__GetDiskFreeSpace(soap, NULL, NULL, "ns1:GetDiskFreeSpace");
	case SOAP_TYPE_ns1__GetDiskFreeSpaceResponse:
		return soap_in_ns1__GetDiskFreeSpaceResponse(soap, NULL, NULL, "ns1:GetDiskFreeSpaceResponse");
	case SOAP_TYPE_ns1__GetDevID:
		return soap_in_ns1__GetDevID(soap, NULL, NULL, "ns1:GetDevID");
	case SOAP_TYPE_ns1__GetDevIDResponse:
		return soap_in_ns1__GetDevIDResponse(soap, NULL, NULL, "ns1:GetDevIDResponse");
	case SOAP_TYPE_ns1__GetDeviceTime:
		return soap_in_ns1__GetDeviceTime(soap, NULL, NULL, "ns1:GetDeviceTime");
	case SOAP_TYPE_ns1__GetDeviceTimeResponse:
		return soap_in_ns1__GetDeviceTimeResponse(soap, NULL, NULL, "ns1:GetDeviceTimeResponse");
	case SOAP_TYPE_ns1__GetChannelStatus:
		return soap_in_ns1__GetChannelStatus(soap, NULL, NULL, "ns1:GetChannelStatus");
	case SOAP_TYPE_ns1__GetChannelStatusResponse:
		return soap_in_ns1__GetChannelStatusResponse(soap, NULL, NULL, "ns1:GetChannelStatusResponse");
	case SOAP_TYPE_ns1__GetChannelRunningStatus:
		return soap_in_ns1__GetChannelRunningStatus(soap, NULL, NULL, "ns1:GetChannelRunningStatus");
	case SOAP_TYPE_ns1__GetChannelRunningStatusResponse:
		return soap_in_ns1__GetChannelRunningStatusResponse(soap, NULL, NULL, "ns1:GetChannelRunningStatusResponse");
	case SOAP_TYPE_ns1__GetChannelCfg:
		return soap_in_ns1__GetChannelCfg(soap, NULL, NULL, "ns1:GetChannelCfg");
	case SOAP_TYPE_ns1__GetChannelCfgResponse:
		return soap_in_ns1__GetChannelCfgResponse(soap, NULL, NULL, "ns1:GetChannelCfgResponse");
	case SOAP_TYPE_ns1__ExecuteSQL:
		return soap_in_ns1__ExecuteSQL(soap, NULL, NULL, "ns1:ExecuteSQL");
	case SOAP_TYPE_ns1__ExecuteSQLResponse:
		return soap_in_ns1__ExecuteSQLResponse(soap, NULL, NULL, "ns1:ExecuteSQLResponse");
	case SOAP_TYPE_ns1__DelRecordFile:
		return soap_in_ns1__DelRecordFile(soap, NULL, NULL, "ns1:DelRecordFile");
	case SOAP_TYPE_ns1__DelRecordFileResponse:
		return soap_in_ns1__DelRecordFileResponse(soap, NULL, NULL, "ns1:DelRecordFileResponse");
	case SOAP_TYPE_ns1__DeleteFile:
		return soap_in_ns1__DeleteFile(soap, NULL, NULL, "ns1:DeleteFile");
	case SOAP_TYPE_ns1__DeleteFileResponse:
		return soap_in_ns1__DeleteFileResponse(soap, NULL, NULL, "ns1:DeleteFileResponse");
	case SOAP_TYPE_PointerTons1__CalculateInput:
		return soap_in_PointerTons1__CalculateInput(soap, NULL, NULL, "ns1:CalculateInput");
	case SOAP_TYPE_PointerTons1__CalculateRet:
		return soap_in_PointerTons1__CalculateRet(soap, NULL, NULL, "ns1:CalculateRet");
	case SOAP_TYPE_PointerTons1__MonitorInfo:
		return soap_in_PointerTons1__MonitorInfo(soap, NULL, NULL, "ns1:MonitorInfo");
	case SOAP_TYPE_PointerTons1__NetCfg:
		return soap_in_PointerTons1__NetCfg(soap, NULL, NULL, "ns1:NetCfg");
	case SOAP_TYPE_PointerTons1__TotalChVol:
		return soap_in_PointerTons1__TotalChVol(soap, NULL, NULL, "ns1:TotalChVol");
	case SOAP_TYPE_PointerTons1__HardwareInfo:
		return soap_in_PointerTons1__HardwareInfo(soap, NULL, NULL, "ns1:HardwareInfo");
	case SOAP_TYPE_PointerTons1__GlobalCfg:
		return soap_in_PointerTons1__GlobalCfg(soap, NULL, NULL, "ns1:GlobalCfg");
	case SOAP_TYPE_PointerTons1__DiskSpace:
		return soap_in_PointerTons1__DiskSpace(soap, NULL, NULL, "ns1:DiskSpace");
	case SOAP_TYPE_PointerTons1__TotalChStatus:
		return soap_in_PointerTons1__TotalChStatus(soap, NULL, NULL, "ns1:TotalChStatus");
	case SOAP_TYPE_PointerTons1__ChRunStatus:
		return soap_in_PointerTons1__ChRunStatus(soap, NULL, NULL, "ns1:ChRunStatus");
	case SOAP_TYPE_PointerTons1__ChannelCfg:
		return soap_in_PointerTons1__ChannelCfg(soap, NULL, NULL, "ns1:ChannelCfg");
	case SOAP_TYPE_PointerTons1__SqlResult:
		return soap_in_PointerTons1__SqlResult(soap, NULL, NULL, "ns1:SqlResult");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CalculateRet"))
		{	*type = SOAP_TYPE_ns1__CalculateRet;
			return soap_in_ns1__CalculateRet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CalculateInput"))
		{	*type = SOAP_TYPE_ns1__CalculateInput;
			return soap_in_ns1__CalculateInput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SqlResult"))
		{	*type = SOAP_TYPE_ns1__SqlResult;
			return soap_in_ns1__SqlResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MonitorInfo"))
		{	*type = SOAP_TYPE_ns1__MonitorInfo;
			return soap_in_ns1__MonitorInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NetCfg"))
		{	*type = SOAP_TYPE_ns1__NetCfg;
			return soap_in_ns1__NetCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TotalChVol"))
		{	*type = SOAP_TYPE_ns1__TotalChVol;
			return soap_in_ns1__TotalChVol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HardwareInfo"))
		{	*type = SOAP_TYPE_ns1__HardwareInfo;
			return soap_in_ns1__HardwareInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GlobalCfg"))
		{	*type = SOAP_TYPE_ns1__GlobalCfg;
			return soap_in_ns1__GlobalCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiskSpace"))
		{	*type = SOAP_TYPE_ns1__DiskSpace;
			return soap_in_ns1__DiskSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TotalChStatus"))
		{	*type = SOAP_TYPE_ns1__TotalChStatus;
			return soap_in_ns1__TotalChStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChRunStatus"))
		{	*type = SOAP_TYPE_ns1__ChRunStatus;
			return soap_in_ns1__ChRunStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelCfg"))
		{	*type = SOAP_TYPE_ns1__ChannelCfg;
			return soap_in_ns1__ChannelCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWebPort"))
		{	*type = SOAP_TYPE_ns1__GetWebPort;
			return soap_in_ns1__GetWebPort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWebPortResponse"))
		{	*type = SOAP_TYPE_ns1__GetWebPortResponse;
			return soap_in_ns1__GetWebPortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetWebPort"))
		{	*type = SOAP_TYPE_ns1__SetWebPort;
			return soap_in_ns1__SetWebPort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetWebPortResponse"))
		{	*type = SOAP_TYPE_ns1__SetWebPortResponse;
			return soap_in_ns1__SetWebPortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteDVD"))
		{	*type = SOAP_TYPE_ns1__WriteDVD;
			return soap_in_ns1__WriteDVD(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteDVDResponse"))
		{	*type = SOAP_TYPE_ns1__WriteDVDResponse;
			return soap_in_ns1__WriteDVDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CalculateData"))
		{	*type = SOAP_TYPE_ns1__CalculateData;
			return soap_in_ns1__CalculateData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CalculateDataResponse"))
		{	*type = SOAP_TYPE_ns1__CalculateDataResponse;
			return soap_in_ns1__CalculateDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckMediaAvailable"))
		{	*type = SOAP_TYPE_ns1__CheckMediaAvailable;
			return soap_in_ns1__CheckMediaAvailable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckMediaAvailableResponse"))
		{	*type = SOAP_TYPE_ns1__CheckMediaAvailableResponse;
			return soap_in_ns1__CheckMediaAvailableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckMediaConnected"))
		{	*type = SOAP_TYPE_ns1__CheckMediaConnected;
			return soap_in_ns1__CheckMediaConnected(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckMediaConnectedResponse"))
		{	*type = SOAP_TYPE_ns1__CheckMediaConnectedResponse;
			return soap_in_ns1__CheckMediaConnectedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopMonitor"))
		{	*type = SOAP_TYPE_ns1__StopMonitor;
			return soap_in_ns1__StopMonitor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopMonitorResponse"))
		{	*type = SOAP_TYPE_ns1__StopMonitorResponse;
			return soap_in_ns1__StopMonitorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartMonitor"))
		{	*type = SOAP_TYPE_ns1__StartMonitor;
			return soap_in_ns1__StartMonitor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartMonitorResponse"))
		{	*type = SOAP_TYPE_ns1__StartMonitorResponse;
			return soap_in_ns1__StartMonitorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetNetCfg"))
		{	*type = SOAP_TYPE_ns1__SetNetCfg;
			return soap_in_ns1__SetNetCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetNetCfgResponse"))
		{	*type = SOAP_TYPE_ns1__SetNetCfgResponse;
			return soap_in_ns1__SetNetCfgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetGlobalCfg"))
		{	*type = SOAP_TYPE_ns1__SetGlobalCfg;
			return soap_in_ns1__SetGlobalCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetGlobalCfgResponse"))
		{	*type = SOAP_TYPE_ns1__SetGlobalCfgResponse;
			return soap_in_ns1__SetGlobalCfgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDateTime"))
		{	*type = SOAP_TYPE_ns1__SetDateTime;
			return soap_in_ns1__SetDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDateTimeResponse"))
		{	*type = SOAP_TYPE_ns1__SetDateTimeResponse;
			return soap_in_ns1__SetDateTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetChannelCfg"))
		{	*type = SOAP_TYPE_ns1__SetChannelCfg;
			return soap_in_ns1__SetChannelCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetChannelCfgResponse"))
		{	*type = SOAP_TYPE_ns1__SetChannelCfgResponse;
			return soap_in_ns1__SetChannelCfgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetAdminPassword"))
		{	*type = SOAP_TYPE_ns1__SetAdminPassword;
			return soap_in_ns1__SetAdminPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetAdminPasswordResponse"))
		{	*type = SOAP_TYPE_ns1__SetAdminPasswordResponse;
			return soap_in_ns1__SetAdminPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RebootDevice"))
		{	*type = SOAP_TYPE_ns1__RebootDevice;
			return soap_in_ns1__RebootDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RebootDeviceResponse"))
		{	*type = SOAP_TYPE_ns1__RebootDeviceResponse;
			return soap_in_ns1__RebootDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryRecord"))
		{	*type = SOAP_TYPE_ns1__QueryRecord;
			return soap_in_ns1__QueryRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryRecordResponse"))
		{	*type = SOAP_TYPE_ns1__QueryRecordResponse;
			return soap_in_ns1__QueryRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLineVol"))
		{	*type = SOAP_TYPE_ns1__GetLineVol;
			return soap_in_ns1__GetLineVol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLineVolResponse"))
		{	*type = SOAP_TYPE_ns1__GetLineVolResponse;
			return soap_in_ns1__GetLineVolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHardwareInfo"))
		{	*type = SOAP_TYPE_ns1__GetHardwareInfo;
			return soap_in_ns1__GetHardwareInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHardwareInfoResponse"))
		{	*type = SOAP_TYPE_ns1__GetHardwareInfoResponse;
			return soap_in_ns1__GetHardwareInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGlobalCfg"))
		{	*type = SOAP_TYPE_ns1__GetGlobalCfg;
			return soap_in_ns1__GetGlobalCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetGlobalCfgResponse"))
		{	*type = SOAP_TYPE_ns1__GetGlobalCfgResponse;
			return soap_in_ns1__GetGlobalCfgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDiskFreeSpace"))
		{	*type = SOAP_TYPE_ns1__GetDiskFreeSpace;
			return soap_in_ns1__GetDiskFreeSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDiskFreeSpaceResponse"))
		{	*type = SOAP_TYPE_ns1__GetDiskFreeSpaceResponse;
			return soap_in_ns1__GetDiskFreeSpaceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevID"))
		{	*type = SOAP_TYPE_ns1__GetDevID;
			return soap_in_ns1__GetDevID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDevIDResponse"))
		{	*type = SOAP_TYPE_ns1__GetDevIDResponse;
			return soap_in_ns1__GetDevIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDeviceTime"))
		{	*type = SOAP_TYPE_ns1__GetDeviceTime;
			return soap_in_ns1__GetDeviceTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDeviceTimeResponse"))
		{	*type = SOAP_TYPE_ns1__GetDeviceTimeResponse;
			return soap_in_ns1__GetDeviceTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChannelStatus"))
		{	*type = SOAP_TYPE_ns1__GetChannelStatus;
			return soap_in_ns1__GetChannelStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChannelStatusResponse"))
		{	*type = SOAP_TYPE_ns1__GetChannelStatusResponse;
			return soap_in_ns1__GetChannelStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChannelRunningStatus"))
		{	*type = SOAP_TYPE_ns1__GetChannelRunningStatus;
			return soap_in_ns1__GetChannelRunningStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChannelRunningStatusResponse"))
		{	*type = SOAP_TYPE_ns1__GetChannelRunningStatusResponse;
			return soap_in_ns1__GetChannelRunningStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChannelCfg"))
		{	*type = SOAP_TYPE_ns1__GetChannelCfg;
			return soap_in_ns1__GetChannelCfg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChannelCfgResponse"))
		{	*type = SOAP_TYPE_ns1__GetChannelCfgResponse;
			return soap_in_ns1__GetChannelCfgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSQL"))
		{	*type = SOAP_TYPE_ns1__ExecuteSQL;
			return soap_in_ns1__ExecuteSQL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSQLResponse"))
		{	*type = SOAP_TYPE_ns1__ExecuteSQLResponse;
			return soap_in_ns1__ExecuteSQLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DelRecordFile"))
		{	*type = SOAP_TYPE_ns1__DelRecordFile;
			return soap_in_ns1__DelRecordFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DelRecordFileResponse"))
		{	*type = SOAP_TYPE_ns1__DelRecordFileResponse;
			return soap_in_ns1__DelRecordFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteFile"))
		{	*type = SOAP_TYPE_ns1__DeleteFile;
			return soap_in_ns1__DeleteFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteFileResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteFileResponse;
			return soap_in_ns1__DeleteFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__CalculateRet:
		return ((ns1__CalculateRet *)ptr)->soap_out(soap, tag, id, "ns1:CalculateRet");
	case SOAP_TYPE_ns1__CalculateInput:
		return ((ns1__CalculateInput *)ptr)->soap_out(soap, tag, id, "ns1:CalculateInput");
	case SOAP_TYPE_ns1__SqlResult:
		return ((ns1__SqlResult *)ptr)->soap_out(soap, tag, id, "ns1:SqlResult");
	case SOAP_TYPE_ns1__MonitorInfo:
		return ((ns1__MonitorInfo *)ptr)->soap_out(soap, tag, id, "ns1:MonitorInfo");
	case SOAP_TYPE_ns1__NetCfg:
		return ((ns1__NetCfg *)ptr)->soap_out(soap, tag, id, "ns1:NetCfg");
	case SOAP_TYPE_ns1__TotalChVol:
		return ((ns1__TotalChVol *)ptr)->soap_out(soap, tag, id, "ns1:TotalChVol");
	case SOAP_TYPE_ns1__HardwareInfo:
		return ((ns1__HardwareInfo *)ptr)->soap_out(soap, tag, id, "ns1:HardwareInfo");
	case SOAP_TYPE_ns1__GlobalCfg:
		return ((ns1__GlobalCfg *)ptr)->soap_out(soap, tag, id, "ns1:GlobalCfg");
	case SOAP_TYPE_ns1__DiskSpace:
		return ((ns1__DiskSpace *)ptr)->soap_out(soap, tag, id, "ns1:DiskSpace");
	case SOAP_TYPE_ns1__TotalChStatus:
		return ((ns1__TotalChStatus *)ptr)->soap_out(soap, tag, id, "ns1:TotalChStatus");
	case SOAP_TYPE_ns1__ChRunStatus:
		return ((ns1__ChRunStatus *)ptr)->soap_out(soap, tag, id, "ns1:ChRunStatus");
	case SOAP_TYPE_ns1__ChannelCfg:
		return ((ns1__ChannelCfg *)ptr)->soap_out(soap, tag, id, "ns1:ChannelCfg");
	case SOAP_TYPE_ns1__GetWebPort:
		return soap_out_ns1__GetWebPort(soap, tag, id, (const struct ns1__GetWebPort *)ptr, "ns1:GetWebPort");
	case SOAP_TYPE_ns1__GetWebPortResponse:
		return soap_out_ns1__GetWebPortResponse(soap, tag, id, (const struct ns1__GetWebPortResponse *)ptr, "ns1:GetWebPortResponse");
	case SOAP_TYPE_ns1__SetWebPort:
		return soap_out_ns1__SetWebPort(soap, tag, id, (const struct ns1__SetWebPort *)ptr, "ns1:SetWebPort");
	case SOAP_TYPE_ns1__SetWebPortResponse:
		return soap_out_ns1__SetWebPortResponse(soap, tag, id, (const struct ns1__SetWebPortResponse *)ptr, "ns1:SetWebPortResponse");
	case SOAP_TYPE_ns1__WriteDVD:
		return soap_out_ns1__WriteDVD(soap, tag, id, (const struct ns1__WriteDVD *)ptr, "ns1:WriteDVD");
	case SOAP_TYPE_ns1__WriteDVDResponse:
		return soap_out_ns1__WriteDVDResponse(soap, tag, id, (const struct ns1__WriteDVDResponse *)ptr, "ns1:WriteDVDResponse");
	case SOAP_TYPE_ns1__CalculateData:
		return soap_out_ns1__CalculateData(soap, tag, id, (const struct ns1__CalculateData *)ptr, "ns1:CalculateData");
	case SOAP_TYPE_ns1__CalculateDataResponse:
		return soap_out_ns1__CalculateDataResponse(soap, tag, id, (const struct ns1__CalculateDataResponse *)ptr, "ns1:CalculateDataResponse");
	case SOAP_TYPE_ns1__CheckMediaAvailable:
		return soap_out_ns1__CheckMediaAvailable(soap, tag, id, (const struct ns1__CheckMediaAvailable *)ptr, "ns1:CheckMediaAvailable");
	case SOAP_TYPE_ns1__CheckMediaAvailableResponse:
		return soap_out_ns1__CheckMediaAvailableResponse(soap, tag, id, (const struct ns1__CheckMediaAvailableResponse *)ptr, "ns1:CheckMediaAvailableResponse");
	case SOAP_TYPE_ns1__CheckMediaConnected:
		return soap_out_ns1__CheckMediaConnected(soap, tag, id, (const struct ns1__CheckMediaConnected *)ptr, "ns1:CheckMediaConnected");
	case SOAP_TYPE_ns1__CheckMediaConnectedResponse:
		return soap_out_ns1__CheckMediaConnectedResponse(soap, tag, id, (const struct ns1__CheckMediaConnectedResponse *)ptr, "ns1:CheckMediaConnectedResponse");
	case SOAP_TYPE_ns1__StopMonitor:
		return soap_out_ns1__StopMonitor(soap, tag, id, (const struct ns1__StopMonitor *)ptr, "ns1:StopMonitor");
	case SOAP_TYPE_ns1__StopMonitorResponse:
		return soap_out_ns1__StopMonitorResponse(soap, tag, id, (const struct ns1__StopMonitorResponse *)ptr, "ns1:StopMonitorResponse");
	case SOAP_TYPE_ns1__StartMonitor:
		return soap_out_ns1__StartMonitor(soap, tag, id, (const struct ns1__StartMonitor *)ptr, "ns1:StartMonitor");
	case SOAP_TYPE_ns1__StartMonitorResponse:
		return soap_out_ns1__StartMonitorResponse(soap, tag, id, (const struct ns1__StartMonitorResponse *)ptr, "ns1:StartMonitorResponse");
	case SOAP_TYPE_ns1__SetNetCfg:
		return soap_out_ns1__SetNetCfg(soap, tag, id, (const struct ns1__SetNetCfg *)ptr, "ns1:SetNetCfg");
	case SOAP_TYPE_ns1__SetNetCfgResponse:
		return soap_out_ns1__SetNetCfgResponse(soap, tag, id, (const struct ns1__SetNetCfgResponse *)ptr, "ns1:SetNetCfgResponse");
	case SOAP_TYPE_ns1__SetGlobalCfg:
		return soap_out_ns1__SetGlobalCfg(soap, tag, id, (const struct ns1__SetGlobalCfg *)ptr, "ns1:SetGlobalCfg");
	case SOAP_TYPE_ns1__SetGlobalCfgResponse:
		return soap_out_ns1__SetGlobalCfgResponse(soap, tag, id, (const struct ns1__SetGlobalCfgResponse *)ptr, "ns1:SetGlobalCfgResponse");
	case SOAP_TYPE_ns1__SetDateTime:
		return soap_out_ns1__SetDateTime(soap, tag, id, (const struct ns1__SetDateTime *)ptr, "ns1:SetDateTime");
	case SOAP_TYPE_ns1__SetDateTimeResponse:
		return soap_out_ns1__SetDateTimeResponse(soap, tag, id, (const struct ns1__SetDateTimeResponse *)ptr, "ns1:SetDateTimeResponse");
	case SOAP_TYPE_ns1__SetChannelCfg:
		return soap_out_ns1__SetChannelCfg(soap, tag, id, (const struct ns1__SetChannelCfg *)ptr, "ns1:SetChannelCfg");
	case SOAP_TYPE_ns1__SetChannelCfgResponse:
		return soap_out_ns1__SetChannelCfgResponse(soap, tag, id, (const struct ns1__SetChannelCfgResponse *)ptr, "ns1:SetChannelCfgResponse");
	case SOAP_TYPE_ns1__SetAdminPassword:
		return soap_out_ns1__SetAdminPassword(soap, tag, id, (const struct ns1__SetAdminPassword *)ptr, "ns1:SetAdminPassword");
	case SOAP_TYPE_ns1__SetAdminPasswordResponse:
		return soap_out_ns1__SetAdminPasswordResponse(soap, tag, id, (const struct ns1__SetAdminPasswordResponse *)ptr, "ns1:SetAdminPasswordResponse");
	case SOAP_TYPE_ns1__RebootDevice:
		return soap_out_ns1__RebootDevice(soap, tag, id, (const struct ns1__RebootDevice *)ptr, "ns1:RebootDevice");
	case SOAP_TYPE_ns1__RebootDeviceResponse:
		return soap_out_ns1__RebootDeviceResponse(soap, tag, id, (const struct ns1__RebootDeviceResponse *)ptr, "ns1:RebootDeviceResponse");
	case SOAP_TYPE_ns1__QueryRecord:
		return soap_out_ns1__QueryRecord(soap, tag, id, (const struct ns1__QueryRecord *)ptr, "ns1:QueryRecord");
	case SOAP_TYPE_ns1__QueryRecordResponse:
		return soap_out_ns1__QueryRecordResponse(soap, tag, id, (const struct ns1__QueryRecordResponse *)ptr, "ns1:QueryRecordResponse");
	case SOAP_TYPE_ns1__GetLineVol:
		return soap_out_ns1__GetLineVol(soap, tag, id, (const struct ns1__GetLineVol *)ptr, "ns1:GetLineVol");
	case SOAP_TYPE_ns1__GetLineVolResponse:
		return soap_out_ns1__GetLineVolResponse(soap, tag, id, (const struct ns1__GetLineVolResponse *)ptr, "ns1:GetLineVolResponse");
	case SOAP_TYPE_ns1__GetHardwareInfo:
		return soap_out_ns1__GetHardwareInfo(soap, tag, id, (const struct ns1__GetHardwareInfo *)ptr, "ns1:GetHardwareInfo");
	case SOAP_TYPE_ns1__GetHardwareInfoResponse:
		return soap_out_ns1__GetHardwareInfoResponse(soap, tag, id, (const struct ns1__GetHardwareInfoResponse *)ptr, "ns1:GetHardwareInfoResponse");
	case SOAP_TYPE_ns1__GetGlobalCfg:
		return soap_out_ns1__GetGlobalCfg(soap, tag, id, (const struct ns1__GetGlobalCfg *)ptr, "ns1:GetGlobalCfg");
	case SOAP_TYPE_ns1__GetGlobalCfgResponse:
		return soap_out_ns1__GetGlobalCfgResponse(soap, tag, id, (const struct ns1__GetGlobalCfgResponse *)ptr, "ns1:GetGlobalCfgResponse");
	case SOAP_TYPE_ns1__GetDiskFreeSpace:
		return soap_out_ns1__GetDiskFreeSpace(soap, tag, id, (const struct ns1__GetDiskFreeSpace *)ptr, "ns1:GetDiskFreeSpace");
	case SOAP_TYPE_ns1__GetDiskFreeSpaceResponse:
		return soap_out_ns1__GetDiskFreeSpaceResponse(soap, tag, id, (const struct ns1__GetDiskFreeSpaceResponse *)ptr, "ns1:GetDiskFreeSpaceResponse");
	case SOAP_TYPE_ns1__GetDevID:
		return soap_out_ns1__GetDevID(soap, tag, id, (const struct ns1__GetDevID *)ptr, "ns1:GetDevID");
	case SOAP_TYPE_ns1__GetDevIDResponse:
		return soap_out_ns1__GetDevIDResponse(soap, tag, id, (const struct ns1__GetDevIDResponse *)ptr, "ns1:GetDevIDResponse");
	case SOAP_TYPE_ns1__GetDeviceTime:
		return soap_out_ns1__GetDeviceTime(soap, tag, id, (const struct ns1__GetDeviceTime *)ptr, "ns1:GetDeviceTime");
	case SOAP_TYPE_ns1__GetDeviceTimeResponse:
		return soap_out_ns1__GetDeviceTimeResponse(soap, tag, id, (const struct ns1__GetDeviceTimeResponse *)ptr, "ns1:GetDeviceTimeResponse");
	case SOAP_TYPE_ns1__GetChannelStatus:
		return soap_out_ns1__GetChannelStatus(soap, tag, id, (const struct ns1__GetChannelStatus *)ptr, "ns1:GetChannelStatus");
	case SOAP_TYPE_ns1__GetChannelStatusResponse:
		return soap_out_ns1__GetChannelStatusResponse(soap, tag, id, (const struct ns1__GetChannelStatusResponse *)ptr, "ns1:GetChannelStatusResponse");
	case SOAP_TYPE_ns1__GetChannelRunningStatus:
		return soap_out_ns1__GetChannelRunningStatus(soap, tag, id, (const struct ns1__GetChannelRunningStatus *)ptr, "ns1:GetChannelRunningStatus");
	case SOAP_TYPE_ns1__GetChannelRunningStatusResponse:
		return soap_out_ns1__GetChannelRunningStatusResponse(soap, tag, id, (const struct ns1__GetChannelRunningStatusResponse *)ptr, "ns1:GetChannelRunningStatusResponse");
	case SOAP_TYPE_ns1__GetChannelCfg:
		return soap_out_ns1__GetChannelCfg(soap, tag, id, (const struct ns1__GetChannelCfg *)ptr, "ns1:GetChannelCfg");
	case SOAP_TYPE_ns1__GetChannelCfgResponse:
		return soap_out_ns1__GetChannelCfgResponse(soap, tag, id, (const struct ns1__GetChannelCfgResponse *)ptr, "ns1:GetChannelCfgResponse");
	case SOAP_TYPE_ns1__ExecuteSQL:
		return soap_out_ns1__ExecuteSQL(soap, tag, id, (const struct ns1__ExecuteSQL *)ptr, "ns1:ExecuteSQL");
	case SOAP_TYPE_ns1__ExecuteSQLResponse:
		return soap_out_ns1__ExecuteSQLResponse(soap, tag, id, (const struct ns1__ExecuteSQLResponse *)ptr, "ns1:ExecuteSQLResponse");
	case SOAP_TYPE_ns1__DelRecordFile:
		return soap_out_ns1__DelRecordFile(soap, tag, id, (const struct ns1__DelRecordFile *)ptr, "ns1:DelRecordFile");
	case SOAP_TYPE_ns1__DelRecordFileResponse:
		return soap_out_ns1__DelRecordFileResponse(soap, tag, id, (const struct ns1__DelRecordFileResponse *)ptr, "ns1:DelRecordFileResponse");
	case SOAP_TYPE_ns1__DeleteFile:
		return soap_out_ns1__DeleteFile(soap, tag, id, (const struct ns1__DeleteFile *)ptr, "ns1:DeleteFile");
	case SOAP_TYPE_ns1__DeleteFileResponse:
		return soap_out_ns1__DeleteFileResponse(soap, tag, id, (const struct ns1__DeleteFileResponse *)ptr, "ns1:DeleteFileResponse");
	case SOAP_TYPE_PointerTons1__CalculateInput:
		return soap_out_PointerTons1__CalculateInput(soap, tag, id, (ns1__CalculateInput *const*)ptr, "ns1:CalculateInput");
	case SOAP_TYPE_PointerTons1__CalculateRet:
		return soap_out_PointerTons1__CalculateRet(soap, tag, id, (ns1__CalculateRet *const*)ptr, "ns1:CalculateRet");
	case SOAP_TYPE_PointerTons1__MonitorInfo:
		return soap_out_PointerTons1__MonitorInfo(soap, tag, id, (ns1__MonitorInfo *const*)ptr, "ns1:MonitorInfo");
	case SOAP_TYPE_PointerTons1__NetCfg:
		return soap_out_PointerTons1__NetCfg(soap, tag, id, (ns1__NetCfg *const*)ptr, "ns1:NetCfg");
	case SOAP_TYPE_PointerTons1__TotalChVol:
		return soap_out_PointerTons1__TotalChVol(soap, tag, id, (ns1__TotalChVol *const*)ptr, "ns1:TotalChVol");
	case SOAP_TYPE_PointerTons1__HardwareInfo:
		return soap_out_PointerTons1__HardwareInfo(soap, tag, id, (ns1__HardwareInfo *const*)ptr, "ns1:HardwareInfo");
	case SOAP_TYPE_PointerTons1__GlobalCfg:
		return soap_out_PointerTons1__GlobalCfg(soap, tag, id, (ns1__GlobalCfg *const*)ptr, "ns1:GlobalCfg");
	case SOAP_TYPE_PointerTons1__DiskSpace:
		return soap_out_PointerTons1__DiskSpace(soap, tag, id, (ns1__DiskSpace *const*)ptr, "ns1:DiskSpace");
	case SOAP_TYPE_PointerTons1__TotalChStatus:
		return soap_out_PointerTons1__TotalChStatus(soap, tag, id, (ns1__TotalChStatus *const*)ptr, "ns1:TotalChStatus");
	case SOAP_TYPE_PointerTons1__ChRunStatus:
		return soap_out_PointerTons1__ChRunStatus(soap, tag, id, (ns1__ChRunStatus *const*)ptr, "ns1:ChRunStatus");
	case SOAP_TYPE_PointerTons1__ChannelCfg:
		return soap_out_PointerTons1__ChannelCfg(soap, tag, id, (ns1__ChannelCfg *const*)ptr, "ns1:ChannelCfg");
	case SOAP_TYPE_PointerTons1__SqlResult:
		return soap_out_PointerTons1__SqlResult(soap, tag, id, (ns1__SqlResult *const*)ptr, "ns1:SqlResult");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__CalculateRet:
		((ns1__CalculateRet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CalculateInput:
		((ns1__CalculateInput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SqlResult:
		((ns1__SqlResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MonitorInfo:
		((ns1__MonitorInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NetCfg:
		((ns1__NetCfg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TotalChVol:
		((ns1__TotalChVol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HardwareInfo:
		((ns1__HardwareInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GlobalCfg:
		((ns1__GlobalCfg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DiskSpace:
		((ns1__DiskSpace *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TotalChStatus:
		((ns1__TotalChStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChRunStatus:
		((ns1__ChRunStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChannelCfg:
		((ns1__ChannelCfg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetWebPort:
		soap_serialize_ns1__GetWebPort(soap, (const struct ns1__GetWebPort *)ptr);
		break;
	case SOAP_TYPE_ns1__GetWebPortResponse:
		soap_serialize_ns1__GetWebPortResponse(soap, (const struct ns1__GetWebPortResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetWebPort:
		soap_serialize_ns1__SetWebPort(soap, (const struct ns1__SetWebPort *)ptr);
		break;
	case SOAP_TYPE_ns1__SetWebPortResponse:
		soap_serialize_ns1__SetWebPortResponse(soap, (const struct ns1__SetWebPortResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__WriteDVD:
		soap_serialize_ns1__WriteDVD(soap, (const struct ns1__WriteDVD *)ptr);
		break;
	case SOAP_TYPE_ns1__WriteDVDResponse:
		soap_serialize_ns1__WriteDVDResponse(soap, (const struct ns1__WriteDVDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__CalculateData:
		soap_serialize_ns1__CalculateData(soap, (const struct ns1__CalculateData *)ptr);
		break;
	case SOAP_TYPE_ns1__CalculateDataResponse:
		soap_serialize_ns1__CalculateDataResponse(soap, (const struct ns1__CalculateDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaAvailable:
		soap_serialize_ns1__CheckMediaAvailable(soap, (const struct ns1__CheckMediaAvailable *)ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaAvailableResponse:
		soap_serialize_ns1__CheckMediaAvailableResponse(soap, (const struct ns1__CheckMediaAvailableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaConnected:
		soap_serialize_ns1__CheckMediaConnected(soap, (const struct ns1__CheckMediaConnected *)ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaConnectedResponse:
		soap_serialize_ns1__CheckMediaConnectedResponse(soap, (const struct ns1__CheckMediaConnectedResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__StopMonitor:
		soap_serialize_ns1__StopMonitor(soap, (const struct ns1__StopMonitor *)ptr);
		break;
	case SOAP_TYPE_ns1__StopMonitorResponse:
		soap_serialize_ns1__StopMonitorResponse(soap, (const struct ns1__StopMonitorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__StartMonitor:
		soap_serialize_ns1__StartMonitor(soap, (const struct ns1__StartMonitor *)ptr);
		break;
	case SOAP_TYPE_ns1__StartMonitorResponse:
		soap_serialize_ns1__StartMonitorResponse(soap, (const struct ns1__StartMonitorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetNetCfg:
		soap_serialize_ns1__SetNetCfg(soap, (const struct ns1__SetNetCfg *)ptr);
		break;
	case SOAP_TYPE_ns1__SetNetCfgResponse:
		soap_serialize_ns1__SetNetCfgResponse(soap, (const struct ns1__SetNetCfgResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetGlobalCfg:
		soap_serialize_ns1__SetGlobalCfg(soap, (const struct ns1__SetGlobalCfg *)ptr);
		break;
	case SOAP_TYPE_ns1__SetGlobalCfgResponse:
		soap_serialize_ns1__SetGlobalCfgResponse(soap, (const struct ns1__SetGlobalCfgResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetDateTime:
		soap_serialize_ns1__SetDateTime(soap, (const struct ns1__SetDateTime *)ptr);
		break;
	case SOAP_TYPE_ns1__SetDateTimeResponse:
		soap_serialize_ns1__SetDateTimeResponse(soap, (const struct ns1__SetDateTimeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetChannelCfg:
		soap_serialize_ns1__SetChannelCfg(soap, (const struct ns1__SetChannelCfg *)ptr);
		break;
	case SOAP_TYPE_ns1__SetChannelCfgResponse:
		soap_serialize_ns1__SetChannelCfgResponse(soap, (const struct ns1__SetChannelCfgResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetAdminPassword:
		soap_serialize_ns1__SetAdminPassword(soap, (const struct ns1__SetAdminPassword *)ptr);
		break;
	case SOAP_TYPE_ns1__SetAdminPasswordResponse:
		soap_serialize_ns1__SetAdminPasswordResponse(soap, (const struct ns1__SetAdminPasswordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__RebootDevice:
		soap_serialize_ns1__RebootDevice(soap, (const struct ns1__RebootDevice *)ptr);
		break;
	case SOAP_TYPE_ns1__RebootDeviceResponse:
		soap_serialize_ns1__RebootDeviceResponse(soap, (const struct ns1__RebootDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__QueryRecord:
		soap_serialize_ns1__QueryRecord(soap, (const struct ns1__QueryRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__QueryRecordResponse:
		soap_serialize_ns1__QueryRecordResponse(soap, (const struct ns1__QueryRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetLineVol:
		soap_serialize_ns1__GetLineVol(soap, (const struct ns1__GetLineVol *)ptr);
		break;
	case SOAP_TYPE_ns1__GetLineVolResponse:
		soap_serialize_ns1__GetLineVolResponse(soap, (const struct ns1__GetLineVolResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetHardwareInfo:
		soap_serialize_ns1__GetHardwareInfo(soap, (const struct ns1__GetHardwareInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__GetHardwareInfoResponse:
		soap_serialize_ns1__GetHardwareInfoResponse(soap, (const struct ns1__GetHardwareInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetGlobalCfg:
		soap_serialize_ns1__GetGlobalCfg(soap, (const struct ns1__GetGlobalCfg *)ptr);
		break;
	case SOAP_TYPE_ns1__GetGlobalCfgResponse:
		soap_serialize_ns1__GetGlobalCfgResponse(soap, (const struct ns1__GetGlobalCfgResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetDiskFreeSpace:
		soap_serialize_ns1__GetDiskFreeSpace(soap, (const struct ns1__GetDiskFreeSpace *)ptr);
		break;
	case SOAP_TYPE_ns1__GetDiskFreeSpaceResponse:
		soap_serialize_ns1__GetDiskFreeSpaceResponse(soap, (const struct ns1__GetDiskFreeSpaceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetDevID:
		soap_serialize_ns1__GetDevID(soap, (const struct ns1__GetDevID *)ptr);
		break;
	case SOAP_TYPE_ns1__GetDevIDResponse:
		soap_serialize_ns1__GetDevIDResponse(soap, (const struct ns1__GetDevIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetDeviceTime:
		soap_serialize_ns1__GetDeviceTime(soap, (const struct ns1__GetDeviceTime *)ptr);
		break;
	case SOAP_TYPE_ns1__GetDeviceTimeResponse:
		soap_serialize_ns1__GetDeviceTimeResponse(soap, (const struct ns1__GetDeviceTimeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelStatus:
		soap_serialize_ns1__GetChannelStatus(soap, (const struct ns1__GetChannelStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelStatusResponse:
		soap_serialize_ns1__GetChannelStatusResponse(soap, (const struct ns1__GetChannelStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelRunningStatus:
		soap_serialize_ns1__GetChannelRunningStatus(soap, (const struct ns1__GetChannelRunningStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelRunningStatusResponse:
		soap_serialize_ns1__GetChannelRunningStatusResponse(soap, (const struct ns1__GetChannelRunningStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelCfg:
		soap_serialize_ns1__GetChannelCfg(soap, (const struct ns1__GetChannelCfg *)ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelCfgResponse:
		soap_serialize_ns1__GetChannelCfgResponse(soap, (const struct ns1__GetChannelCfgResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ExecuteSQL:
		soap_serialize_ns1__ExecuteSQL(soap, (const struct ns1__ExecuteSQL *)ptr);
		break;
	case SOAP_TYPE_ns1__ExecuteSQLResponse:
		soap_serialize_ns1__ExecuteSQLResponse(soap, (const struct ns1__ExecuteSQLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DelRecordFile:
		soap_serialize_ns1__DelRecordFile(soap, (const struct ns1__DelRecordFile *)ptr);
		break;
	case SOAP_TYPE_ns1__DelRecordFileResponse:
		soap_serialize_ns1__DelRecordFileResponse(soap, (const struct ns1__DelRecordFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteFile:
		soap_serialize_ns1__DeleteFile(soap, (const struct ns1__DeleteFile *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteFileResponse:
		soap_serialize_ns1__DeleteFileResponse(soap, (const struct ns1__DeleteFileResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CalculateInput:
		soap_serialize_PointerTons1__CalculateInput(soap, (ns1__CalculateInput *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CalculateRet:
		soap_serialize_PointerTons1__CalculateRet(soap, (ns1__CalculateRet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MonitorInfo:
		soap_serialize_PointerTons1__MonitorInfo(soap, (ns1__MonitorInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NetCfg:
		soap_serialize_PointerTons1__NetCfg(soap, (ns1__NetCfg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TotalChVol:
		soap_serialize_PointerTons1__TotalChVol(soap, (ns1__TotalChVol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HardwareInfo:
		soap_serialize_PointerTons1__HardwareInfo(soap, (ns1__HardwareInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GlobalCfg:
		soap_serialize_PointerTons1__GlobalCfg(soap, (ns1__GlobalCfg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DiskSpace:
		soap_serialize_PointerTons1__DiskSpace(soap, (ns1__DiskSpace *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TotalChStatus:
		soap_serialize_PointerTons1__TotalChStatus(soap, (ns1__TotalChStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChRunStatus:
		soap_serialize_PointerTons1__ChRunStatus(soap, (ns1__ChRunStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChannelCfg:
		soap_serialize_PointerTons1__ChannelCfg(soap, (ns1__ChannelCfg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SqlResult:
		soap_serialize_PointerTons1__SqlResult(soap, (ns1__SqlResult *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns1__ChannelCfg:
		return (void*)soap_instantiate_ns1__ChannelCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChRunStatus:
		return (void*)soap_instantiate_ns1__ChRunStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TotalChStatus:
		return (void*)soap_instantiate_ns1__TotalChStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DiskSpace:
		return (void*)soap_instantiate_ns1__DiskSpace(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GlobalCfg:
		return (void*)soap_instantiate_ns1__GlobalCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HardwareInfo:
		return (void*)soap_instantiate_ns1__HardwareInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TotalChVol:
		return (void*)soap_instantiate_ns1__TotalChVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NetCfg:
		return (void*)soap_instantiate_ns1__NetCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MonitorInfo:
		return (void*)soap_instantiate_ns1__MonitorInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SqlResult:
		return (void*)soap_instantiate_ns1__SqlResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CalculateInput:
		return (void*)soap_instantiate_ns1__CalculateInput(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CalculateRet:
		return (void*)soap_instantiate_ns1__CalculateRet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteFileResponse:
		return (void*)soap_instantiate_ns1__DeleteFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteFile:
		return (void*)soap_instantiate_ns1__DeleteFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DelRecordFileResponse:
		return (void*)soap_instantiate_ns1__DelRecordFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DelRecordFile:
		return (void*)soap_instantiate_ns1__DelRecordFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExecuteSQLResponse:
		return (void*)soap_instantiate_ns1__ExecuteSQLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExecuteSQL:
		return (void*)soap_instantiate_ns1__ExecuteSQL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetChannelCfgResponse:
		return (void*)soap_instantiate_ns1__GetChannelCfgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetChannelCfg:
		return (void*)soap_instantiate_ns1__GetChannelCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetChannelRunningStatusResponse:
		return (void*)soap_instantiate_ns1__GetChannelRunningStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetChannelRunningStatus:
		return (void*)soap_instantiate_ns1__GetChannelRunningStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetChannelStatusResponse:
		return (void*)soap_instantiate_ns1__GetChannelStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetChannelStatus:
		return (void*)soap_instantiate_ns1__GetChannelStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDeviceTimeResponse:
		return (void*)soap_instantiate_ns1__GetDeviceTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDeviceTime:
		return (void*)soap_instantiate_ns1__GetDeviceTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDevIDResponse:
		return (void*)soap_instantiate_ns1__GetDevIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDevID:
		return (void*)soap_instantiate_ns1__GetDevID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDiskFreeSpaceResponse:
		return (void*)soap_instantiate_ns1__GetDiskFreeSpaceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetDiskFreeSpace:
		return (void*)soap_instantiate_ns1__GetDiskFreeSpace(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetGlobalCfgResponse:
		return (void*)soap_instantiate_ns1__GetGlobalCfgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetGlobalCfg:
		return (void*)soap_instantiate_ns1__GetGlobalCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetHardwareInfoResponse:
		return (void*)soap_instantiate_ns1__GetHardwareInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetHardwareInfo:
		return (void*)soap_instantiate_ns1__GetHardwareInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetLineVolResponse:
		return (void*)soap_instantiate_ns1__GetLineVolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetLineVol:
		return (void*)soap_instantiate_ns1__GetLineVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QueryRecordResponse:
		return (void*)soap_instantiate_ns1__QueryRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QueryRecord:
		return (void*)soap_instantiate_ns1__QueryRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RebootDeviceResponse:
		return (void*)soap_instantiate_ns1__RebootDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RebootDevice:
		return (void*)soap_instantiate_ns1__RebootDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetAdminPasswordResponse:
		return (void*)soap_instantiate_ns1__SetAdminPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetAdminPassword:
		return (void*)soap_instantiate_ns1__SetAdminPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetChannelCfgResponse:
		return (void*)soap_instantiate_ns1__SetChannelCfgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetChannelCfg:
		return (void*)soap_instantiate_ns1__SetChannelCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetDateTimeResponse:
		return (void*)soap_instantiate_ns1__SetDateTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetDateTime:
		return (void*)soap_instantiate_ns1__SetDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetGlobalCfgResponse:
		return (void*)soap_instantiate_ns1__SetGlobalCfgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetGlobalCfg:
		return (void*)soap_instantiate_ns1__SetGlobalCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetNetCfgResponse:
		return (void*)soap_instantiate_ns1__SetNetCfgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetNetCfg:
		return (void*)soap_instantiate_ns1__SetNetCfg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StartMonitorResponse:
		return (void*)soap_instantiate_ns1__StartMonitorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StartMonitor:
		return (void*)soap_instantiate_ns1__StartMonitor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StopMonitorResponse:
		return (void*)soap_instantiate_ns1__StopMonitorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StopMonitor:
		return (void*)soap_instantiate_ns1__StopMonitor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CheckMediaConnectedResponse:
		return (void*)soap_instantiate_ns1__CheckMediaConnectedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CheckMediaConnected:
		return (void*)soap_instantiate_ns1__CheckMediaConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CheckMediaAvailableResponse:
		return (void*)soap_instantiate_ns1__CheckMediaAvailableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CheckMediaAvailable:
		return (void*)soap_instantiate_ns1__CheckMediaAvailable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CalculateDataResponse:
		return (void*)soap_instantiate_ns1__CalculateDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CalculateData:
		return (void*)soap_instantiate_ns1__CalculateData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteDVDResponse:
		return (void*)soap_instantiate_ns1__WriteDVDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteDVD:
		return (void*)soap_instantiate_ns1__WriteDVD(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetWebPortResponse:
		return (void*)soap_instantiate_ns1__SetWebPortResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetWebPort:
		return (void*)soap_instantiate_ns1__SetWebPort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetWebPortResponse:
		return (void*)soap_instantiate_ns1__GetWebPortResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetWebPort:
		return (void*)soap_instantiate_ns1__GetWebPort(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__ChannelCfg:
		if (p->size < 0)
			SOAP_DELETE((ns1__ChannelCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ChannelCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ChRunStatus:
		if (p->size < 0)
			SOAP_DELETE((ns1__ChRunStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ChRunStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TotalChStatus:
		if (p->size < 0)
			SOAP_DELETE((ns1__TotalChStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TotalChStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DiskSpace:
		if (p->size < 0)
			SOAP_DELETE((ns1__DiskSpace*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DiskSpace*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GlobalCfg:
		if (p->size < 0)
			SOAP_DELETE((ns1__GlobalCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__GlobalCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__HardwareInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__HardwareInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__HardwareInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TotalChVol:
		if (p->size < 0)
			SOAP_DELETE((ns1__TotalChVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TotalChVol*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NetCfg:
		if (p->size < 0)
			SOAP_DELETE((ns1__NetCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NetCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__MonitorInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__MonitorInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__MonitorInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SqlResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__SqlResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SqlResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CalculateInput:
		if (p->size < 0)
			SOAP_DELETE((ns1__CalculateInput*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CalculateInput*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CalculateRet:
		if (p->size < 0)
			SOAP_DELETE((ns1__CalculateRet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CalculateRet*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DeleteFileResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DeleteFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DeleteFileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DeleteFile:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DeleteFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DeleteFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DelRecordFileResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DelRecordFileResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DelRecordFileResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DelRecordFile:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DelRecordFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DelRecordFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ExecuteSQLResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__ExecuteSQLResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__ExecuteSQLResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ExecuteSQL:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__ExecuteSQL*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__ExecuteSQL*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelCfgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetChannelCfgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetChannelCfgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelCfg:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetChannelCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetChannelCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelRunningStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetChannelRunningStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetChannelRunningStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelRunningStatus:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetChannelRunningStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetChannelRunningStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetChannelStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetChannelStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetChannelStatus:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetChannelStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetChannelStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetDeviceTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetDeviceTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetDeviceTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetDeviceTime:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetDeviceTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetDeviceTime*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetDevIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetDevIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetDevIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetDevID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetDevID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetDevID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetDiskFreeSpaceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetDiskFreeSpaceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetDiskFreeSpaceResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetDiskFreeSpace:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetDiskFreeSpace*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetDiskFreeSpace*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetGlobalCfgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetGlobalCfgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetGlobalCfgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetGlobalCfg:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetGlobalCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetGlobalCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetHardwareInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetHardwareInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetHardwareInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetHardwareInfo:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetHardwareInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetHardwareInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetLineVolResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetLineVolResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetLineVolResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetLineVol:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetLineVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetLineVol*)p->ptr);
		break;
	case SOAP_TYPE_ns1__QueryRecordResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__QueryRecordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__QueryRecordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__QueryRecord:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__QueryRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__QueryRecord*)p->ptr);
		break;
	case SOAP_TYPE_ns1__RebootDeviceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__RebootDeviceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__RebootDeviceResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__RebootDevice:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__RebootDevice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__RebootDevice*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetAdminPasswordResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetAdminPasswordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetAdminPasswordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetAdminPassword:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetAdminPassword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetAdminPassword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetChannelCfgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetChannelCfgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetChannelCfgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetChannelCfg:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetChannelCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetChannelCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetDateTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetDateTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetDateTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetDateTime:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetDateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetDateTime*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetGlobalCfgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetGlobalCfgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetGlobalCfgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetGlobalCfg:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetGlobalCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetGlobalCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetNetCfgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetNetCfgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetNetCfgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetNetCfg:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetNetCfg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetNetCfg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StartMonitorResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__StartMonitorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__StartMonitorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StartMonitor:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__StartMonitor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__StartMonitor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StopMonitorResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__StopMonitorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__StopMonitorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StopMonitor:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__StopMonitor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__StopMonitor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaConnectedResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__CheckMediaConnectedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__CheckMediaConnectedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaConnected:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__CheckMediaConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__CheckMediaConnected*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaAvailableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__CheckMediaAvailableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__CheckMediaAvailableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CheckMediaAvailable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__CheckMediaAvailable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__CheckMediaAvailable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CalculateDataResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__CalculateDataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__CalculateDataResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CalculateData:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__CalculateData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__CalculateData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__WriteDVDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__WriteDVDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__WriteDVDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__WriteDVD:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__WriteDVD*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__WriteDVD*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetWebPortResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetWebPortResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetWebPortResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SetWebPort:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__SetWebPort*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__SetWebPort*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetWebPortResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetWebPortResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetWebPortResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetWebPort:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetWebPort*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetWebPort*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CalculateRet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__CalculateRet::totalcalls);
	soap_default_int(soap, &this->ns1__CalculateRet::totalsizeM);
	soap_default_int(soap, &this->ns1__CalculateRet::totalsizeKB);
	soap_default_int(soap, &this->ns1__CalculateRet::sizeAvailable);
	/* transient soap skipped */
}

void ns1__CalculateRet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__CalculateRet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CalculateRet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CalculateRet(struct soap *soap, const char *tag, int id, const ns1__CalculateRet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CalculateRet), type))
		return soap->error;
	if (soap_out_int(soap, "totalcalls", -1, &(a->ns1__CalculateRet::totalcalls), ""))
		return soap->error;
	if (soap_out_int(soap, "totalsizeM", -1, &(a->ns1__CalculateRet::totalsizeM), ""))
		return soap->error;
	if (soap_out_int(soap, "totalsizeKB", -1, &(a->ns1__CalculateRet::totalsizeKB), ""))
		return soap->error;
	if (soap_out_int(soap, "sizeAvailable", -1, &(a->ns1__CalculateRet::sizeAvailable), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CalculateRet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CalculateRet(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CalculateRet * SOAP_FMAC4 soap_in_ns1__CalculateRet(struct soap *soap, const char *tag, ns1__CalculateRet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CalculateRet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CalculateRet, sizeof(ns1__CalculateRet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CalculateRet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CalculateRet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_totalcalls1 = 1;
	size_t soap_flag_totalsizeM1 = 1;
	size_t soap_flag_totalsizeKB1 = 1;
	size_t soap_flag_sizeAvailable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_totalcalls1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "totalcalls", &(a->ns1__CalculateRet::totalcalls), "xsd:int"))
				{	soap_flag_totalcalls1--;
					continue;
				}
			if (soap_flag_totalsizeM1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "totalsizeM", &(a->ns1__CalculateRet::totalsizeM), "xsd:int"))
				{	soap_flag_totalsizeM1--;
					continue;
				}
			if (soap_flag_totalsizeKB1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "totalsizeKB", &(a->ns1__CalculateRet::totalsizeKB), "xsd:int"))
				{	soap_flag_totalsizeKB1--;
					continue;
				}
			if (soap_flag_sizeAvailable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sizeAvailable", &(a->ns1__CalculateRet::sizeAvailable), "xsd:int"))
				{	soap_flag_sizeAvailable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CalculateRet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CalculateRet, 0, sizeof(ns1__CalculateRet), 0, soap_copy_ns1__CalculateRet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_totalcalls1 > 0 || soap_flag_totalsizeM1 > 0 || soap_flag_totalsizeKB1 > 0 || soap_flag_sizeAvailable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CalculateRet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CalculateRet);
	if (this->soap_out(soap, tag?tag:"ns1:CalculateRet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CalculateRet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CalculateRet(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CalculateRet * SOAP_FMAC4 soap_get_ns1__CalculateRet(struct soap *soap, ns1__CalculateRet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CalculateRet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CalculateRet * SOAP_FMAC2 soap_instantiate_ns1__CalculateRet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CalculateRet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CalculateRet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CalculateRet);
		if (size)
			*size = sizeof(ns1__CalculateRet);
		((ns1__CalculateRet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CalculateRet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CalculateRet);
		for (int i = 0; i < n; i++)
			((ns1__CalculateRet*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CalculateRet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CalculateRet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CalculateRet %p -> %p\n", q, p));
	*(ns1__CalculateRet*)p = *(ns1__CalculateRet*)q;
}

void ns1__CalculateInput::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__CalculateInput::SelectType);
	soap_default_int(soap, &this->ns1__CalculateInput::start_USCOREyear);
	soap_default_int(soap, &this->ns1__CalculateInput::start_USCOREmonth);
	soap_default_int(soap, &this->ns1__CalculateInput::start_USCOREday);
	soap_default_int(soap, &this->ns1__CalculateInput::end_USCOREyear);
	soap_default_int(soap, &this->ns1__CalculateInput::end_USCOREmonth);
	soap_default_int(soap, &this->ns1__CalculateInput::end_USCOREday);
	soap_default_int(soap, &this->ns1__CalculateInput::monthwise_USCOREyear);
	soap_default_int(soap, &this->ns1__CalculateInput::monthwise_USCOREmonth);
	soap_default_int(soap, &this->ns1__CalculateInput::monthwise_USCOREday);
	soap_default_int(soap, &this->ns1__CalculateInput::mediaType);
	/* transient soap skipped */
}

void ns1__CalculateInput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__CalculateInput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CalculateInput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CalculateInput(struct soap *soap, const char *tag, int id, const ns1__CalculateInput *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CalculateInput), type))
		return soap->error;
	if (soap_out_int(soap, "SelectType", -1, &(a->ns1__CalculateInput::SelectType), ""))
		return soap->error;
	if (soap_out_int(soap, "start_year", -1, &(a->ns1__CalculateInput::start_USCOREyear), ""))
		return soap->error;
	if (soap_out_int(soap, "start_month", -1, &(a->ns1__CalculateInput::start_USCOREmonth), ""))
		return soap->error;
	if (soap_out_int(soap, "start_day", -1, &(a->ns1__CalculateInput::start_USCOREday), ""))
		return soap->error;
	if (soap_out_int(soap, "end_year", -1, &(a->ns1__CalculateInput::end_USCOREyear), ""))
		return soap->error;
	if (soap_out_int(soap, "end_month", -1, &(a->ns1__CalculateInput::end_USCOREmonth), ""))
		return soap->error;
	if (soap_out_int(soap, "end_day", -1, &(a->ns1__CalculateInput::end_USCOREday), ""))
		return soap->error;
	if (soap_out_int(soap, "monthwise_year", -1, &(a->ns1__CalculateInput::monthwise_USCOREyear), ""))
		return soap->error;
	if (soap_out_int(soap, "monthwise_month", -1, &(a->ns1__CalculateInput::monthwise_USCOREmonth), ""))
		return soap->error;
	if (soap_out_int(soap, "monthwise_day", -1, &(a->ns1__CalculateInput::monthwise_USCOREday), ""))
		return soap->error;
	if (soap_out_int(soap, "mediaType", -1, &(a->ns1__CalculateInput::mediaType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CalculateInput::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CalculateInput(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CalculateInput * SOAP_FMAC4 soap_in_ns1__CalculateInput(struct soap *soap, const char *tag, ns1__CalculateInput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CalculateInput *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CalculateInput, sizeof(ns1__CalculateInput), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CalculateInput)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CalculateInput *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SelectType1 = 1;
	size_t soap_flag_start_USCOREyear1 = 1;
	size_t soap_flag_start_USCOREmonth1 = 1;
	size_t soap_flag_start_USCOREday1 = 1;
	size_t soap_flag_end_USCOREyear1 = 1;
	size_t soap_flag_end_USCOREmonth1 = 1;
	size_t soap_flag_end_USCOREday1 = 1;
	size_t soap_flag_monthwise_USCOREyear1 = 1;
	size_t soap_flag_monthwise_USCOREmonth1 = 1;
	size_t soap_flag_monthwise_USCOREday1 = 1;
	size_t soap_flag_mediaType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SelectType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "SelectType", &(a->ns1__CalculateInput::SelectType), "xsd:int"))
				{	soap_flag_SelectType1--;
					continue;
				}
			if (soap_flag_start_USCOREyear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start_year", &(a->ns1__CalculateInput::start_USCOREyear), "xsd:int"))
				{	soap_flag_start_USCOREyear1--;
					continue;
				}
			if (soap_flag_start_USCOREmonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start_month", &(a->ns1__CalculateInput::start_USCOREmonth), "xsd:int"))
				{	soap_flag_start_USCOREmonth1--;
					continue;
				}
			if (soap_flag_start_USCOREday1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start_day", &(a->ns1__CalculateInput::start_USCOREday), "xsd:int"))
				{	soap_flag_start_USCOREday1--;
					continue;
				}
			if (soap_flag_end_USCOREyear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "end_year", &(a->ns1__CalculateInput::end_USCOREyear), "xsd:int"))
				{	soap_flag_end_USCOREyear1--;
					continue;
				}
			if (soap_flag_end_USCOREmonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "end_month", &(a->ns1__CalculateInput::end_USCOREmonth), "xsd:int"))
				{	soap_flag_end_USCOREmonth1--;
					continue;
				}
			if (soap_flag_end_USCOREday1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "end_day", &(a->ns1__CalculateInput::end_USCOREday), "xsd:int"))
				{	soap_flag_end_USCOREday1--;
					continue;
				}
			if (soap_flag_monthwise_USCOREyear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "monthwise_year", &(a->ns1__CalculateInput::monthwise_USCOREyear), "xsd:int"))
				{	soap_flag_monthwise_USCOREyear1--;
					continue;
				}
			if (soap_flag_monthwise_USCOREmonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "monthwise_month", &(a->ns1__CalculateInput::monthwise_USCOREmonth), "xsd:int"))
				{	soap_flag_monthwise_USCOREmonth1--;
					continue;
				}
			if (soap_flag_monthwise_USCOREday1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "monthwise_day", &(a->ns1__CalculateInput::monthwise_USCOREday), "xsd:int"))
				{	soap_flag_monthwise_USCOREday1--;
					continue;
				}
			if (soap_flag_mediaType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "mediaType", &(a->ns1__CalculateInput::mediaType), "xsd:int"))
				{	soap_flag_mediaType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CalculateInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CalculateInput, 0, sizeof(ns1__CalculateInput), 0, soap_copy_ns1__CalculateInput);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SelectType1 > 0 || soap_flag_start_USCOREyear1 > 0 || soap_flag_start_USCOREmonth1 > 0 || soap_flag_start_USCOREday1 > 0 || soap_flag_end_USCOREyear1 > 0 || soap_flag_end_USCOREmonth1 > 0 || soap_flag_end_USCOREday1 > 0 || soap_flag_monthwise_USCOREyear1 > 0 || soap_flag_monthwise_USCOREmonth1 > 0 || soap_flag_monthwise_USCOREday1 > 0 || soap_flag_mediaType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CalculateInput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CalculateInput);
	if (this->soap_out(soap, tag?tag:"ns1:CalculateInput", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CalculateInput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CalculateInput(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CalculateInput * SOAP_FMAC4 soap_get_ns1__CalculateInput(struct soap *soap, ns1__CalculateInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CalculateInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CalculateInput * SOAP_FMAC2 soap_instantiate_ns1__CalculateInput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CalculateInput(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CalculateInput, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CalculateInput);
		if (size)
			*size = sizeof(ns1__CalculateInput);
		((ns1__CalculateInput*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CalculateInput[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CalculateInput);
		for (int i = 0; i < n; i++)
			((ns1__CalculateInput*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CalculateInput*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CalculateInput(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CalculateInput %p -> %p\n", q, p));
	*(ns1__CalculateInput*)p = *(ns1__CalculateInput*)q;
}

void ns1__SqlResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__SqlResult::result);
	soap_default_string(soap, &this->ns1__SqlResult::sqlinfo);
	/* transient soap skipped */
}

void ns1__SqlResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__SqlResult::sqlinfo);
	/* transient soap skipped */
}

int ns1__SqlResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SqlResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SqlResult(struct soap *soap, const char *tag, int id, const ns1__SqlResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SqlResult), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &(a->ns1__SqlResult::result), ""))
		return soap->error;
	if (a->ns1__SqlResult::sqlinfo)
	{	if (soap_out_string(soap, "sqlinfo", -1, &a->ns1__SqlResult::sqlinfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "sqlinfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SqlResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SqlResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SqlResult * SOAP_FMAC4 soap_in_ns1__SqlResult(struct soap *soap, const char *tag, ns1__SqlResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SqlResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SqlResult, sizeof(ns1__SqlResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SqlResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SqlResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	size_t soap_flag_sqlinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &(a->ns1__SqlResult::result), "xsd:int"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_sqlinfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sqlinfo", &(a->ns1__SqlResult::sqlinfo), "xsd:string"))
				{	soap_flag_sqlinfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SqlResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SqlResult, 0, sizeof(ns1__SqlResult), 0, soap_copy_ns1__SqlResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0 || soap_flag_sqlinfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__SqlResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SqlResult);
	if (this->soap_out(soap, tag?tag:"ns1:SqlResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SqlResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SqlResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SqlResult * SOAP_FMAC4 soap_get_ns1__SqlResult(struct soap *soap, ns1__SqlResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SqlResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SqlResult * SOAP_FMAC2 soap_instantiate_ns1__SqlResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SqlResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SqlResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SqlResult);
		if (size)
			*size = sizeof(ns1__SqlResult);
		((ns1__SqlResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SqlResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SqlResult);
		for (int i = 0; i < n; i++)
			((ns1__SqlResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SqlResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SqlResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SqlResult %p -> %p\n", q, p));
	*(ns1__SqlResult*)p = *(ns1__SqlResult*)q;
}

void ns1__MonitorInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__MonitorInfo::ChID);
	soap_default_string(soap, &this->ns1__MonitorInfo::szRemoteIP);
	/* transient soap skipped */
}

void ns1__MonitorInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__MonitorInfo::szRemoteIP);
	/* transient soap skipped */
}

int ns1__MonitorInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MonitorInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MonitorInfo(struct soap *soap, const char *tag, int id, const ns1__MonitorInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MonitorInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ChID", -1, &(a->ns1__MonitorInfo::ChID), ""))
		return soap->error;
	if (a->ns1__MonitorInfo::szRemoteIP)
	{	if (soap_out_string(soap, "szRemoteIP", -1, &a->ns1__MonitorInfo::szRemoteIP, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szRemoteIP"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MonitorInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MonitorInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MonitorInfo * SOAP_FMAC4 soap_in_ns1__MonitorInfo(struct soap *soap, const char *tag, ns1__MonitorInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MonitorInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MonitorInfo, sizeof(ns1__MonitorInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MonitorInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MonitorInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ChID1 = 1;
	size_t soap_flag_szRemoteIP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ChID", &(a->ns1__MonitorInfo::ChID), "xsd:int"))
				{	soap_flag_ChID1--;
					continue;
				}
			if (soap_flag_szRemoteIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szRemoteIP", &(a->ns1__MonitorInfo::szRemoteIP), "xsd:string"))
				{	soap_flag_szRemoteIP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MonitorInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MonitorInfo, 0, sizeof(ns1__MonitorInfo), 0, soap_copy_ns1__MonitorInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChID1 > 0 || soap_flag_szRemoteIP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__MonitorInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MonitorInfo);
	if (this->soap_out(soap, tag?tag:"ns1:MonitorInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MonitorInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MonitorInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MonitorInfo * SOAP_FMAC4 soap_get_ns1__MonitorInfo(struct soap *soap, ns1__MonitorInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MonitorInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__MonitorInfo * SOAP_FMAC2 soap_instantiate_ns1__MonitorInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MonitorInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MonitorInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__MonitorInfo);
		if (size)
			*size = sizeof(ns1__MonitorInfo);
		((ns1__MonitorInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__MonitorInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MonitorInfo);
		for (int i = 0; i < n; i++)
			((ns1__MonitorInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MonitorInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MonitorInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MonitorInfo %p -> %p\n", q, p));
	*(ns1__MonitorInfo*)p = *(ns1__MonitorInfo*)q;
}

void ns1__NetCfg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__NetCfg::szIPAddr);
	soap_default_string(soap, &this->ns1__NetCfg::szMask);
	soap_default_string(soap, &this->ns1__NetCfg::szGateway);
	soap_default_string(soap, &this->ns1__NetCfg::szDns);
	/* transient soap skipped */
}

void ns1__NetCfg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__NetCfg::szIPAddr);
	soap_serialize_string(soap, &this->ns1__NetCfg::szMask);
	soap_serialize_string(soap, &this->ns1__NetCfg::szGateway);
	soap_serialize_string(soap, &this->ns1__NetCfg::szDns);
	/* transient soap skipped */
}

int ns1__NetCfg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NetCfg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NetCfg(struct soap *soap, const char *tag, int id, const ns1__NetCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NetCfg), type))
		return soap->error;
	if (a->ns1__NetCfg::szIPAddr)
	{	if (soap_out_string(soap, "szIPAddr", -1, &a->ns1__NetCfg::szIPAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szIPAddr"))
		return soap->error;
	if (a->ns1__NetCfg::szMask)
	{	if (soap_out_string(soap, "szMask", -1, &a->ns1__NetCfg::szMask, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szMask"))
		return soap->error;
	if (a->ns1__NetCfg::szGateway)
	{	if (soap_out_string(soap, "szGateway", -1, &a->ns1__NetCfg::szGateway, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szGateway"))
		return soap->error;
	if (a->ns1__NetCfg::szDns)
	{	if (soap_out_string(soap, "szDns", -1, &a->ns1__NetCfg::szDns, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDns"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__NetCfg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NetCfg(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NetCfg * SOAP_FMAC4 soap_in_ns1__NetCfg(struct soap *soap, const char *tag, ns1__NetCfg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NetCfg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NetCfg, sizeof(ns1__NetCfg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NetCfg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NetCfg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_szIPAddr1 = 1;
	size_t soap_flag_szMask1 = 1;
	size_t soap_flag_szGateway1 = 1;
	size_t soap_flag_szDns1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szIPAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szIPAddr", &(a->ns1__NetCfg::szIPAddr), "xsd:string"))
				{	soap_flag_szIPAddr1--;
					continue;
				}
			if (soap_flag_szMask1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szMask", &(a->ns1__NetCfg::szMask), "xsd:string"))
				{	soap_flag_szMask1--;
					continue;
				}
			if (soap_flag_szGateway1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szGateway", &(a->ns1__NetCfg::szGateway), "xsd:string"))
				{	soap_flag_szGateway1--;
					continue;
				}
			if (soap_flag_szDns1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDns", &(a->ns1__NetCfg::szDns), "xsd:string"))
				{	soap_flag_szDns1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NetCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NetCfg, 0, sizeof(ns1__NetCfg), 0, soap_copy_ns1__NetCfg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_szIPAddr1 > 0 || soap_flag_szMask1 > 0 || soap_flag_szGateway1 > 0 || soap_flag_szDns1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__NetCfg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NetCfg);
	if (this->soap_out(soap, tag?tag:"ns1:NetCfg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NetCfg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NetCfg(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NetCfg * SOAP_FMAC4 soap_get_ns1__NetCfg(struct soap *soap, ns1__NetCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NetCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NetCfg * SOAP_FMAC2 soap_instantiate_ns1__NetCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NetCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NetCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NetCfg);
		if (size)
			*size = sizeof(ns1__NetCfg);
		((ns1__NetCfg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__NetCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__NetCfg);
		for (int i = 0; i < n; i++)
			((ns1__NetCfg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__NetCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NetCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NetCfg %p -> %p\n", q, p));
	*(ns1__NetCfg*)p = *(ns1__NetCfg*)q;
}

void ns1__TotalChVol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TotalChVol::iTotalCh);
	soap_default_int(soap, &this->ns1__TotalChVol::iStartCh);
	soap_default_string(soap, &this->ns1__TotalChVol::szChVol);
	/* transient soap skipped */
}

void ns1__TotalChVol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__TotalChVol::szChVol);
	/* transient soap skipped */
}

int ns1__TotalChVol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TotalChVol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TotalChVol(struct soap *soap, const char *tag, int id, const ns1__TotalChVol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TotalChVol), type))
		return soap->error;
	if (soap_out_int(soap, "iTotalCh", -1, &(a->ns1__TotalChVol::iTotalCh), ""))
		return soap->error;
	if (soap_out_int(soap, "iStartCh", -1, &(a->ns1__TotalChVol::iStartCh), ""))
		return soap->error;
	if (a->ns1__TotalChVol::szChVol)
	{	if (soap_out_string(soap, "szChVol", -1, &a->ns1__TotalChVol::szChVol, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szChVol"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TotalChVol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TotalChVol(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TotalChVol * SOAP_FMAC4 soap_in_ns1__TotalChVol(struct soap *soap, const char *tag, ns1__TotalChVol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TotalChVol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TotalChVol, sizeof(ns1__TotalChVol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TotalChVol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TotalChVol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iTotalCh1 = 1;
	size_t soap_flag_iStartCh1 = 1;
	size_t soap_flag_szChVol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iTotalCh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iTotalCh", &(a->ns1__TotalChVol::iTotalCh), "xsd:int"))
				{	soap_flag_iTotalCh1--;
					continue;
				}
			if (soap_flag_iStartCh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iStartCh", &(a->ns1__TotalChVol::iStartCh), "xsd:int"))
				{	soap_flag_iStartCh1--;
					continue;
				}
			if (soap_flag_szChVol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szChVol", &(a->ns1__TotalChVol::szChVol), "xsd:string"))
				{	soap_flag_szChVol1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TotalChVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TotalChVol, 0, sizeof(ns1__TotalChVol), 0, soap_copy_ns1__TotalChVol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iTotalCh1 > 0 || soap_flag_iStartCh1 > 0 || soap_flag_szChVol1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TotalChVol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TotalChVol);
	if (this->soap_out(soap, tag?tag:"ns1:TotalChVol", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TotalChVol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TotalChVol(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TotalChVol * SOAP_FMAC4 soap_get_ns1__TotalChVol(struct soap *soap, ns1__TotalChVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TotalChVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TotalChVol * SOAP_FMAC2 soap_instantiate_ns1__TotalChVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TotalChVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TotalChVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TotalChVol);
		if (size)
			*size = sizeof(ns1__TotalChVol);
		((ns1__TotalChVol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__TotalChVol[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TotalChVol);
		for (int i = 0; i < n; i++)
			((ns1__TotalChVol*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TotalChVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TotalChVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TotalChVol %p -> %p\n", q, p));
	*(ns1__TotalChVol*)p = *(ns1__TotalChVol*)q;
}

void ns1__HardwareInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__HardwareInfo::TotalChannels);
	soap_default_string(soap, &this->ns1__HardwareInfo::BoardType);
	soap_default_string(soap, &this->ns1__HardwareInfo::IpAddress);
	soap_default_string(soap, &this->ns1__HardwareInfo::Gateway);
	soap_default_string(soap, &this->ns1__HardwareInfo::Macaddress);
	soap_default_string(soap, &this->ns1__HardwareInfo::Mask);
	soap_default_string(soap, &this->ns1__HardwareInfo::Dns);
	soap_default_string(soap, &this->ns1__HardwareInfo::DevID);
	soap_default_string(soap, &this->ns1__HardwareInfo::WebVersion);
	soap_default_string(soap, &this->ns1__HardwareInfo::RecSvrVersion);
	soap_default_string(soap, &this->ns1__HardwareInfo::SqlVersion);
	soap_default_string(soap, &this->ns1__HardwareInfo::kernelVersion);
	soap_default_string(soap, &this->ns1__HardwareInfo::CpldVersion);
	/* transient soap skipped */
}

void ns1__HardwareInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__HardwareInfo::BoardType);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::IpAddress);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::Gateway);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::Macaddress);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::Mask);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::Dns);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::DevID);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::WebVersion);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::RecSvrVersion);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::SqlVersion);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::kernelVersion);
	soap_serialize_string(soap, &this->ns1__HardwareInfo::CpldVersion);
	/* transient soap skipped */
}

int ns1__HardwareInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HardwareInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HardwareInfo(struct soap *soap, const char *tag, int id, const ns1__HardwareInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HardwareInfo), type))
		return soap->error;
	if (soap_out_int(soap, "TotalChannels", -1, &(a->ns1__HardwareInfo::TotalChannels), ""))
		return soap->error;
	if (a->ns1__HardwareInfo::BoardType)
	{	if (soap_out_string(soap, "BoardType", -1, &a->ns1__HardwareInfo::BoardType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "BoardType"))
		return soap->error;
	if (a->ns1__HardwareInfo::IpAddress)
	{	if (soap_out_string(soap, "IpAddress", -1, &a->ns1__HardwareInfo::IpAddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "IpAddress"))
		return soap->error;
	if (a->ns1__HardwareInfo::Gateway)
	{	if (soap_out_string(soap, "Gateway", -1, &a->ns1__HardwareInfo::Gateway, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Gateway"))
		return soap->error;
	if (a->ns1__HardwareInfo::Macaddress)
	{	if (soap_out_string(soap, "Macaddress", -1, &a->ns1__HardwareInfo::Macaddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Macaddress"))
		return soap->error;
	if (a->ns1__HardwareInfo::Mask)
	{	if (soap_out_string(soap, "Mask", -1, &a->ns1__HardwareInfo::Mask, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Mask"))
		return soap->error;
	if (a->ns1__HardwareInfo::Dns)
	{	if (soap_out_string(soap, "Dns", -1, &a->ns1__HardwareInfo::Dns, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Dns"))
		return soap->error;
	if (a->ns1__HardwareInfo::DevID)
	{	if (soap_out_string(soap, "DevID", -1, &a->ns1__HardwareInfo::DevID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "DevID"))
		return soap->error;
	if (a->ns1__HardwareInfo::WebVersion)
	{	if (soap_out_string(soap, "WebVersion", -1, &a->ns1__HardwareInfo::WebVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "WebVersion"))
		return soap->error;
	if (a->ns1__HardwareInfo::RecSvrVersion)
	{	if (soap_out_string(soap, "RecSvrVersion", -1, &a->ns1__HardwareInfo::RecSvrVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RecSvrVersion"))
		return soap->error;
	if (a->ns1__HardwareInfo::SqlVersion)
	{	if (soap_out_string(soap, "SqlVersion", -1, &a->ns1__HardwareInfo::SqlVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "SqlVersion"))
		return soap->error;
	if (a->ns1__HardwareInfo::kernelVersion)
	{	if (soap_out_string(soap, "kernelVersion", -1, &a->ns1__HardwareInfo::kernelVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "kernelVersion"))
		return soap->error;
	if (a->ns1__HardwareInfo::CpldVersion)
	{	if (soap_out_string(soap, "CpldVersion", -1, &a->ns1__HardwareInfo::CpldVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "CpldVersion"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__HardwareInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HardwareInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HardwareInfo * SOAP_FMAC4 soap_in_ns1__HardwareInfo(struct soap *soap, const char *tag, ns1__HardwareInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HardwareInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HardwareInfo, sizeof(ns1__HardwareInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HardwareInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HardwareInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TotalChannels1 = 1;
	size_t soap_flag_BoardType1 = 1;
	size_t soap_flag_IpAddress1 = 1;
	size_t soap_flag_Gateway1 = 1;
	size_t soap_flag_Macaddress1 = 1;
	size_t soap_flag_Mask1 = 1;
	size_t soap_flag_Dns1 = 1;
	size_t soap_flag_DevID1 = 1;
	size_t soap_flag_WebVersion1 = 1;
	size_t soap_flag_RecSvrVersion1 = 1;
	size_t soap_flag_SqlVersion1 = 1;
	size_t soap_flag_kernelVersion1 = 1;
	size_t soap_flag_CpldVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalChannels1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TotalChannels", &(a->ns1__HardwareInfo::TotalChannels), "xsd:int"))
				{	soap_flag_TotalChannels1--;
					continue;
				}
			if (soap_flag_BoardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "BoardType", &(a->ns1__HardwareInfo::BoardType), "xsd:string"))
				{	soap_flag_BoardType1--;
					continue;
				}
			if (soap_flag_IpAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "IpAddress", &(a->ns1__HardwareInfo::IpAddress), "xsd:string"))
				{	soap_flag_IpAddress1--;
					continue;
				}
			if (soap_flag_Gateway1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Gateway", &(a->ns1__HardwareInfo::Gateway), "xsd:string"))
				{	soap_flag_Gateway1--;
					continue;
				}
			if (soap_flag_Macaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Macaddress", &(a->ns1__HardwareInfo::Macaddress), "xsd:string"))
				{	soap_flag_Macaddress1--;
					continue;
				}
			if (soap_flag_Mask1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Mask", &(a->ns1__HardwareInfo::Mask), "xsd:string"))
				{	soap_flag_Mask1--;
					continue;
				}
			if (soap_flag_Dns1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Dns", &(a->ns1__HardwareInfo::Dns), "xsd:string"))
				{	soap_flag_Dns1--;
					continue;
				}
			if (soap_flag_DevID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DevID", &(a->ns1__HardwareInfo::DevID), "xsd:string"))
				{	soap_flag_DevID1--;
					continue;
				}
			if (soap_flag_WebVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "WebVersion", &(a->ns1__HardwareInfo::WebVersion), "xsd:string"))
				{	soap_flag_WebVersion1--;
					continue;
				}
			if (soap_flag_RecSvrVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "RecSvrVersion", &(a->ns1__HardwareInfo::RecSvrVersion), "xsd:string"))
				{	soap_flag_RecSvrVersion1--;
					continue;
				}
			if (soap_flag_SqlVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SqlVersion", &(a->ns1__HardwareInfo::SqlVersion), "xsd:string"))
				{	soap_flag_SqlVersion1--;
					continue;
				}
			if (soap_flag_kernelVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "kernelVersion", &(a->ns1__HardwareInfo::kernelVersion), "xsd:string"))
				{	soap_flag_kernelVersion1--;
					continue;
				}
			if (soap_flag_CpldVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "CpldVersion", &(a->ns1__HardwareInfo::CpldVersion), "xsd:string"))
				{	soap_flag_CpldVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HardwareInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HardwareInfo, 0, sizeof(ns1__HardwareInfo), 0, soap_copy_ns1__HardwareInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalChannels1 > 0 || soap_flag_BoardType1 > 0 || soap_flag_IpAddress1 > 0 || soap_flag_Gateway1 > 0 || soap_flag_Macaddress1 > 0 || soap_flag_Mask1 > 0 || soap_flag_Dns1 > 0 || soap_flag_DevID1 > 0 || soap_flag_WebVersion1 > 0 || soap_flag_RecSvrVersion1 > 0 || soap_flag_SqlVersion1 > 0 || soap_flag_kernelVersion1 > 0 || soap_flag_CpldVersion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__HardwareInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HardwareInfo);
	if (this->soap_out(soap, tag?tag:"ns1:HardwareInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__HardwareInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HardwareInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HardwareInfo * SOAP_FMAC4 soap_get_ns1__HardwareInfo(struct soap *soap, ns1__HardwareInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HardwareInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__HardwareInfo * SOAP_FMAC2 soap_instantiate_ns1__HardwareInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HardwareInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HardwareInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__HardwareInfo);
		if (size)
			*size = sizeof(ns1__HardwareInfo);
		((ns1__HardwareInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__HardwareInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HardwareInfo);
		for (int i = 0; i < n; i++)
			((ns1__HardwareInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HardwareInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HardwareInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HardwareInfo %p -> %p\n", q, p));
	*(ns1__HardwareInfo*)p = *(ns1__HardwareInfo*)q;
}

void ns1__GlobalCfg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__GlobalCfg::icompress);
	soap_default_int(soap, &this->ns1__GlobalCfg::ifileformat);
	soap_default_string(soap, &this->ns1__GlobalCfg::szrecpath);
	soap_default_string(soap, &this->ns1__GlobalCfg::szdevreboottime);
	soap_default_int(soap, &this->ns1__GlobalCfg::istartch);
	soap_default_int(soap, &this->ns1__GlobalCfg::itotalch);
	soap_default_int(soap, &this->ns1__GlobalCfg::cSetReboot);
	soap_default_int(soap, &this->ns1__GlobalCfg::iRebootHour);
	soap_default_int(soap, &this->ns1__GlobalCfg::iRebootMin);
	/* transient soap skipped */
}

void ns1__GlobalCfg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__GlobalCfg::szrecpath);
	soap_serialize_string(soap, &this->ns1__GlobalCfg::szdevreboottime);
	/* transient soap skipped */
}

int ns1__GlobalCfg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GlobalCfg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GlobalCfg(struct soap *soap, const char *tag, int id, const ns1__GlobalCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GlobalCfg), type))
		return soap->error;
	if (soap_out_int(soap, "icompress", -1, &(a->ns1__GlobalCfg::icompress), ""))
		return soap->error;
	if (soap_out_int(soap, "ifileformat", -1, &(a->ns1__GlobalCfg::ifileformat), ""))
		return soap->error;
	if (a->ns1__GlobalCfg::szrecpath)
	{	if (soap_out_string(soap, "szrecpath", -1, &a->ns1__GlobalCfg::szrecpath, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szrecpath"))
		return soap->error;
	if (a->ns1__GlobalCfg::szdevreboottime)
	{	if (soap_out_string(soap, "szdevreboottime", -1, &a->ns1__GlobalCfg::szdevreboottime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szdevreboottime"))
		return soap->error;
	if (soap_out_int(soap, "istartch", -1, &(a->ns1__GlobalCfg::istartch), ""))
		return soap->error;
	if (soap_out_int(soap, "itotalch", -1, &(a->ns1__GlobalCfg::itotalch), ""))
		return soap->error;
	if (soap_out_int(soap, "cSetReboot", -1, &(a->ns1__GlobalCfg::cSetReboot), ""))
		return soap->error;
	if (soap_out_int(soap, "iRebootHour", -1, &(a->ns1__GlobalCfg::iRebootHour), ""))
		return soap->error;
	if (soap_out_int(soap, "iRebootMin", -1, &(a->ns1__GlobalCfg::iRebootMin), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__GlobalCfg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GlobalCfg(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GlobalCfg * SOAP_FMAC4 soap_in_ns1__GlobalCfg(struct soap *soap, const char *tag, ns1__GlobalCfg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GlobalCfg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GlobalCfg, sizeof(ns1__GlobalCfg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GlobalCfg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GlobalCfg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_icompress1 = 1;
	size_t soap_flag_ifileformat1 = 1;
	size_t soap_flag_szrecpath1 = 1;
	size_t soap_flag_szdevreboottime1 = 1;
	size_t soap_flag_istartch1 = 1;
	size_t soap_flag_itotalch1 = 1;
	size_t soap_flag_cSetReboot1 = 1;
	size_t soap_flag_iRebootHour1 = 1;
	size_t soap_flag_iRebootMin1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_icompress1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "icompress", &(a->ns1__GlobalCfg::icompress), "xsd:int"))
				{	soap_flag_icompress1--;
					continue;
				}
			if (soap_flag_ifileformat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ifileformat", &(a->ns1__GlobalCfg::ifileformat), "xsd:int"))
				{	soap_flag_ifileformat1--;
					continue;
				}
			if (soap_flag_szrecpath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szrecpath", &(a->ns1__GlobalCfg::szrecpath), "xsd:string"))
				{	soap_flag_szrecpath1--;
					continue;
				}
			if (soap_flag_szdevreboottime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szdevreboottime", &(a->ns1__GlobalCfg::szdevreboottime), "xsd:string"))
				{	soap_flag_szdevreboottime1--;
					continue;
				}
			if (soap_flag_istartch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "istartch", &(a->ns1__GlobalCfg::istartch), "xsd:int"))
				{	soap_flag_istartch1--;
					continue;
				}
			if (soap_flag_itotalch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "itotalch", &(a->ns1__GlobalCfg::itotalch), "xsd:int"))
				{	soap_flag_itotalch1--;
					continue;
				}
			if (soap_flag_cSetReboot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cSetReboot", &(a->ns1__GlobalCfg::cSetReboot), "xsd:int"))
				{	soap_flag_cSetReboot1--;
					continue;
				}
			if (soap_flag_iRebootHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRebootHour", &(a->ns1__GlobalCfg::iRebootHour), "xsd:int"))
				{	soap_flag_iRebootHour1--;
					continue;
				}
			if (soap_flag_iRebootMin1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRebootMin", &(a->ns1__GlobalCfg::iRebootMin), "xsd:int"))
				{	soap_flag_iRebootMin1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GlobalCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GlobalCfg, 0, sizeof(ns1__GlobalCfg), 0, soap_copy_ns1__GlobalCfg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_icompress1 > 0 || soap_flag_ifileformat1 > 0 || soap_flag_szrecpath1 > 0 || soap_flag_szdevreboottime1 > 0 || soap_flag_istartch1 > 0 || soap_flag_itotalch1 > 0 || soap_flag_cSetReboot1 > 0 || soap_flag_iRebootHour1 > 0 || soap_flag_iRebootMin1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__GlobalCfg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GlobalCfg);
	if (this->soap_out(soap, tag?tag:"ns1:GlobalCfg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GlobalCfg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GlobalCfg(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GlobalCfg * SOAP_FMAC4 soap_get_ns1__GlobalCfg(struct soap *soap, ns1__GlobalCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GlobalCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__GlobalCfg * SOAP_FMAC2 soap_instantiate_ns1__GlobalCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GlobalCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GlobalCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__GlobalCfg);
		if (size)
			*size = sizeof(ns1__GlobalCfg);
		((ns1__GlobalCfg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__GlobalCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GlobalCfg);
		for (int i = 0; i < n; i++)
			((ns1__GlobalCfg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GlobalCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GlobalCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GlobalCfg %p -> %p\n", q, p));
	*(ns1__GlobalCfg*)p = *(ns1__GlobalCfg*)q;
}

void ns1__DiskSpace::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__DiskSpace::szDiskType1);
	soap_default_string(soap, &this->ns1__DiskSpace::szDiskName1);
	soap_default_int(soap, &this->ns1__DiskSpace::iDiskTotalSpace1);
	soap_default_int(soap, &this->ns1__DiskSpace::iDiskFreeSpace1);
	soap_default_string(soap, &this->ns1__DiskSpace::szDiskType2);
	soap_default_string(soap, &this->ns1__DiskSpace::szDiskName2);
	soap_default_int(soap, &this->ns1__DiskSpace::iDiskTotalSpace2);
	soap_default_int(soap, &this->ns1__DiskSpace::iDiskFreeSpace2);
	soap_default_string(soap, &this->ns1__DiskSpace::szDiskType3);
	soap_default_string(soap, &this->ns1__DiskSpace::szDiskName3);
	soap_default_int(soap, &this->ns1__DiskSpace::iDiskTotalSpace3);
	soap_default_int(soap, &this->ns1__DiskSpace::iDiskFreeSpace3);
	/* transient soap skipped */
}

void ns1__DiskSpace::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__DiskSpace::szDiskType1);
	soap_serialize_string(soap, &this->ns1__DiskSpace::szDiskName1);
	soap_serialize_string(soap, &this->ns1__DiskSpace::szDiskType2);
	soap_serialize_string(soap, &this->ns1__DiskSpace::szDiskName2);
	soap_serialize_string(soap, &this->ns1__DiskSpace::szDiskType3);
	soap_serialize_string(soap, &this->ns1__DiskSpace::szDiskName3);
	/* transient soap skipped */
}

int ns1__DiskSpace::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DiskSpace(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DiskSpace(struct soap *soap, const char *tag, int id, const ns1__DiskSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DiskSpace), type))
		return soap->error;
	if (a->ns1__DiskSpace::szDiskType1)
	{	if (soap_out_string(soap, "szDiskType1", -1, &a->ns1__DiskSpace::szDiskType1, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDiskType1"))
		return soap->error;
	if (a->ns1__DiskSpace::szDiskName1)
	{	if (soap_out_string(soap, "szDiskName1", -1, &a->ns1__DiskSpace::szDiskName1, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDiskName1"))
		return soap->error;
	if (soap_out_int(soap, "iDiskTotalSpace1", -1, &(a->ns1__DiskSpace::iDiskTotalSpace1), ""))
		return soap->error;
	if (soap_out_int(soap, "iDiskFreeSpace1", -1, &(a->ns1__DiskSpace::iDiskFreeSpace1), ""))
		return soap->error;
	if (a->ns1__DiskSpace::szDiskType2)
	{	if (soap_out_string(soap, "szDiskType2", -1, &a->ns1__DiskSpace::szDiskType2, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDiskType2"))
		return soap->error;
	if (a->ns1__DiskSpace::szDiskName2)
	{	if (soap_out_string(soap, "szDiskName2", -1, &a->ns1__DiskSpace::szDiskName2, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDiskName2"))
		return soap->error;
	if (soap_out_int(soap, "iDiskTotalSpace2", -1, &(a->ns1__DiskSpace::iDiskTotalSpace2), ""))
		return soap->error;
	if (soap_out_int(soap, "iDiskFreeSpace2", -1, &(a->ns1__DiskSpace::iDiskFreeSpace2), ""))
		return soap->error;
	if (a->ns1__DiskSpace::szDiskType3)
	{	if (soap_out_string(soap, "szDiskType3", -1, &a->ns1__DiskSpace::szDiskType3, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDiskType3"))
		return soap->error;
	if (a->ns1__DiskSpace::szDiskName3)
	{	if (soap_out_string(soap, "szDiskName3", -1, &a->ns1__DiskSpace::szDiskName3, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDiskName3"))
		return soap->error;
	if (soap_out_int(soap, "iDiskTotalSpace3", -1, &(a->ns1__DiskSpace::iDiskTotalSpace3), ""))
		return soap->error;
	if (soap_out_int(soap, "iDiskFreeSpace3", -1, &(a->ns1__DiskSpace::iDiskFreeSpace3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DiskSpace::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DiskSpace(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DiskSpace * SOAP_FMAC4 soap_in_ns1__DiskSpace(struct soap *soap, const char *tag, ns1__DiskSpace *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DiskSpace *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DiskSpace, sizeof(ns1__DiskSpace), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DiskSpace)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DiskSpace *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_szDiskType11 = 1;
	size_t soap_flag_szDiskName11 = 1;
	size_t soap_flag_iDiskTotalSpace11 = 1;
	size_t soap_flag_iDiskFreeSpace11 = 1;
	size_t soap_flag_szDiskType21 = 1;
	size_t soap_flag_szDiskName21 = 1;
	size_t soap_flag_iDiskTotalSpace21 = 1;
	size_t soap_flag_iDiskFreeSpace21 = 1;
	size_t soap_flag_szDiskType31 = 1;
	size_t soap_flag_szDiskName31 = 1;
	size_t soap_flag_iDiskTotalSpace31 = 1;
	size_t soap_flag_iDiskFreeSpace31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_szDiskType11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDiskType1", &(a->ns1__DiskSpace::szDiskType1), "xsd:string"))
				{	soap_flag_szDiskType11--;
					continue;
				}
			if (soap_flag_szDiskName11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDiskName1", &(a->ns1__DiskSpace::szDiskName1), "xsd:string"))
				{	soap_flag_szDiskName11--;
					continue;
				}
			if (soap_flag_iDiskTotalSpace11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iDiskTotalSpace1", &(a->ns1__DiskSpace::iDiskTotalSpace1), "xsd:int"))
				{	soap_flag_iDiskTotalSpace11--;
					continue;
				}
			if (soap_flag_iDiskFreeSpace11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iDiskFreeSpace1", &(a->ns1__DiskSpace::iDiskFreeSpace1), "xsd:int"))
				{	soap_flag_iDiskFreeSpace11--;
					continue;
				}
			if (soap_flag_szDiskType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDiskType2", &(a->ns1__DiskSpace::szDiskType2), "xsd:string"))
				{	soap_flag_szDiskType21--;
					continue;
				}
			if (soap_flag_szDiskName21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDiskName2", &(a->ns1__DiskSpace::szDiskName2), "xsd:string"))
				{	soap_flag_szDiskName21--;
					continue;
				}
			if (soap_flag_iDiskTotalSpace21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iDiskTotalSpace2", &(a->ns1__DiskSpace::iDiskTotalSpace2), "xsd:int"))
				{	soap_flag_iDiskTotalSpace21--;
					continue;
				}
			if (soap_flag_iDiskFreeSpace21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iDiskFreeSpace2", &(a->ns1__DiskSpace::iDiskFreeSpace2), "xsd:int"))
				{	soap_flag_iDiskFreeSpace21--;
					continue;
				}
			if (soap_flag_szDiskType31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDiskType3", &(a->ns1__DiskSpace::szDiskType3), "xsd:string"))
				{	soap_flag_szDiskType31--;
					continue;
				}
			if (soap_flag_szDiskName31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDiskName3", &(a->ns1__DiskSpace::szDiskName3), "xsd:string"))
				{	soap_flag_szDiskName31--;
					continue;
				}
			if (soap_flag_iDiskTotalSpace31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iDiskTotalSpace3", &(a->ns1__DiskSpace::iDiskTotalSpace3), "xsd:int"))
				{	soap_flag_iDiskTotalSpace31--;
					continue;
				}
			if (soap_flag_iDiskFreeSpace31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iDiskFreeSpace3", &(a->ns1__DiskSpace::iDiskFreeSpace3), "xsd:int"))
				{	soap_flag_iDiskFreeSpace31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DiskSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DiskSpace, 0, sizeof(ns1__DiskSpace), 0, soap_copy_ns1__DiskSpace);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_szDiskType11 > 0 || soap_flag_szDiskName11 > 0 || soap_flag_iDiskTotalSpace11 > 0 || soap_flag_iDiskFreeSpace11 > 0 || soap_flag_szDiskType21 > 0 || soap_flag_szDiskName21 > 0 || soap_flag_iDiskTotalSpace21 > 0 || soap_flag_iDiskFreeSpace21 > 0 || soap_flag_szDiskType31 > 0 || soap_flag_szDiskName31 > 0 || soap_flag_iDiskTotalSpace31 > 0 || soap_flag_iDiskFreeSpace31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DiskSpace::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DiskSpace);
	if (this->soap_out(soap, tag?tag:"ns1:DiskSpace", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DiskSpace::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DiskSpace(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DiskSpace * SOAP_FMAC4 soap_get_ns1__DiskSpace(struct soap *soap, ns1__DiskSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DiskSpace * SOAP_FMAC2 soap_instantiate_ns1__DiskSpace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DiskSpace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DiskSpace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DiskSpace);
		if (size)
			*size = sizeof(ns1__DiskSpace);
		((ns1__DiskSpace*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DiskSpace[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DiskSpace);
		for (int i = 0; i < n; i++)
			((ns1__DiskSpace*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DiskSpace*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DiskSpace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DiskSpace %p -> %p\n", q, p));
	*(ns1__DiskSpace*)p = *(ns1__DiskSpace*)q;
}

void ns1__TotalChStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TotalChStatus::cTotalCh);
	soap_default_int(soap, &this->ns1__TotalChStatus::iStartCh);
	soap_default_string(soap, &this->ns1__TotalChStatus::arrChStatus);
	/* transient soap skipped */
}

void ns1__TotalChStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__TotalChStatus::arrChStatus);
	/* transient soap skipped */
}

int ns1__TotalChStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TotalChStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TotalChStatus(struct soap *soap, const char *tag, int id, const ns1__TotalChStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TotalChStatus), type))
		return soap->error;
	if (soap_out_int(soap, "cTotalCh", -1, &(a->ns1__TotalChStatus::cTotalCh), ""))
		return soap->error;
	if (soap_out_int(soap, "iStartCh", -1, &(a->ns1__TotalChStatus::iStartCh), ""))
		return soap->error;
	if (a->ns1__TotalChStatus::arrChStatus)
	{	if (soap_out_string(soap, "arrChStatus", -1, &a->ns1__TotalChStatus::arrChStatus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "arrChStatus"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TotalChStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TotalChStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TotalChStatus * SOAP_FMAC4 soap_in_ns1__TotalChStatus(struct soap *soap, const char *tag, ns1__TotalChStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TotalChStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TotalChStatus, sizeof(ns1__TotalChStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TotalChStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TotalChStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cTotalCh1 = 1;
	size_t soap_flag_iStartCh1 = 1;
	size_t soap_flag_arrChStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cTotalCh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cTotalCh", &(a->ns1__TotalChStatus::cTotalCh), "xsd:int"))
				{	soap_flag_cTotalCh1--;
					continue;
				}
			if (soap_flag_iStartCh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iStartCh", &(a->ns1__TotalChStatus::iStartCh), "xsd:int"))
				{	soap_flag_iStartCh1--;
					continue;
				}
			if (soap_flag_arrChStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "arrChStatus", &(a->ns1__TotalChStatus::arrChStatus), "xsd:string"))
				{	soap_flag_arrChStatus1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TotalChStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TotalChStatus, 0, sizeof(ns1__TotalChStatus), 0, soap_copy_ns1__TotalChStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cTotalCh1 > 0 || soap_flag_iStartCh1 > 0 || soap_flag_arrChStatus1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TotalChStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TotalChStatus);
	if (this->soap_out(soap, tag?tag:"ns1:TotalChStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TotalChStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TotalChStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TotalChStatus * SOAP_FMAC4 soap_get_ns1__TotalChStatus(struct soap *soap, ns1__TotalChStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TotalChStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TotalChStatus * SOAP_FMAC2 soap_instantiate_ns1__TotalChStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TotalChStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TotalChStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TotalChStatus);
		if (size)
			*size = sizeof(ns1__TotalChStatus);
		((ns1__TotalChStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__TotalChStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TotalChStatus);
		for (int i = 0; i < n; i++)
			((ns1__TotalChStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TotalChStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TotalChStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TotalChStatus %p -> %p\n", q, p));
	*(ns1__TotalChStatus*)p = *(ns1__TotalChStatus*)q;
}

void ns1__ChRunStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ChRunStatus::cChID);
	soap_default_int(soap, &this->ns1__ChRunStatus::cChStatus);
	soap_default_int(soap, &this->ns1__ChRunStatus::cRecDir);
	soap_default_string(soap, &this->ns1__ChRunStatus::szDtmf);
	soap_default_int(soap, &this->ns1__ChRunStatus::iRecLen);
	soap_default_string(soap, &this->ns1__ChRunStatus::szRingTime);
	soap_default_int(soap, &this->ns1__ChRunStatus::cRingCnt);
	soap_default_string(soap, &this->ns1__ChRunStatus::szCallerID);
	soap_default_string(soap, &this->ns1__ChRunStatus::szCalleeID);
	/* transient soap skipped */
}

void ns1__ChRunStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__ChRunStatus::szDtmf);
	soap_serialize_string(soap, &this->ns1__ChRunStatus::szRingTime);
	soap_serialize_string(soap, &this->ns1__ChRunStatus::szCallerID);
	soap_serialize_string(soap, &this->ns1__ChRunStatus::szCalleeID);
	/* transient soap skipped */
}

int ns1__ChRunStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChRunStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChRunStatus(struct soap *soap, const char *tag, int id, const ns1__ChRunStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChRunStatus), type))
		return soap->error;
	if (soap_out_int(soap, "cChID", -1, &(a->ns1__ChRunStatus::cChID), ""))
		return soap->error;
	if (soap_out_int(soap, "cChStatus", -1, &(a->ns1__ChRunStatus::cChStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "cRecDir", -1, &(a->ns1__ChRunStatus::cRecDir), ""))
		return soap->error;
	if (a->ns1__ChRunStatus::szDtmf)
	{	if (soap_out_string(soap, "szDtmf", -1, &a->ns1__ChRunStatus::szDtmf, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szDtmf"))
		return soap->error;
	if (soap_out_int(soap, "iRecLen", -1, &(a->ns1__ChRunStatus::iRecLen), ""))
		return soap->error;
	if (a->ns1__ChRunStatus::szRingTime)
	{	if (soap_out_string(soap, "szRingTime", -1, &a->ns1__ChRunStatus::szRingTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szRingTime"))
		return soap->error;
	if (soap_out_int(soap, "cRingCnt", -1, &(a->ns1__ChRunStatus::cRingCnt), ""))
		return soap->error;
	if (a->ns1__ChRunStatus::szCallerID)
	{	if (soap_out_string(soap, "szCallerID", -1, &a->ns1__ChRunStatus::szCallerID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szCallerID"))
		return soap->error;
	if (a->ns1__ChRunStatus::szCalleeID)
	{	if (soap_out_string(soap, "szCalleeID", -1, &a->ns1__ChRunStatus::szCalleeID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szCalleeID"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ChRunStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChRunStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChRunStatus * SOAP_FMAC4 soap_in_ns1__ChRunStatus(struct soap *soap, const char *tag, ns1__ChRunStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChRunStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChRunStatus, sizeof(ns1__ChRunStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ChRunStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ChRunStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cChID1 = 1;
	size_t soap_flag_cChStatus1 = 1;
	size_t soap_flag_cRecDir1 = 1;
	size_t soap_flag_szDtmf1 = 1;
	size_t soap_flag_iRecLen1 = 1;
	size_t soap_flag_szRingTime1 = 1;
	size_t soap_flag_cRingCnt1 = 1;
	size_t soap_flag_szCallerID1 = 1;
	size_t soap_flag_szCalleeID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cChID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cChID", &(a->ns1__ChRunStatus::cChID), "xsd:int"))
				{	soap_flag_cChID1--;
					continue;
				}
			if (soap_flag_cChStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cChStatus", &(a->ns1__ChRunStatus::cChStatus), "xsd:int"))
				{	soap_flag_cChStatus1--;
					continue;
				}
			if (soap_flag_cRecDir1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cRecDir", &(a->ns1__ChRunStatus::cRecDir), "xsd:int"))
				{	soap_flag_cRecDir1--;
					continue;
				}
			if (soap_flag_szDtmf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szDtmf", &(a->ns1__ChRunStatus::szDtmf), "xsd:string"))
				{	soap_flag_szDtmf1--;
					continue;
				}
			if (soap_flag_iRecLen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRecLen", &(a->ns1__ChRunStatus::iRecLen), "xsd:int"))
				{	soap_flag_iRecLen1--;
					continue;
				}
			if (soap_flag_szRingTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szRingTime", &(a->ns1__ChRunStatus::szRingTime), "xsd:string"))
				{	soap_flag_szRingTime1--;
					continue;
				}
			if (soap_flag_cRingCnt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cRingCnt", &(a->ns1__ChRunStatus::cRingCnt), "xsd:int"))
				{	soap_flag_cRingCnt1--;
					continue;
				}
			if (soap_flag_szCallerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szCallerID", &(a->ns1__ChRunStatus::szCallerID), "xsd:string"))
				{	soap_flag_szCallerID1--;
					continue;
				}
			if (soap_flag_szCalleeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szCalleeID", &(a->ns1__ChRunStatus::szCalleeID), "xsd:string"))
				{	soap_flag_szCalleeID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ChRunStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChRunStatus, 0, sizeof(ns1__ChRunStatus), 0, soap_copy_ns1__ChRunStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cChID1 > 0 || soap_flag_cChStatus1 > 0 || soap_flag_cRecDir1 > 0 || soap_flag_szDtmf1 > 0 || soap_flag_iRecLen1 > 0 || soap_flag_szRingTime1 > 0 || soap_flag_cRingCnt1 > 0 || soap_flag_szCallerID1 > 0 || soap_flag_szCalleeID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ChRunStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ChRunStatus);
	if (this->soap_out(soap, tag?tag:"ns1:ChRunStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ChRunStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChRunStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChRunStatus * SOAP_FMAC4 soap_get_ns1__ChRunStatus(struct soap *soap, ns1__ChRunStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChRunStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ChRunStatus * SOAP_FMAC2 soap_instantiate_ns1__ChRunStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChRunStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ChRunStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ChRunStatus);
		if (size)
			*size = sizeof(ns1__ChRunStatus);
		((ns1__ChRunStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ChRunStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ChRunStatus);
		for (int i = 0; i < n; i++)
			((ns1__ChRunStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ChRunStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ChRunStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ChRunStatus %p -> %p\n", q, p));
	*(ns1__ChRunStatus*)p = *(ns1__ChRunStatus*)q;
}

void ns1__ChannelCfg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ChannelCfg::iChID);
	soap_default_int(soap, &this->ns1__ChannelCfg::iRecType);
	soap_default_int(soap, &this->ns1__ChannelCfg::iRecDir);
	soap_default_int(soap, &this->ns1__ChannelCfg::iLongRecInterval);
	soap_default_int(soap, &this->ns1__ChannelCfg::iMaxReclen);
	soap_default_int(soap, &this->ns1__ChannelCfg::iRecvDtmfTime);
	soap_default_string(soap, &this->ns1__ChannelCfg::szBindPhoneNum);
	soap_default_string(soap, &this->ns1__ChannelCfg::szStartDtmf);
	soap_default_string(soap, &this->ns1__ChannelCfg::szStopDtmf);
	/* transient soap skipped */
}

void ns1__ChannelCfg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__ChannelCfg::szBindPhoneNum);
	soap_serialize_string(soap, &this->ns1__ChannelCfg::szStartDtmf);
	soap_serialize_string(soap, &this->ns1__ChannelCfg::szStopDtmf);
	/* transient soap skipped */
}

int ns1__ChannelCfg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChannelCfg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelCfg(struct soap *soap, const char *tag, int id, const ns1__ChannelCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelCfg), type))
		return soap->error;
	if (soap_out_int(soap, "iChID", -1, &(a->ns1__ChannelCfg::iChID), ""))
		return soap->error;
	if (soap_out_int(soap, "iRecType", -1, &(a->ns1__ChannelCfg::iRecType), ""))
		return soap->error;
	if (soap_out_int(soap, "iRecDir", -1, &(a->ns1__ChannelCfg::iRecDir), ""))
		return soap->error;
	if (soap_out_int(soap, "iLongRecInterval", -1, &(a->ns1__ChannelCfg::iLongRecInterval), ""))
		return soap->error;
	if (soap_out_int(soap, "iMaxReclen", -1, &(a->ns1__ChannelCfg::iMaxReclen), ""))
		return soap->error;
	if (soap_out_int(soap, "iRecvDtmfTime", -1, &(a->ns1__ChannelCfg::iRecvDtmfTime), ""))
		return soap->error;
	if (a->ns1__ChannelCfg::szBindPhoneNum)
	{	if (soap_out_string(soap, "szBindPhoneNum", -1, &a->ns1__ChannelCfg::szBindPhoneNum, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szBindPhoneNum"))
		return soap->error;
	if (a->ns1__ChannelCfg::szStartDtmf)
	{	if (soap_out_string(soap, "szStartDtmf", -1, &a->ns1__ChannelCfg::szStartDtmf, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szStartDtmf"))
		return soap->error;
	if (a->ns1__ChannelCfg::szStopDtmf)
	{	if (soap_out_string(soap, "szStopDtmf", -1, &a->ns1__ChannelCfg::szStopDtmf, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "szStopDtmf"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ChannelCfg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChannelCfg(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChannelCfg * SOAP_FMAC4 soap_in_ns1__ChannelCfg(struct soap *soap, const char *tag, ns1__ChannelCfg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChannelCfg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelCfg, sizeof(ns1__ChannelCfg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ChannelCfg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ChannelCfg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iChID1 = 1;
	size_t soap_flag_iRecType1 = 1;
	size_t soap_flag_iRecDir1 = 1;
	size_t soap_flag_iLongRecInterval1 = 1;
	size_t soap_flag_iMaxReclen1 = 1;
	size_t soap_flag_iRecvDtmfTime1 = 1;
	size_t soap_flag_szBindPhoneNum1 = 1;
	size_t soap_flag_szStartDtmf1 = 1;
	size_t soap_flag_szStopDtmf1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iChID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iChID", &(a->ns1__ChannelCfg::iChID), "xsd:int"))
				{	soap_flag_iChID1--;
					continue;
				}
			if (soap_flag_iRecType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRecType", &(a->ns1__ChannelCfg::iRecType), "xsd:int"))
				{	soap_flag_iRecType1--;
					continue;
				}
			if (soap_flag_iRecDir1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRecDir", &(a->ns1__ChannelCfg::iRecDir), "xsd:int"))
				{	soap_flag_iRecDir1--;
					continue;
				}
			if (soap_flag_iLongRecInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iLongRecInterval", &(a->ns1__ChannelCfg::iLongRecInterval), "xsd:int"))
				{	soap_flag_iLongRecInterval1--;
					continue;
				}
			if (soap_flag_iMaxReclen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iMaxReclen", &(a->ns1__ChannelCfg::iMaxReclen), "xsd:int"))
				{	soap_flag_iMaxReclen1--;
					continue;
				}
			if (soap_flag_iRecvDtmfTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRecvDtmfTime", &(a->ns1__ChannelCfg::iRecvDtmfTime), "xsd:int"))
				{	soap_flag_iRecvDtmfTime1--;
					continue;
				}
			if (soap_flag_szBindPhoneNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szBindPhoneNum", &(a->ns1__ChannelCfg::szBindPhoneNum), "xsd:string"))
				{	soap_flag_szBindPhoneNum1--;
					continue;
				}
			if (soap_flag_szStartDtmf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szStartDtmf", &(a->ns1__ChannelCfg::szStartDtmf), "xsd:string"))
				{	soap_flag_szStartDtmf1--;
					continue;
				}
			if (soap_flag_szStopDtmf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "szStopDtmf", &(a->ns1__ChannelCfg::szStopDtmf), "xsd:string"))
				{	soap_flag_szStopDtmf1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ChannelCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelCfg, 0, sizeof(ns1__ChannelCfg), 0, soap_copy_ns1__ChannelCfg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iChID1 > 0 || soap_flag_iRecType1 > 0 || soap_flag_iRecDir1 > 0 || soap_flag_iLongRecInterval1 > 0 || soap_flag_iMaxReclen1 > 0 || soap_flag_iRecvDtmfTime1 > 0 || soap_flag_szBindPhoneNum1 > 0 || soap_flag_szStartDtmf1 > 0 || soap_flag_szStopDtmf1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ChannelCfg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ChannelCfg);
	if (this->soap_out(soap, tag?tag:"ns1:ChannelCfg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ChannelCfg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChannelCfg(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChannelCfg * SOAP_FMAC4 soap_get_ns1__ChannelCfg(struct soap *soap, ns1__ChannelCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ChannelCfg * SOAP_FMAC2 soap_instantiate_ns1__ChannelCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChannelCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ChannelCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ChannelCfg);
		if (size)
			*size = sizeof(ns1__ChannelCfg);
		((ns1__ChannelCfg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ChannelCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ChannelCfg);
		for (int i = 0; i < n; i++)
			((ns1__ChannelCfg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ChannelCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ChannelCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ChannelCfg %p -> %p\n", q, p));
	*(ns1__ChannelCfg*)p = *(ns1__ChannelCfg*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetWebPort(struct soap *soap, struct ns1__GetWebPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetWebPort(struct soap *soap, const struct ns1__GetWebPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetWebPort(struct soap *soap, const char *tag, int id, const struct ns1__GetWebPort *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetWebPort), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetWebPort * SOAP_FMAC4 soap_in_ns1__GetWebPort(struct soap *soap, const char *tag, struct ns1__GetWebPort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetWebPort *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetWebPort, sizeof(struct ns1__GetWebPort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetWebPort(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetWebPort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetWebPort, 0, sizeof(struct ns1__GetWebPort), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetWebPort(struct soap *soap, const struct ns1__GetWebPort *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetWebPort);
	if (soap_out_ns1__GetWebPort(soap, tag?tag:"ns1:GetWebPort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetWebPort * SOAP_FMAC4 soap_get_ns1__GetWebPort(struct soap *soap, struct ns1__GetWebPort *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetWebPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetWebPort * SOAP_FMAC2 soap_instantiate_ns1__GetWebPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetWebPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetWebPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetWebPort);
		if (size)
			*size = sizeof(struct ns1__GetWebPort);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetWebPort[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetWebPort);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetWebPort*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetWebPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetWebPort %p -> %p\n", q, p));
	*(struct ns1__GetWebPort*)p = *(struct ns1__GetWebPort*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetWebPortResponse(struct soap *soap, struct ns1__GetWebPortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GetWebPortResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetWebPortResponse(struct soap *soap, const struct ns1__GetWebPortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetWebPortResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetWebPortResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetWebPortResponse), type))
		return soap->error;
	if (soap_out_int(soap, "GetWebPortResponse", -1, &a->GetWebPortResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetWebPortResponse * SOAP_FMAC4 soap_in_ns1__GetWebPortResponse(struct soap *soap, const char *tag, struct ns1__GetWebPortResponse *a, const char *type)
{
	size_t soap_flag_GetWebPortResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetWebPortResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetWebPortResponse, sizeof(struct ns1__GetWebPortResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetWebPortResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetWebPortResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "GetWebPortResponse", &a->GetWebPortResponse, "xsd:int"))
				{	soap_flag_GetWebPortResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetWebPortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetWebPortResponse, 0, sizeof(struct ns1__GetWebPortResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetWebPortResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetWebPortResponse(struct soap *soap, const struct ns1__GetWebPortResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetWebPortResponse);
	if (soap_out_ns1__GetWebPortResponse(soap, tag?tag:"ns1:GetWebPortResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetWebPortResponse * SOAP_FMAC4 soap_get_ns1__GetWebPortResponse(struct soap *soap, struct ns1__GetWebPortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetWebPortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetWebPortResponse * SOAP_FMAC2 soap_instantiate_ns1__GetWebPortResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetWebPortResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetWebPortResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetWebPortResponse);
		if (size)
			*size = sizeof(struct ns1__GetWebPortResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetWebPortResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetWebPortResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetWebPortResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetWebPortResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetWebPortResponse %p -> %p\n", q, p));
	*(struct ns1__GetWebPortResponse*)p = *(struct ns1__GetWebPortResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetWebPort(struct soap *soap, struct ns1__SetWebPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->WebPort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetWebPort(struct soap *soap, const struct ns1__SetWebPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetWebPort(struct soap *soap, const char *tag, int id, const struct ns1__SetWebPort *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetWebPort), type))
		return soap->error;
	if (soap_out_int(soap, "WebPort", -1, &a->WebPort, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetWebPort * SOAP_FMAC4 soap_in_ns1__SetWebPort(struct soap *soap, const char *tag, struct ns1__SetWebPort *a, const char *type)
{
	size_t soap_flag_WebPort = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetWebPort *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetWebPort, sizeof(struct ns1__SetWebPort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetWebPort(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WebPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "WebPort", &a->WebPort, "xsd:int"))
				{	soap_flag_WebPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetWebPort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetWebPort, 0, sizeof(struct ns1__SetWebPort), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WebPort > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetWebPort(struct soap *soap, const struct ns1__SetWebPort *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetWebPort);
	if (soap_out_ns1__SetWebPort(soap, tag?tag:"ns1:SetWebPort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetWebPort * SOAP_FMAC4 soap_get_ns1__SetWebPort(struct soap *soap, struct ns1__SetWebPort *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetWebPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetWebPort * SOAP_FMAC2 soap_instantiate_ns1__SetWebPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetWebPort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetWebPort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetWebPort);
		if (size)
			*size = sizeof(struct ns1__SetWebPort);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetWebPort[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetWebPort);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetWebPort*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetWebPort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetWebPort %p -> %p\n", q, p));
	*(struct ns1__SetWebPort*)p = *(struct ns1__SetWebPort*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetWebPortResponse(struct soap *soap, struct ns1__SetWebPortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->SetWebPortResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetWebPortResponse(struct soap *soap, const struct ns1__SetWebPortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetWebPortResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetWebPortResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetWebPortResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "SetWebPortResponse", -1, &a->SetWebPortResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetWebPortResponse * SOAP_FMAC4 soap_in_ns1__SetWebPortResponse(struct soap *soap, const char *tag, struct ns1__SetWebPortResponse *a, const char *type)
{
	size_t soap_flag_SetWebPortResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetWebPortResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetWebPortResponse, sizeof(struct ns1__SetWebPortResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetWebPortResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetWebPortResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "SetWebPortResponse", &a->SetWebPortResponse, "xsd:boolean"))
				{	soap_flag_SetWebPortResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetWebPortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetWebPortResponse, 0, sizeof(struct ns1__SetWebPortResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetWebPortResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetWebPortResponse(struct soap *soap, const struct ns1__SetWebPortResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetWebPortResponse);
	if (soap_out_ns1__SetWebPortResponse(soap, tag?tag:"ns1:SetWebPortResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetWebPortResponse * SOAP_FMAC4 soap_get_ns1__SetWebPortResponse(struct soap *soap, struct ns1__SetWebPortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetWebPortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetWebPortResponse * SOAP_FMAC2 soap_instantiate_ns1__SetWebPortResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetWebPortResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetWebPortResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetWebPortResponse);
		if (size)
			*size = sizeof(struct ns1__SetWebPortResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetWebPortResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetWebPortResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetWebPortResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetWebPortResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetWebPortResponse %p -> %p\n", q, p));
	*(struct ns1__SetWebPortResponse*)p = *(struct ns1__SetWebPortResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WriteDVD(struct soap *soap, struct ns1__WriteDVD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WriteDVD(struct soap *soap, const struct ns1__WriteDVD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteDVD(struct soap *soap, const char *tag, int id, const struct ns1__WriteDVD *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteDVD), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__WriteDVD * SOAP_FMAC4 soap_in_ns1__WriteDVD(struct soap *soap, const char *tag, struct ns1__WriteDVD *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__WriteDVD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteDVD, sizeof(struct ns1__WriteDVD), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__WriteDVD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__WriteDVD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteDVD, 0, sizeof(struct ns1__WriteDVD), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WriteDVD(struct soap *soap, const struct ns1__WriteDVD *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WriteDVD);
	if (soap_out_ns1__WriteDVD(soap, tag?tag:"ns1:WriteDVD", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__WriteDVD * SOAP_FMAC4 soap_get_ns1__WriteDVD(struct soap *soap, struct ns1__WriteDVD *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteDVD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__WriteDVD * SOAP_FMAC2 soap_instantiate_ns1__WriteDVD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteDVD(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__WriteDVD, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__WriteDVD);
		if (size)
			*size = sizeof(struct ns1__WriteDVD);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__WriteDVD[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__WriteDVD);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__WriteDVD*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__WriteDVD(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__WriteDVD %p -> %p\n", q, p));
	*(struct ns1__WriteDVD*)p = *(struct ns1__WriteDVD*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__WriteDVDResponse(struct soap *soap, struct ns1__WriteDVDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->WriteDVDResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__WriteDVDResponse(struct soap *soap, const struct ns1__WriteDVDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteDVDResponse(struct soap *soap, const char *tag, int id, const struct ns1__WriteDVDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteDVDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "WriteDVDResponse", -1, &a->WriteDVDResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__WriteDVDResponse * SOAP_FMAC4 soap_in_ns1__WriteDVDResponse(struct soap *soap, const char *tag, struct ns1__WriteDVDResponse *a, const char *type)
{
	size_t soap_flag_WriteDVDResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__WriteDVDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteDVDResponse, sizeof(struct ns1__WriteDVDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__WriteDVDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WriteDVDResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "WriteDVDResponse", &a->WriteDVDResponse, "xsd:int"))
				{	soap_flag_WriteDVDResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__WriteDVDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteDVDResponse, 0, sizeof(struct ns1__WriteDVDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WriteDVDResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__WriteDVDResponse(struct soap *soap, const struct ns1__WriteDVDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__WriteDVDResponse);
	if (soap_out_ns1__WriteDVDResponse(soap, tag?tag:"ns1:WriteDVDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__WriteDVDResponse * SOAP_FMAC4 soap_get_ns1__WriteDVDResponse(struct soap *soap, struct ns1__WriteDVDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteDVDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__WriteDVDResponse * SOAP_FMAC2 soap_instantiate_ns1__WriteDVDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteDVDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__WriteDVDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__WriteDVDResponse);
		if (size)
			*size = sizeof(struct ns1__WriteDVDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__WriteDVDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__WriteDVDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__WriteDVDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__WriteDVDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__WriteDVDResponse %p -> %p\n", q, p));
	*(struct ns1__WriteDVDResponse*)p = *(struct ns1__WriteDVDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CalculateData(struct soap *soap, struct ns1__CalculateData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->calInput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CalculateData(struct soap *soap, const struct ns1__CalculateData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CalculateInput(soap, &a->calInput);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CalculateData(struct soap *soap, const char *tag, int id, const struct ns1__CalculateData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CalculateData), type))
		return soap->error;
	if (soap_out_PointerTons1__CalculateInput(soap, "calInput", -1, &a->calInput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CalculateData * SOAP_FMAC4 soap_in_ns1__CalculateData(struct soap *soap, const char *tag, struct ns1__CalculateData *a, const char *type)
{
	size_t soap_flag_calInput = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CalculateData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CalculateData, sizeof(struct ns1__CalculateData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CalculateData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_calInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CalculateInput(soap, "calInput", &a->calInput, "ns1:CalculateInput"))
				{	soap_flag_calInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CalculateData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CalculateData, 0, sizeof(struct ns1__CalculateData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CalculateData(struct soap *soap, const struct ns1__CalculateData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CalculateData);
	if (soap_out_ns1__CalculateData(soap, tag?tag:"ns1:CalculateData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CalculateData * SOAP_FMAC4 soap_get_ns1__CalculateData(struct soap *soap, struct ns1__CalculateData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CalculateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__CalculateData * SOAP_FMAC2 soap_instantiate_ns1__CalculateData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CalculateData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CalculateData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CalculateData);
		if (size)
			*size = sizeof(struct ns1__CalculateData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CalculateData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__CalculateData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__CalculateData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CalculateData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__CalculateData %p -> %p\n", q, p));
	*(struct ns1__CalculateData*)p = *(struct ns1__CalculateData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CalculateDataResponse(struct soap *soap, struct ns1__CalculateDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CalculateDataResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CalculateDataResponse(struct soap *soap, const struct ns1__CalculateDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CalculateRet(soap, &a->CalculateDataResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CalculateDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__CalculateDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CalculateDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CalculateRet(soap, "CalculateDataResponse", -1, &a->CalculateDataResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CalculateDataResponse * SOAP_FMAC4 soap_in_ns1__CalculateDataResponse(struct soap *soap, const char *tag, struct ns1__CalculateDataResponse *a, const char *type)
{
	size_t soap_flag_CalculateDataResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CalculateDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CalculateDataResponse, sizeof(struct ns1__CalculateDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CalculateDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CalculateDataResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CalculateRet(soap, "CalculateDataResponse", &a->CalculateDataResponse, "ns1:CalculateRet"))
				{	soap_flag_CalculateDataResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CalculateDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CalculateDataResponse, 0, sizeof(struct ns1__CalculateDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CalculateDataResponse(struct soap *soap, const struct ns1__CalculateDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CalculateDataResponse);
	if (soap_out_ns1__CalculateDataResponse(soap, tag?tag:"ns1:CalculateDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CalculateDataResponse * SOAP_FMAC4 soap_get_ns1__CalculateDataResponse(struct soap *soap, struct ns1__CalculateDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CalculateDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__CalculateDataResponse * SOAP_FMAC2 soap_instantiate_ns1__CalculateDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CalculateDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CalculateDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CalculateDataResponse);
		if (size)
			*size = sizeof(struct ns1__CalculateDataResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CalculateDataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__CalculateDataResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__CalculateDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CalculateDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__CalculateDataResponse %p -> %p\n", q, p));
	*(struct ns1__CalculateDataResponse*)p = *(struct ns1__CalculateDataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CheckMediaAvailable(struct soap *soap, struct ns1__CheckMediaAvailable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CheckMediaAvailable(struct soap *soap, const struct ns1__CheckMediaAvailable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CheckMediaAvailable(struct soap *soap, const char *tag, int id, const struct ns1__CheckMediaAvailable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CheckMediaAvailable), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CheckMediaAvailable * SOAP_FMAC4 soap_in_ns1__CheckMediaAvailable(struct soap *soap, const char *tag, struct ns1__CheckMediaAvailable *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CheckMediaAvailable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CheckMediaAvailable, sizeof(struct ns1__CheckMediaAvailable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CheckMediaAvailable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CheckMediaAvailable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CheckMediaAvailable, 0, sizeof(struct ns1__CheckMediaAvailable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CheckMediaAvailable(struct soap *soap, const struct ns1__CheckMediaAvailable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CheckMediaAvailable);
	if (soap_out_ns1__CheckMediaAvailable(soap, tag?tag:"ns1:CheckMediaAvailable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CheckMediaAvailable * SOAP_FMAC4 soap_get_ns1__CheckMediaAvailable(struct soap *soap, struct ns1__CheckMediaAvailable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CheckMediaAvailable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__CheckMediaAvailable * SOAP_FMAC2 soap_instantiate_ns1__CheckMediaAvailable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CheckMediaAvailable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CheckMediaAvailable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaAvailable);
		if (size)
			*size = sizeof(struct ns1__CheckMediaAvailable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaAvailable[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__CheckMediaAvailable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__CheckMediaAvailable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CheckMediaAvailable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__CheckMediaAvailable %p -> %p\n", q, p));
	*(struct ns1__CheckMediaAvailable*)p = *(struct ns1__CheckMediaAvailable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CheckMediaAvailableResponse(struct soap *soap, struct ns1__CheckMediaAvailableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->CheckMediaAvailableResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CheckMediaAvailableResponse(struct soap *soap, const struct ns1__CheckMediaAvailableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CheckMediaAvailableResponse(struct soap *soap, const char *tag, int id, const struct ns1__CheckMediaAvailableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CheckMediaAvailableResponse), type))
		return soap->error;
	if (soap_out_int(soap, "CheckMediaAvailableResponse", -1, &a->CheckMediaAvailableResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CheckMediaAvailableResponse * SOAP_FMAC4 soap_in_ns1__CheckMediaAvailableResponse(struct soap *soap, const char *tag, struct ns1__CheckMediaAvailableResponse *a, const char *type)
{
	size_t soap_flag_CheckMediaAvailableResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CheckMediaAvailableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CheckMediaAvailableResponse, sizeof(struct ns1__CheckMediaAvailableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CheckMediaAvailableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckMediaAvailableResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CheckMediaAvailableResponse", &a->CheckMediaAvailableResponse, "xsd:int"))
				{	soap_flag_CheckMediaAvailableResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CheckMediaAvailableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CheckMediaAvailableResponse, 0, sizeof(struct ns1__CheckMediaAvailableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CheckMediaAvailableResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CheckMediaAvailableResponse(struct soap *soap, const struct ns1__CheckMediaAvailableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CheckMediaAvailableResponse);
	if (soap_out_ns1__CheckMediaAvailableResponse(soap, tag?tag:"ns1:CheckMediaAvailableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CheckMediaAvailableResponse * SOAP_FMAC4 soap_get_ns1__CheckMediaAvailableResponse(struct soap *soap, struct ns1__CheckMediaAvailableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CheckMediaAvailableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__CheckMediaAvailableResponse * SOAP_FMAC2 soap_instantiate_ns1__CheckMediaAvailableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CheckMediaAvailableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CheckMediaAvailableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaAvailableResponse);
		if (size)
			*size = sizeof(struct ns1__CheckMediaAvailableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaAvailableResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__CheckMediaAvailableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__CheckMediaAvailableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CheckMediaAvailableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__CheckMediaAvailableResponse %p -> %p\n", q, p));
	*(struct ns1__CheckMediaAvailableResponse*)p = *(struct ns1__CheckMediaAvailableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CheckMediaConnected(struct soap *soap, struct ns1__CheckMediaConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CheckMediaConnected(struct soap *soap, const struct ns1__CheckMediaConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CheckMediaConnected(struct soap *soap, const char *tag, int id, const struct ns1__CheckMediaConnected *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CheckMediaConnected), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CheckMediaConnected * SOAP_FMAC4 soap_in_ns1__CheckMediaConnected(struct soap *soap, const char *tag, struct ns1__CheckMediaConnected *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CheckMediaConnected *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CheckMediaConnected, sizeof(struct ns1__CheckMediaConnected), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CheckMediaConnected(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CheckMediaConnected *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CheckMediaConnected, 0, sizeof(struct ns1__CheckMediaConnected), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CheckMediaConnected(struct soap *soap, const struct ns1__CheckMediaConnected *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CheckMediaConnected);
	if (soap_out_ns1__CheckMediaConnected(soap, tag?tag:"ns1:CheckMediaConnected", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CheckMediaConnected * SOAP_FMAC4 soap_get_ns1__CheckMediaConnected(struct soap *soap, struct ns1__CheckMediaConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CheckMediaConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__CheckMediaConnected * SOAP_FMAC2 soap_instantiate_ns1__CheckMediaConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CheckMediaConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CheckMediaConnected, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaConnected);
		if (size)
			*size = sizeof(struct ns1__CheckMediaConnected);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__CheckMediaConnected);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__CheckMediaConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CheckMediaConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__CheckMediaConnected %p -> %p\n", q, p));
	*(struct ns1__CheckMediaConnected*)p = *(struct ns1__CheckMediaConnected*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CheckMediaConnectedResponse(struct soap *soap, struct ns1__CheckMediaConnectedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->CheckMediaConnectedResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CheckMediaConnectedResponse(struct soap *soap, const struct ns1__CheckMediaConnectedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CheckMediaConnectedResponse(struct soap *soap, const char *tag, int id, const struct ns1__CheckMediaConnectedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CheckMediaConnectedResponse), type))
		return soap->error;
	if (soap_out_int(soap, "CheckMediaConnectedResponse", -1, &a->CheckMediaConnectedResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CheckMediaConnectedResponse * SOAP_FMAC4 soap_in_ns1__CheckMediaConnectedResponse(struct soap *soap, const char *tag, struct ns1__CheckMediaConnectedResponse *a, const char *type)
{
	size_t soap_flag_CheckMediaConnectedResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CheckMediaConnectedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CheckMediaConnectedResponse, sizeof(struct ns1__CheckMediaConnectedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CheckMediaConnectedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckMediaConnectedResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CheckMediaConnectedResponse", &a->CheckMediaConnectedResponse, "xsd:int"))
				{	soap_flag_CheckMediaConnectedResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CheckMediaConnectedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CheckMediaConnectedResponse, 0, sizeof(struct ns1__CheckMediaConnectedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CheckMediaConnectedResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CheckMediaConnectedResponse(struct soap *soap, const struct ns1__CheckMediaConnectedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CheckMediaConnectedResponse);
	if (soap_out_ns1__CheckMediaConnectedResponse(soap, tag?tag:"ns1:CheckMediaConnectedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CheckMediaConnectedResponse * SOAP_FMAC4 soap_get_ns1__CheckMediaConnectedResponse(struct soap *soap, struct ns1__CheckMediaConnectedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CheckMediaConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__CheckMediaConnectedResponse * SOAP_FMAC2 soap_instantiate_ns1__CheckMediaConnectedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CheckMediaConnectedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CheckMediaConnectedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaConnectedResponse);
		if (size)
			*size = sizeof(struct ns1__CheckMediaConnectedResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__CheckMediaConnectedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__CheckMediaConnectedResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__CheckMediaConnectedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CheckMediaConnectedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__CheckMediaConnectedResponse %p -> %p\n", q, p));
	*(struct ns1__CheckMediaConnectedResponse*)p = *(struct ns1__CheckMediaConnectedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StopMonitor(struct soap *soap, struct ns1__StopMonitor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->monitorInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__StopMonitor(struct soap *soap, const struct ns1__StopMonitor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MonitorInfo(soap, &a->monitorInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StopMonitor(struct soap *soap, const char *tag, int id, const struct ns1__StopMonitor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StopMonitor), type))
		return soap->error;
	if (soap_out_PointerTons1__MonitorInfo(soap, "monitorInfo", -1, &a->monitorInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__StopMonitor * SOAP_FMAC4 soap_in_ns1__StopMonitor(struct soap *soap, const char *tag, struct ns1__StopMonitor *a, const char *type)
{
	size_t soap_flag_monitorInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__StopMonitor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StopMonitor, sizeof(struct ns1__StopMonitor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__StopMonitor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_monitorInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MonitorInfo(soap, "monitorInfo", &a->monitorInfo, "ns1:MonitorInfo"))
				{	soap_flag_monitorInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__StopMonitor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StopMonitor, 0, sizeof(struct ns1__StopMonitor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StopMonitor(struct soap *soap, const struct ns1__StopMonitor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StopMonitor);
	if (soap_out_ns1__StopMonitor(soap, tag?tag:"ns1:StopMonitor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__StopMonitor * SOAP_FMAC4 soap_get_ns1__StopMonitor(struct soap *soap, struct ns1__StopMonitor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StopMonitor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__StopMonitor * SOAP_FMAC2 soap_instantiate_ns1__StopMonitor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StopMonitor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StopMonitor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StopMonitor);
		if (size)
			*size = sizeof(struct ns1__StopMonitor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StopMonitor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__StopMonitor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__StopMonitor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StopMonitor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__StopMonitor %p -> %p\n", q, p));
	*(struct ns1__StopMonitor*)p = *(struct ns1__StopMonitor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StopMonitorResponse(struct soap *soap, struct ns1__StopMonitorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->StopMonitorReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__StopMonitorResponse(struct soap *soap, const struct ns1__StopMonitorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StopMonitorResponse(struct soap *soap, const char *tag, int id, const struct ns1__StopMonitorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StopMonitorResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "StopMonitorReturn", -1, &a->StopMonitorReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__StopMonitorResponse * SOAP_FMAC4 soap_in_ns1__StopMonitorResponse(struct soap *soap, const char *tag, struct ns1__StopMonitorResponse *a, const char *type)
{
	size_t soap_flag_StopMonitorReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__StopMonitorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StopMonitorResponse, sizeof(struct ns1__StopMonitorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__StopMonitorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StopMonitorReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "StopMonitorReturn", &a->StopMonitorReturn, "xsd:boolean"))
				{	soap_flag_StopMonitorReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__StopMonitorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StopMonitorResponse, 0, sizeof(struct ns1__StopMonitorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StopMonitorReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StopMonitorResponse(struct soap *soap, const struct ns1__StopMonitorResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StopMonitorResponse);
	if (soap_out_ns1__StopMonitorResponse(soap, tag?tag:"ns1:StopMonitorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__StopMonitorResponse * SOAP_FMAC4 soap_get_ns1__StopMonitorResponse(struct soap *soap, struct ns1__StopMonitorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StopMonitorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__StopMonitorResponse * SOAP_FMAC2 soap_instantiate_ns1__StopMonitorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StopMonitorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StopMonitorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StopMonitorResponse);
		if (size)
			*size = sizeof(struct ns1__StopMonitorResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StopMonitorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__StopMonitorResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__StopMonitorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StopMonitorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__StopMonitorResponse %p -> %p\n", q, p));
	*(struct ns1__StopMonitorResponse*)p = *(struct ns1__StopMonitorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StartMonitor(struct soap *soap, struct ns1__StartMonitor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->monitorInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__StartMonitor(struct soap *soap, const struct ns1__StartMonitor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MonitorInfo(soap, &a->monitorInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StartMonitor(struct soap *soap, const char *tag, int id, const struct ns1__StartMonitor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StartMonitor), type))
		return soap->error;
	if (soap_out_PointerTons1__MonitorInfo(soap, "monitorInfo", -1, &a->monitorInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__StartMonitor * SOAP_FMAC4 soap_in_ns1__StartMonitor(struct soap *soap, const char *tag, struct ns1__StartMonitor *a, const char *type)
{
	size_t soap_flag_monitorInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__StartMonitor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StartMonitor, sizeof(struct ns1__StartMonitor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__StartMonitor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_monitorInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MonitorInfo(soap, "monitorInfo", &a->monitorInfo, "ns1:MonitorInfo"))
				{	soap_flag_monitorInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__StartMonitor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StartMonitor, 0, sizeof(struct ns1__StartMonitor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StartMonitor(struct soap *soap, const struct ns1__StartMonitor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StartMonitor);
	if (soap_out_ns1__StartMonitor(soap, tag?tag:"ns1:StartMonitor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__StartMonitor * SOAP_FMAC4 soap_get_ns1__StartMonitor(struct soap *soap, struct ns1__StartMonitor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StartMonitor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__StartMonitor * SOAP_FMAC2 soap_instantiate_ns1__StartMonitor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StartMonitor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StartMonitor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StartMonitor);
		if (size)
			*size = sizeof(struct ns1__StartMonitor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StartMonitor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__StartMonitor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__StartMonitor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StartMonitor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__StartMonitor %p -> %p\n", q, p));
	*(struct ns1__StartMonitor*)p = *(struct ns1__StartMonitor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StartMonitorResponse(struct soap *soap, struct ns1__StartMonitorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->StartMonitorReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__StartMonitorResponse(struct soap *soap, const struct ns1__StartMonitorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StartMonitorResponse(struct soap *soap, const char *tag, int id, const struct ns1__StartMonitorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StartMonitorResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "StartMonitorReturn", -1, &a->StartMonitorReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__StartMonitorResponse * SOAP_FMAC4 soap_in_ns1__StartMonitorResponse(struct soap *soap, const char *tag, struct ns1__StartMonitorResponse *a, const char *type)
{
	size_t soap_flag_StartMonitorReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__StartMonitorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StartMonitorResponse, sizeof(struct ns1__StartMonitorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__StartMonitorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartMonitorReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "StartMonitorReturn", &a->StartMonitorReturn, "xsd:boolean"))
				{	soap_flag_StartMonitorReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__StartMonitorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StartMonitorResponse, 0, sizeof(struct ns1__StartMonitorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartMonitorReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StartMonitorResponse(struct soap *soap, const struct ns1__StartMonitorResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StartMonitorResponse);
	if (soap_out_ns1__StartMonitorResponse(soap, tag?tag:"ns1:StartMonitorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__StartMonitorResponse * SOAP_FMAC4 soap_get_ns1__StartMonitorResponse(struct soap *soap, struct ns1__StartMonitorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StartMonitorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__StartMonitorResponse * SOAP_FMAC2 soap_instantiate_ns1__StartMonitorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StartMonitorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StartMonitorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StartMonitorResponse);
		if (size)
			*size = sizeof(struct ns1__StartMonitorResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__StartMonitorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__StartMonitorResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__StartMonitorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StartMonitorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__StartMonitorResponse %p -> %p\n", q, p));
	*(struct ns1__StartMonitorResponse*)p = *(struct ns1__StartMonitorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetNetCfg(struct soap *soap, struct ns1__SetNetCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NetCfg = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetNetCfg(struct soap *soap, const struct ns1__SetNetCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__NetCfg(soap, &a->NetCfg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetNetCfg(struct soap *soap, const char *tag, int id, const struct ns1__SetNetCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetNetCfg), type))
		return soap->error;
	if (soap_out_PointerTons1__NetCfg(soap, "NetCfg", -1, &a->NetCfg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetNetCfg * SOAP_FMAC4 soap_in_ns1__SetNetCfg(struct soap *soap, const char *tag, struct ns1__SetNetCfg *a, const char *type)
{
	size_t soap_flag_NetCfg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetNetCfg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetNetCfg, sizeof(struct ns1__SetNetCfg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetNetCfg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetCfg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NetCfg(soap, "NetCfg", &a->NetCfg, "ns1:NetCfg"))
				{	soap_flag_NetCfg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetNetCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetNetCfg, 0, sizeof(struct ns1__SetNetCfg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetNetCfg(struct soap *soap, const struct ns1__SetNetCfg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetNetCfg);
	if (soap_out_ns1__SetNetCfg(soap, tag?tag:"ns1:SetNetCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetNetCfg * SOAP_FMAC4 soap_get_ns1__SetNetCfg(struct soap *soap, struct ns1__SetNetCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetNetCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetNetCfg * SOAP_FMAC2 soap_instantiate_ns1__SetNetCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetNetCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetNetCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetNetCfg);
		if (size)
			*size = sizeof(struct ns1__SetNetCfg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetNetCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetNetCfg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetNetCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetNetCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetNetCfg %p -> %p\n", q, p));
	*(struct ns1__SetNetCfg*)p = *(struct ns1__SetNetCfg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetNetCfgResponse(struct soap *soap, struct ns1__SetNetCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->SetNetCfgReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetNetCfgResponse(struct soap *soap, const struct ns1__SetNetCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetNetCfgResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetNetCfgResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetNetCfgResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "SetNetCfgReturn", -1, &a->SetNetCfgReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetNetCfgResponse * SOAP_FMAC4 soap_in_ns1__SetNetCfgResponse(struct soap *soap, const char *tag, struct ns1__SetNetCfgResponse *a, const char *type)
{
	size_t soap_flag_SetNetCfgReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetNetCfgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetNetCfgResponse, sizeof(struct ns1__SetNetCfgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetNetCfgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetNetCfgReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "SetNetCfgReturn", &a->SetNetCfgReturn, "xsd:boolean"))
				{	soap_flag_SetNetCfgReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetNetCfgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetNetCfgResponse, 0, sizeof(struct ns1__SetNetCfgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetNetCfgReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetNetCfgResponse(struct soap *soap, const struct ns1__SetNetCfgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetNetCfgResponse);
	if (soap_out_ns1__SetNetCfgResponse(soap, tag?tag:"ns1:SetNetCfgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetNetCfgResponse * SOAP_FMAC4 soap_get_ns1__SetNetCfgResponse(struct soap *soap, struct ns1__SetNetCfgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetNetCfgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetNetCfgResponse * SOAP_FMAC2 soap_instantiate_ns1__SetNetCfgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetNetCfgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetNetCfgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetNetCfgResponse);
		if (size)
			*size = sizeof(struct ns1__SetNetCfgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetNetCfgResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetNetCfgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetNetCfgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetNetCfgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetNetCfgResponse %p -> %p\n", q, p));
	*(struct ns1__SetNetCfgResponse*)p = *(struct ns1__SetNetCfgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetGlobalCfg(struct soap *soap, struct ns1__SetGlobalCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->globalset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetGlobalCfg(struct soap *soap, const struct ns1__SetGlobalCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GlobalCfg(soap, &a->globalset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetGlobalCfg(struct soap *soap, const char *tag, int id, const struct ns1__SetGlobalCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetGlobalCfg), type))
		return soap->error;
	if (soap_out_PointerTons1__GlobalCfg(soap, "globalset", -1, &a->globalset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetGlobalCfg * SOAP_FMAC4 soap_in_ns1__SetGlobalCfg(struct soap *soap, const char *tag, struct ns1__SetGlobalCfg *a, const char *type)
{
	size_t soap_flag_globalset = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetGlobalCfg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetGlobalCfg, sizeof(struct ns1__SetGlobalCfg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetGlobalCfg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_globalset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GlobalCfg(soap, "globalset", &a->globalset, "ns1:GlobalCfg"))
				{	soap_flag_globalset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetGlobalCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetGlobalCfg, 0, sizeof(struct ns1__SetGlobalCfg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetGlobalCfg(struct soap *soap, const struct ns1__SetGlobalCfg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetGlobalCfg);
	if (soap_out_ns1__SetGlobalCfg(soap, tag?tag:"ns1:SetGlobalCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetGlobalCfg * SOAP_FMAC4 soap_get_ns1__SetGlobalCfg(struct soap *soap, struct ns1__SetGlobalCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetGlobalCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetGlobalCfg * SOAP_FMAC2 soap_instantiate_ns1__SetGlobalCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetGlobalCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetGlobalCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGlobalCfg);
		if (size)
			*size = sizeof(struct ns1__SetGlobalCfg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGlobalCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetGlobalCfg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetGlobalCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetGlobalCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetGlobalCfg %p -> %p\n", q, p));
	*(struct ns1__SetGlobalCfg*)p = *(struct ns1__SetGlobalCfg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetGlobalCfgResponse(struct soap *soap, struct ns1__SetGlobalCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->SetGlobalCfgReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetGlobalCfgResponse(struct soap *soap, const struct ns1__SetGlobalCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetGlobalCfgResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetGlobalCfgResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetGlobalCfgResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "SetGlobalCfgReturn", -1, &a->SetGlobalCfgReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetGlobalCfgResponse * SOAP_FMAC4 soap_in_ns1__SetGlobalCfgResponse(struct soap *soap, const char *tag, struct ns1__SetGlobalCfgResponse *a, const char *type)
{
	size_t soap_flag_SetGlobalCfgReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetGlobalCfgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetGlobalCfgResponse, sizeof(struct ns1__SetGlobalCfgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetGlobalCfgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetGlobalCfgReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "SetGlobalCfgReturn", &a->SetGlobalCfgReturn, "xsd:boolean"))
				{	soap_flag_SetGlobalCfgReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetGlobalCfgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetGlobalCfgResponse, 0, sizeof(struct ns1__SetGlobalCfgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetGlobalCfgReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetGlobalCfgResponse(struct soap *soap, const struct ns1__SetGlobalCfgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetGlobalCfgResponse);
	if (soap_out_ns1__SetGlobalCfgResponse(soap, tag?tag:"ns1:SetGlobalCfgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetGlobalCfgResponse * SOAP_FMAC4 soap_get_ns1__SetGlobalCfgResponse(struct soap *soap, struct ns1__SetGlobalCfgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetGlobalCfgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetGlobalCfgResponse * SOAP_FMAC2 soap_instantiate_ns1__SetGlobalCfgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetGlobalCfgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetGlobalCfgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGlobalCfgResponse);
		if (size)
			*size = sizeof(struct ns1__SetGlobalCfgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetGlobalCfgResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetGlobalCfgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetGlobalCfgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetGlobalCfgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetGlobalCfgResponse %p -> %p\n", q, p));
	*(struct ns1__SetGlobalCfgResponse*)p = *(struct ns1__SetGlobalCfgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetDateTime(struct soap *soap, struct ns1__SetDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetDateTime(struct soap *soap, const struct ns1__SetDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetDateTime(struct soap *soap, const char *tag, int id, const struct ns1__SetDateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetDateTime), type))
		return soap->error;
	if (soap_out_string(soap, "time", -1, &a->time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetDateTime * SOAP_FMAC4 soap_in_ns1__SetDateTime(struct soap *soap, const char *tag, struct ns1__SetDateTime *a, const char *type)
{
	size_t soap_flag_time = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetDateTime, sizeof(struct ns1__SetDateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetDateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_time && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "time", &a->time, "xsd:string"))
				{	soap_flag_time--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetDateTime, 0, sizeof(struct ns1__SetDateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetDateTime(struct soap *soap, const struct ns1__SetDateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetDateTime);
	if (soap_out_ns1__SetDateTime(soap, tag?tag:"ns1:SetDateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetDateTime * SOAP_FMAC4 soap_get_ns1__SetDateTime(struct soap *soap, struct ns1__SetDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetDateTime * SOAP_FMAC2 soap_instantiate_ns1__SetDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetDateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetDateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetDateTime);
		if (size)
			*size = sizeof(struct ns1__SetDateTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetDateTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetDateTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetDateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetDateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetDateTime %p -> %p\n", q, p));
	*(struct ns1__SetDateTime*)p = *(struct ns1__SetDateTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetDateTimeResponse(struct soap *soap, struct ns1__SetDateTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->SetDateTimeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetDateTimeResponse(struct soap *soap, const struct ns1__SetDateTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetDateTimeResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetDateTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetDateTimeResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "SetDateTimeReturn", -1, &a->SetDateTimeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetDateTimeResponse * SOAP_FMAC4 soap_in_ns1__SetDateTimeResponse(struct soap *soap, const char *tag, struct ns1__SetDateTimeResponse *a, const char *type)
{
	size_t soap_flag_SetDateTimeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetDateTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetDateTimeResponse, sizeof(struct ns1__SetDateTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetDateTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetDateTimeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "SetDateTimeReturn", &a->SetDateTimeReturn, "xsd:boolean"))
				{	soap_flag_SetDateTimeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetDateTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetDateTimeResponse, 0, sizeof(struct ns1__SetDateTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetDateTimeReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetDateTimeResponse(struct soap *soap, const struct ns1__SetDateTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetDateTimeResponse);
	if (soap_out_ns1__SetDateTimeResponse(soap, tag?tag:"ns1:SetDateTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetDateTimeResponse * SOAP_FMAC4 soap_get_ns1__SetDateTimeResponse(struct soap *soap, struct ns1__SetDateTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetDateTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetDateTimeResponse * SOAP_FMAC2 soap_instantiate_ns1__SetDateTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetDateTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetDateTimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetDateTimeResponse);
		if (size)
			*size = sizeof(struct ns1__SetDateTimeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetDateTimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetDateTimeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetDateTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetDateTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetDateTimeResponse %p -> %p\n", q, p));
	*(struct ns1__SetDateTimeResponse*)p = *(struct ns1__SetDateTimeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetChannelCfg(struct soap *soap, struct ns1__SetChannelCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->channelcfg = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetChannelCfg(struct soap *soap, const struct ns1__SetChannelCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ChannelCfg(soap, &a->channelcfg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetChannelCfg(struct soap *soap, const char *tag, int id, const struct ns1__SetChannelCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetChannelCfg), type))
		return soap->error;
	if (soap_out_PointerTons1__ChannelCfg(soap, "channelcfg", -1, &a->channelcfg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetChannelCfg * SOAP_FMAC4 soap_in_ns1__SetChannelCfg(struct soap *soap, const char *tag, struct ns1__SetChannelCfg *a, const char *type)
{
	size_t soap_flag_channelcfg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetChannelCfg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetChannelCfg, sizeof(struct ns1__SetChannelCfg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetChannelCfg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_channelcfg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ChannelCfg(soap, "channelcfg", &a->channelcfg, "ns1:ChannelCfg"))
				{	soap_flag_channelcfg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetChannelCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetChannelCfg, 0, sizeof(struct ns1__SetChannelCfg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetChannelCfg(struct soap *soap, const struct ns1__SetChannelCfg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetChannelCfg);
	if (soap_out_ns1__SetChannelCfg(soap, tag?tag:"ns1:SetChannelCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetChannelCfg * SOAP_FMAC4 soap_get_ns1__SetChannelCfg(struct soap *soap, struct ns1__SetChannelCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetChannelCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetChannelCfg * SOAP_FMAC2 soap_instantiate_ns1__SetChannelCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetChannelCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetChannelCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetChannelCfg);
		if (size)
			*size = sizeof(struct ns1__SetChannelCfg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetChannelCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetChannelCfg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetChannelCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetChannelCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetChannelCfg %p -> %p\n", q, p));
	*(struct ns1__SetChannelCfg*)p = *(struct ns1__SetChannelCfg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetChannelCfgResponse(struct soap *soap, struct ns1__SetChannelCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->SetChannelCfgReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetChannelCfgResponse(struct soap *soap, const struct ns1__SetChannelCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetChannelCfgResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetChannelCfgResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetChannelCfgResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "SetChannelCfgReturn", -1, &a->SetChannelCfgReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetChannelCfgResponse * SOAP_FMAC4 soap_in_ns1__SetChannelCfgResponse(struct soap *soap, const char *tag, struct ns1__SetChannelCfgResponse *a, const char *type)
{
	size_t soap_flag_SetChannelCfgReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetChannelCfgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetChannelCfgResponse, sizeof(struct ns1__SetChannelCfgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetChannelCfgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetChannelCfgReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "SetChannelCfgReturn", &a->SetChannelCfgReturn, "xsd:boolean"))
				{	soap_flag_SetChannelCfgReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetChannelCfgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetChannelCfgResponse, 0, sizeof(struct ns1__SetChannelCfgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetChannelCfgReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetChannelCfgResponse(struct soap *soap, const struct ns1__SetChannelCfgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetChannelCfgResponse);
	if (soap_out_ns1__SetChannelCfgResponse(soap, tag?tag:"ns1:SetChannelCfgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetChannelCfgResponse * SOAP_FMAC4 soap_get_ns1__SetChannelCfgResponse(struct soap *soap, struct ns1__SetChannelCfgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetChannelCfgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetChannelCfgResponse * SOAP_FMAC2 soap_instantiate_ns1__SetChannelCfgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetChannelCfgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetChannelCfgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetChannelCfgResponse);
		if (size)
			*size = sizeof(struct ns1__SetChannelCfgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetChannelCfgResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetChannelCfgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetChannelCfgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetChannelCfgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetChannelCfgResponse %p -> %p\n", q, p));
	*(struct ns1__SetChannelCfgResponse*)p = *(struct ns1__SetChannelCfgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetAdminPassword(struct soap *soap, struct ns1__SetAdminPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->OldPassword);
	soap_default_string(soap, &a->NewPassword);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetAdminPassword(struct soap *soap, const struct ns1__SetAdminPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->OldPassword);
	soap_serialize_string(soap, &a->NewPassword);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetAdminPassword(struct soap *soap, const char *tag, int id, const struct ns1__SetAdminPassword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetAdminPassword), type))
		return soap->error;
	if (soap_out_string(soap, "OldPassword", -1, &a->OldPassword, ""))
		return soap->error;
	if (soap_out_string(soap, "NewPassword", -1, &a->NewPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetAdminPassword * SOAP_FMAC4 soap_in_ns1__SetAdminPassword(struct soap *soap, const char *tag, struct ns1__SetAdminPassword *a, const char *type)
{
	size_t soap_flag_OldPassword = 1;
	size_t soap_flag_NewPassword = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetAdminPassword *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetAdminPassword, sizeof(struct ns1__SetAdminPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetAdminPassword(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OldPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "OldPassword", &a->OldPassword, "xsd:string"))
				{	soap_flag_OldPassword--;
					continue;
				}
			if (soap_flag_NewPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "NewPassword", &a->NewPassword, "xsd:string"))
				{	soap_flag_NewPassword--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetAdminPassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetAdminPassword, 0, sizeof(struct ns1__SetAdminPassword), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetAdminPassword(struct soap *soap, const struct ns1__SetAdminPassword *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetAdminPassword);
	if (soap_out_ns1__SetAdminPassword(soap, tag?tag:"ns1:SetAdminPassword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetAdminPassword * SOAP_FMAC4 soap_get_ns1__SetAdminPassword(struct soap *soap, struct ns1__SetAdminPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetAdminPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetAdminPassword * SOAP_FMAC2 soap_instantiate_ns1__SetAdminPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetAdminPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetAdminPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetAdminPassword);
		if (size)
			*size = sizeof(struct ns1__SetAdminPassword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetAdminPassword[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetAdminPassword);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetAdminPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetAdminPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetAdminPassword %p -> %p\n", q, p));
	*(struct ns1__SetAdminPassword*)p = *(struct ns1__SetAdminPassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetAdminPasswordResponse(struct soap *soap, struct ns1__SetAdminPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->SetAdminPasswordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetAdminPasswordResponse(struct soap *soap, const struct ns1__SetAdminPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetAdminPasswordResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetAdminPasswordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetAdminPasswordResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "SetAdminPasswordReturn", -1, &a->SetAdminPasswordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetAdminPasswordResponse * SOAP_FMAC4 soap_in_ns1__SetAdminPasswordResponse(struct soap *soap, const char *tag, struct ns1__SetAdminPasswordResponse *a, const char *type)
{
	size_t soap_flag_SetAdminPasswordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetAdminPasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetAdminPasswordResponse, sizeof(struct ns1__SetAdminPasswordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetAdminPasswordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetAdminPasswordReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "SetAdminPasswordReturn", &a->SetAdminPasswordReturn, "xsd:boolean"))
				{	soap_flag_SetAdminPasswordReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetAdminPasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetAdminPasswordResponse, 0, sizeof(struct ns1__SetAdminPasswordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SetAdminPasswordReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetAdminPasswordResponse(struct soap *soap, const struct ns1__SetAdminPasswordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SetAdminPasswordResponse);
	if (soap_out_ns1__SetAdminPasswordResponse(soap, tag?tag:"ns1:SetAdminPasswordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetAdminPasswordResponse * SOAP_FMAC4 soap_get_ns1__SetAdminPasswordResponse(struct soap *soap, struct ns1__SetAdminPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetAdminPasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__SetAdminPasswordResponse * SOAP_FMAC2 soap_instantiate_ns1__SetAdminPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetAdminPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SetAdminPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetAdminPasswordResponse);
		if (size)
			*size = sizeof(struct ns1__SetAdminPasswordResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__SetAdminPasswordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__SetAdminPasswordResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__SetAdminPasswordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SetAdminPasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__SetAdminPasswordResponse %p -> %p\n", q, p));
	*(struct ns1__SetAdminPasswordResponse*)p = *(struct ns1__SetAdminPasswordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RebootDevice(struct soap *soap, struct ns1__RebootDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->cmd);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RebootDevice(struct soap *soap, const struct ns1__RebootDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RebootDevice(struct soap *soap, const char *tag, int id, const struct ns1__RebootDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RebootDevice), type))
		return soap->error;
	if (soap_out_int(soap, "cmd", -1, &a->cmd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RebootDevice * SOAP_FMAC4 soap_in_ns1__RebootDevice(struct soap *soap, const char *tag, struct ns1__RebootDevice *a, const char *type)
{
	size_t soap_flag_cmd = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RebootDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RebootDevice, sizeof(struct ns1__RebootDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RebootDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cmd", &a->cmd, "xsd:int"))
				{	soap_flag_cmd--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RebootDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RebootDevice, 0, sizeof(struct ns1__RebootDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmd > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RebootDevice(struct soap *soap, const struct ns1__RebootDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RebootDevice);
	if (soap_out_ns1__RebootDevice(soap, tag?tag:"ns1:RebootDevice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__RebootDevice * SOAP_FMAC4 soap_get_ns1__RebootDevice(struct soap *soap, struct ns1__RebootDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RebootDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__RebootDevice * SOAP_FMAC2 soap_instantiate_ns1__RebootDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RebootDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RebootDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__RebootDevice);
		if (size)
			*size = sizeof(struct ns1__RebootDevice);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__RebootDevice[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__RebootDevice);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__RebootDevice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RebootDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__RebootDevice %p -> %p\n", q, p));
	*(struct ns1__RebootDevice*)p = *(struct ns1__RebootDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RebootDeviceResponse(struct soap *soap, struct ns1__RebootDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->RebootDeviceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RebootDeviceResponse(struct soap *soap, const struct ns1__RebootDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RebootDeviceResponse(struct soap *soap, const char *tag, int id, const struct ns1__RebootDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RebootDeviceResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "RebootDeviceReturn", -1, &a->RebootDeviceReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RebootDeviceResponse * SOAP_FMAC4 soap_in_ns1__RebootDeviceResponse(struct soap *soap, const char *tag, struct ns1__RebootDeviceResponse *a, const char *type)
{
	size_t soap_flag_RebootDeviceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RebootDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RebootDeviceResponse, sizeof(struct ns1__RebootDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RebootDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootDeviceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "RebootDeviceReturn", &a->RebootDeviceReturn, "xsd:boolean"))
				{	soap_flag_RebootDeviceReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RebootDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RebootDeviceResponse, 0, sizeof(struct ns1__RebootDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootDeviceReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RebootDeviceResponse(struct soap *soap, const struct ns1__RebootDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RebootDeviceResponse);
	if (soap_out_ns1__RebootDeviceResponse(soap, tag?tag:"ns1:RebootDeviceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__RebootDeviceResponse * SOAP_FMAC4 soap_get_ns1__RebootDeviceResponse(struct soap *soap, struct ns1__RebootDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RebootDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__RebootDeviceResponse * SOAP_FMAC2 soap_instantiate_ns1__RebootDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RebootDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RebootDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__RebootDeviceResponse);
		if (size)
			*size = sizeof(struct ns1__RebootDeviceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__RebootDeviceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__RebootDeviceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__RebootDeviceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RebootDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__RebootDeviceResponse %p -> %p\n", q, p));
	*(struct ns1__RebootDeviceResponse*)p = *(struct ns1__RebootDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__QueryRecord(struct soap *soap, struct ns1__QueryRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->StartDate);
	soap_default_string(soap, &a->StartTime);
	soap_default_string(soap, &a->EndDate);
	soap_default_string(soap, &a->EndTime);
	soap_default_int(soap, &a->StartChnl);
	soap_default_int(soap, &a->EndChnl);
	soap_default_int(soap, &a->startindex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__QueryRecord(struct soap *soap, const struct ns1__QueryRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->StartDate);
	soap_serialize_string(soap, &a->StartTime);
	soap_serialize_string(soap, &a->EndDate);
	soap_serialize_string(soap, &a->EndTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QueryRecord(struct soap *soap, const char *tag, int id, const struct ns1__QueryRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QueryRecord), type))
		return soap->error;
	if (soap_out_string(soap, "StartDate", -1, &a->StartDate, ""))
		return soap->error;
	if (soap_out_string(soap, "StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_string(soap, "EndDate", -1, &a->EndDate, ""))
		return soap->error;
	if (soap_out_string(soap, "EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_int(soap, "StartChnl", -1, &a->StartChnl, ""))
		return soap->error;
	if (soap_out_int(soap, "EndChnl", -1, &a->EndChnl, ""))
		return soap->error;
	if (soap_out_int(soap, "startindex", -1, &a->startindex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__QueryRecord * SOAP_FMAC4 soap_in_ns1__QueryRecord(struct soap *soap, const char *tag, struct ns1__QueryRecord *a, const char *type)
{
	size_t soap_flag_StartDate = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndDate = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_StartChnl = 1;
	size_t soap_flag_EndChnl = 1;
	size_t soap_flag_startindex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__QueryRecord *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryRecord, sizeof(struct ns1__QueryRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__QueryRecord(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "StartDate", &a->StartDate, "xsd:string"))
				{	soap_flag_StartDate--;
					continue;
				}
			if (soap_flag_StartTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "StartTime", &a->StartTime, "xsd:string"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "EndDate", &a->EndDate, "xsd:string"))
				{	soap_flag_EndDate--;
					continue;
				}
			if (soap_flag_EndTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "EndTime", &a->EndTime, "xsd:string"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_StartChnl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "StartChnl", &a->StartChnl, "xsd:int"))
				{	soap_flag_StartChnl--;
					continue;
				}
			if (soap_flag_EndChnl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "EndChnl", &a->EndChnl, "xsd:int"))
				{	soap_flag_EndChnl--;
					continue;
				}
			if (soap_flag_startindex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startindex", &a->startindex, "xsd:int"))
				{	soap_flag_startindex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__QueryRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QueryRecord, 0, sizeof(struct ns1__QueryRecord), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartChnl > 0 || soap_flag_EndChnl > 0 || soap_flag_startindex > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__QueryRecord(struct soap *soap, const struct ns1__QueryRecord *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__QueryRecord);
	if (soap_out_ns1__QueryRecord(soap, tag?tag:"ns1:QueryRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__QueryRecord * SOAP_FMAC4 soap_get_ns1__QueryRecord(struct soap *soap, struct ns1__QueryRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QueryRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__QueryRecord * SOAP_FMAC2 soap_instantiate_ns1__QueryRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QueryRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__QueryRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__QueryRecord);
		if (size)
			*size = sizeof(struct ns1__QueryRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__QueryRecord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__QueryRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__QueryRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__QueryRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__QueryRecord %p -> %p\n", q, p));
	*(struct ns1__QueryRecord*)p = *(struct ns1__QueryRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__QueryRecordResponse(struct soap *soap, struct ns1__QueryRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->QueryRecordReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__QueryRecordResponse(struct soap *soap, const struct ns1__QueryRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SqlResult(soap, &a->QueryRecordReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QueryRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__QueryRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QueryRecordResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__SqlResult(soap, "QueryRecordReturn", -1, &a->QueryRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__QueryRecordResponse * SOAP_FMAC4 soap_in_ns1__QueryRecordResponse(struct soap *soap, const char *tag, struct ns1__QueryRecordResponse *a, const char *type)
{
	size_t soap_flag_QueryRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__QueryRecordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryRecordResponse, sizeof(struct ns1__QueryRecordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__QueryRecordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QueryRecordReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SqlResult(soap, "QueryRecordReturn", &a->QueryRecordReturn, "ns1:SqlResult"))
				{	soap_flag_QueryRecordReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__QueryRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QueryRecordResponse, 0, sizeof(struct ns1__QueryRecordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__QueryRecordResponse(struct soap *soap, const struct ns1__QueryRecordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__QueryRecordResponse);
	if (soap_out_ns1__QueryRecordResponse(soap, tag?tag:"ns1:QueryRecordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__QueryRecordResponse * SOAP_FMAC4 soap_get_ns1__QueryRecordResponse(struct soap *soap, struct ns1__QueryRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QueryRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__QueryRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__QueryRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QueryRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__QueryRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__QueryRecordResponse);
		if (size)
			*size = sizeof(struct ns1__QueryRecordResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__QueryRecordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__QueryRecordResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__QueryRecordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__QueryRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__QueryRecordResponse %p -> %p\n", q, p));
	*(struct ns1__QueryRecordResponse*)p = *(struct ns1__QueryRecordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetLineVol(struct soap *soap, struct ns1__GetLineVol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetLineVol(struct soap *soap, const struct ns1__GetLineVol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetLineVol(struct soap *soap, const char *tag, int id, const struct ns1__GetLineVol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetLineVol), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetLineVol * SOAP_FMAC4 soap_in_ns1__GetLineVol(struct soap *soap, const char *tag, struct ns1__GetLineVol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetLineVol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetLineVol, sizeof(struct ns1__GetLineVol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetLineVol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetLineVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetLineVol, 0, sizeof(struct ns1__GetLineVol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetLineVol(struct soap *soap, const struct ns1__GetLineVol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetLineVol);
	if (soap_out_ns1__GetLineVol(soap, tag?tag:"ns1:GetLineVol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetLineVol * SOAP_FMAC4 soap_get_ns1__GetLineVol(struct soap *soap, struct ns1__GetLineVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetLineVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetLineVol * SOAP_FMAC2 soap_instantiate_ns1__GetLineVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetLineVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetLineVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetLineVol);
		if (size)
			*size = sizeof(struct ns1__GetLineVol);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetLineVol[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetLineVol);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetLineVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetLineVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetLineVol %p -> %p\n", q, p));
	*(struct ns1__GetLineVol*)p = *(struct ns1__GetLineVol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetLineVolResponse(struct soap *soap, struct ns1__GetLineVolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetLineVolReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetLineVolResponse(struct soap *soap, const struct ns1__GetLineVolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TotalChVol(soap, &a->GetLineVolReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetLineVolResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetLineVolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetLineVolResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TotalChVol(soap, "GetLineVolReturn", -1, &a->GetLineVolReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetLineVolResponse * SOAP_FMAC4 soap_in_ns1__GetLineVolResponse(struct soap *soap, const char *tag, struct ns1__GetLineVolResponse *a, const char *type)
{
	size_t soap_flag_GetLineVolReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetLineVolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetLineVolResponse, sizeof(struct ns1__GetLineVolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetLineVolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLineVolReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TotalChVol(soap, "GetLineVolReturn", &a->GetLineVolReturn, "ns1:TotalChVol"))
				{	soap_flag_GetLineVolReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetLineVolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetLineVolResponse, 0, sizeof(struct ns1__GetLineVolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetLineVolResponse(struct soap *soap, const struct ns1__GetLineVolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetLineVolResponse);
	if (soap_out_ns1__GetLineVolResponse(soap, tag?tag:"ns1:GetLineVolResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetLineVolResponse * SOAP_FMAC4 soap_get_ns1__GetLineVolResponse(struct soap *soap, struct ns1__GetLineVolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetLineVolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetLineVolResponse * SOAP_FMAC2 soap_instantiate_ns1__GetLineVolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetLineVolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetLineVolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetLineVolResponse);
		if (size)
			*size = sizeof(struct ns1__GetLineVolResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetLineVolResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetLineVolResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetLineVolResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetLineVolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetLineVolResponse %p -> %p\n", q, p));
	*(struct ns1__GetLineVolResponse*)p = *(struct ns1__GetLineVolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetHardwareInfo(struct soap *soap, struct ns1__GetHardwareInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetHardwareInfo(struct soap *soap, const struct ns1__GetHardwareInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetHardwareInfo(struct soap *soap, const char *tag, int id, const struct ns1__GetHardwareInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetHardwareInfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetHardwareInfo * SOAP_FMAC4 soap_in_ns1__GetHardwareInfo(struct soap *soap, const char *tag, struct ns1__GetHardwareInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetHardwareInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetHardwareInfo, sizeof(struct ns1__GetHardwareInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetHardwareInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetHardwareInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetHardwareInfo, 0, sizeof(struct ns1__GetHardwareInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetHardwareInfo(struct soap *soap, const struct ns1__GetHardwareInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetHardwareInfo);
	if (soap_out_ns1__GetHardwareInfo(soap, tag?tag:"ns1:GetHardwareInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetHardwareInfo * SOAP_FMAC4 soap_get_ns1__GetHardwareInfo(struct soap *soap, struct ns1__GetHardwareInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetHardwareInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetHardwareInfo * SOAP_FMAC2 soap_instantiate_ns1__GetHardwareInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetHardwareInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetHardwareInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetHardwareInfo);
		if (size)
			*size = sizeof(struct ns1__GetHardwareInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetHardwareInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetHardwareInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetHardwareInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetHardwareInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetHardwareInfo %p -> %p\n", q, p));
	*(struct ns1__GetHardwareInfo*)p = *(struct ns1__GetHardwareInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetHardwareInfoResponse(struct soap *soap, struct ns1__GetHardwareInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetHardwareInfoReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetHardwareInfoResponse(struct soap *soap, const struct ns1__GetHardwareInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HardwareInfo(soap, &a->GetHardwareInfoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetHardwareInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetHardwareInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetHardwareInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__HardwareInfo(soap, "GetHardwareInfoReturn", -1, &a->GetHardwareInfoReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetHardwareInfoResponse * SOAP_FMAC4 soap_in_ns1__GetHardwareInfoResponse(struct soap *soap, const char *tag, struct ns1__GetHardwareInfoResponse *a, const char *type)
{
	size_t soap_flag_GetHardwareInfoReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetHardwareInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetHardwareInfoResponse, sizeof(struct ns1__GetHardwareInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetHardwareInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetHardwareInfoReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HardwareInfo(soap, "GetHardwareInfoReturn", &a->GetHardwareInfoReturn, "ns1:HardwareInfo"))
				{	soap_flag_GetHardwareInfoReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetHardwareInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetHardwareInfoResponse, 0, sizeof(struct ns1__GetHardwareInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetHardwareInfoResponse(struct soap *soap, const struct ns1__GetHardwareInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetHardwareInfoResponse);
	if (soap_out_ns1__GetHardwareInfoResponse(soap, tag?tag:"ns1:GetHardwareInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetHardwareInfoResponse * SOAP_FMAC4 soap_get_ns1__GetHardwareInfoResponse(struct soap *soap, struct ns1__GetHardwareInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetHardwareInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetHardwareInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__GetHardwareInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetHardwareInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetHardwareInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetHardwareInfoResponse);
		if (size)
			*size = sizeof(struct ns1__GetHardwareInfoResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetHardwareInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetHardwareInfoResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetHardwareInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetHardwareInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetHardwareInfoResponse %p -> %p\n", q, p));
	*(struct ns1__GetHardwareInfoResponse*)p = *(struct ns1__GetHardwareInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetGlobalCfg(struct soap *soap, struct ns1__GetGlobalCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetGlobalCfg(struct soap *soap, const struct ns1__GetGlobalCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetGlobalCfg(struct soap *soap, const char *tag, int id, const struct ns1__GetGlobalCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetGlobalCfg), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetGlobalCfg * SOAP_FMAC4 soap_in_ns1__GetGlobalCfg(struct soap *soap, const char *tag, struct ns1__GetGlobalCfg *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetGlobalCfg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetGlobalCfg, sizeof(struct ns1__GetGlobalCfg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetGlobalCfg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetGlobalCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetGlobalCfg, 0, sizeof(struct ns1__GetGlobalCfg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetGlobalCfg(struct soap *soap, const struct ns1__GetGlobalCfg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetGlobalCfg);
	if (soap_out_ns1__GetGlobalCfg(soap, tag?tag:"ns1:GetGlobalCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetGlobalCfg * SOAP_FMAC4 soap_get_ns1__GetGlobalCfg(struct soap *soap, struct ns1__GetGlobalCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetGlobalCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetGlobalCfg * SOAP_FMAC2 soap_instantiate_ns1__GetGlobalCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetGlobalCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetGlobalCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGlobalCfg);
		if (size)
			*size = sizeof(struct ns1__GetGlobalCfg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGlobalCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetGlobalCfg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetGlobalCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetGlobalCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetGlobalCfg %p -> %p\n", q, p));
	*(struct ns1__GetGlobalCfg*)p = *(struct ns1__GetGlobalCfg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetGlobalCfgResponse(struct soap *soap, struct ns1__GetGlobalCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetGlobalCfgReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetGlobalCfgResponse(struct soap *soap, const struct ns1__GetGlobalCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GlobalCfg(soap, &a->GetGlobalCfgReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetGlobalCfgResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetGlobalCfgResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetGlobalCfgResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__GlobalCfg(soap, "GetGlobalCfgReturn", -1, &a->GetGlobalCfgReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetGlobalCfgResponse * SOAP_FMAC4 soap_in_ns1__GetGlobalCfgResponse(struct soap *soap, const char *tag, struct ns1__GetGlobalCfgResponse *a, const char *type)
{
	size_t soap_flag_GetGlobalCfgReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetGlobalCfgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetGlobalCfgResponse, sizeof(struct ns1__GetGlobalCfgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetGlobalCfgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetGlobalCfgReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GlobalCfg(soap, "GetGlobalCfgReturn", &a->GetGlobalCfgReturn, "ns1:GlobalCfg"))
				{	soap_flag_GetGlobalCfgReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetGlobalCfgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetGlobalCfgResponse, 0, sizeof(struct ns1__GetGlobalCfgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetGlobalCfgResponse(struct soap *soap, const struct ns1__GetGlobalCfgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetGlobalCfgResponse);
	if (soap_out_ns1__GetGlobalCfgResponse(soap, tag?tag:"ns1:GetGlobalCfgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetGlobalCfgResponse * SOAP_FMAC4 soap_get_ns1__GetGlobalCfgResponse(struct soap *soap, struct ns1__GetGlobalCfgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetGlobalCfgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetGlobalCfgResponse * SOAP_FMAC2 soap_instantiate_ns1__GetGlobalCfgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetGlobalCfgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetGlobalCfgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGlobalCfgResponse);
		if (size)
			*size = sizeof(struct ns1__GetGlobalCfgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetGlobalCfgResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetGlobalCfgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetGlobalCfgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetGlobalCfgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetGlobalCfgResponse %p -> %p\n", q, p));
	*(struct ns1__GetGlobalCfgResponse*)p = *(struct ns1__GetGlobalCfgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetDiskFreeSpace(struct soap *soap, struct ns1__GetDiskFreeSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetDiskFreeSpace(struct soap *soap, const struct ns1__GetDiskFreeSpace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDiskFreeSpace(struct soap *soap, const char *tag, int id, const struct ns1__GetDiskFreeSpace *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDiskFreeSpace), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetDiskFreeSpace * SOAP_FMAC4 soap_in_ns1__GetDiskFreeSpace(struct soap *soap, const char *tag, struct ns1__GetDiskFreeSpace *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetDiskFreeSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDiskFreeSpace, sizeof(struct ns1__GetDiskFreeSpace), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetDiskFreeSpace(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetDiskFreeSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDiskFreeSpace, 0, sizeof(struct ns1__GetDiskFreeSpace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetDiskFreeSpace(struct soap *soap, const struct ns1__GetDiskFreeSpace *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetDiskFreeSpace);
	if (soap_out_ns1__GetDiskFreeSpace(soap, tag?tag:"ns1:GetDiskFreeSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetDiskFreeSpace * SOAP_FMAC4 soap_get_ns1__GetDiskFreeSpace(struct soap *soap, struct ns1__GetDiskFreeSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDiskFreeSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetDiskFreeSpace * SOAP_FMAC2 soap_instantiate_ns1__GetDiskFreeSpace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDiskFreeSpace(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetDiskFreeSpace, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDiskFreeSpace);
		if (size)
			*size = sizeof(struct ns1__GetDiskFreeSpace);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDiskFreeSpace[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetDiskFreeSpace);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetDiskFreeSpace*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetDiskFreeSpace(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetDiskFreeSpace %p -> %p\n", q, p));
	*(struct ns1__GetDiskFreeSpace*)p = *(struct ns1__GetDiskFreeSpace*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetDiskFreeSpaceResponse(struct soap *soap, struct ns1__GetDiskFreeSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetDiskFreeSpaceReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetDiskFreeSpaceResponse(struct soap *soap, const struct ns1__GetDiskFreeSpaceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DiskSpace(soap, &a->GetDiskFreeSpaceReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDiskFreeSpaceResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetDiskFreeSpaceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDiskFreeSpaceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DiskSpace(soap, "GetDiskFreeSpaceReturn", -1, &a->GetDiskFreeSpaceReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetDiskFreeSpaceResponse * SOAP_FMAC4 soap_in_ns1__GetDiskFreeSpaceResponse(struct soap *soap, const char *tag, struct ns1__GetDiskFreeSpaceResponse *a, const char *type)
{
	size_t soap_flag_GetDiskFreeSpaceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetDiskFreeSpaceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDiskFreeSpaceResponse, sizeof(struct ns1__GetDiskFreeSpaceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetDiskFreeSpaceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDiskFreeSpaceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DiskSpace(soap, "GetDiskFreeSpaceReturn", &a->GetDiskFreeSpaceReturn, "ns1:DiskSpace"))
				{	soap_flag_GetDiskFreeSpaceReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetDiskFreeSpaceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDiskFreeSpaceResponse, 0, sizeof(struct ns1__GetDiskFreeSpaceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetDiskFreeSpaceResponse(struct soap *soap, const struct ns1__GetDiskFreeSpaceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetDiskFreeSpaceResponse);
	if (soap_out_ns1__GetDiskFreeSpaceResponse(soap, tag?tag:"ns1:GetDiskFreeSpaceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetDiskFreeSpaceResponse * SOAP_FMAC4 soap_get_ns1__GetDiskFreeSpaceResponse(struct soap *soap, struct ns1__GetDiskFreeSpaceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDiskFreeSpaceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetDiskFreeSpaceResponse * SOAP_FMAC2 soap_instantiate_ns1__GetDiskFreeSpaceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDiskFreeSpaceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetDiskFreeSpaceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDiskFreeSpaceResponse);
		if (size)
			*size = sizeof(struct ns1__GetDiskFreeSpaceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDiskFreeSpaceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetDiskFreeSpaceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetDiskFreeSpaceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetDiskFreeSpaceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetDiskFreeSpaceResponse %p -> %p\n", q, p));
	*(struct ns1__GetDiskFreeSpaceResponse*)p = *(struct ns1__GetDiskFreeSpaceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetDevID(struct soap *soap, struct ns1__GetDevID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetDevID(struct soap *soap, const struct ns1__GetDevID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDevID(struct soap *soap, const char *tag, int id, const struct ns1__GetDevID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDevID), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetDevID * SOAP_FMAC4 soap_in_ns1__GetDevID(struct soap *soap, const char *tag, struct ns1__GetDevID *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetDevID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDevID, sizeof(struct ns1__GetDevID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetDevID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetDevID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDevID, 0, sizeof(struct ns1__GetDevID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetDevID(struct soap *soap, const struct ns1__GetDevID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetDevID);
	if (soap_out_ns1__GetDevID(soap, tag?tag:"ns1:GetDevID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetDevID * SOAP_FMAC4 soap_get_ns1__GetDevID(struct soap *soap, struct ns1__GetDevID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDevID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetDevID * SOAP_FMAC2 soap_instantiate_ns1__GetDevID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDevID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetDevID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDevID);
		if (size)
			*size = sizeof(struct ns1__GetDevID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDevID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetDevID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetDevID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetDevID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetDevID %p -> %p\n", q, p));
	*(struct ns1__GetDevID*)p = *(struct ns1__GetDevID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetDevIDResponse(struct soap *soap, struct ns1__GetDevIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GetDevIDReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetDevIDResponse(struct soap *soap, const struct ns1__GetDevIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->GetDevIDReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDevIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetDevIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDevIDResponse), type))
		return soap->error;
	if (a->GetDevIDReturn)
	{	if (soap_out_string(soap, "GetDevIDReturn", -1, &a->GetDevIDReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "GetDevIDReturn"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetDevIDResponse * SOAP_FMAC4 soap_in_ns1__GetDevIDResponse(struct soap *soap, const char *tag, struct ns1__GetDevIDResponse *a, const char *type)
{
	size_t soap_flag_GetDevIDReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetDevIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDevIDResponse, sizeof(struct ns1__GetDevIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetDevIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDevIDReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "GetDevIDReturn", &a->GetDevIDReturn, "xsd:string"))
				{	soap_flag_GetDevIDReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetDevIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDevIDResponse, 0, sizeof(struct ns1__GetDevIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetDevIDReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetDevIDResponse(struct soap *soap, const struct ns1__GetDevIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetDevIDResponse);
	if (soap_out_ns1__GetDevIDResponse(soap, tag?tag:"ns1:GetDevIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetDevIDResponse * SOAP_FMAC4 soap_get_ns1__GetDevIDResponse(struct soap *soap, struct ns1__GetDevIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDevIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetDevIDResponse * SOAP_FMAC2 soap_instantiate_ns1__GetDevIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDevIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetDevIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDevIDResponse);
		if (size)
			*size = sizeof(struct ns1__GetDevIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDevIDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetDevIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetDevIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetDevIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetDevIDResponse %p -> %p\n", q, p));
	*(struct ns1__GetDevIDResponse*)p = *(struct ns1__GetDevIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetDeviceTime(struct soap *soap, struct ns1__GetDeviceTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetDeviceTime(struct soap *soap, const struct ns1__GetDeviceTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDeviceTime(struct soap *soap, const char *tag, int id, const struct ns1__GetDeviceTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDeviceTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetDeviceTime * SOAP_FMAC4 soap_in_ns1__GetDeviceTime(struct soap *soap, const char *tag, struct ns1__GetDeviceTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetDeviceTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDeviceTime, sizeof(struct ns1__GetDeviceTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetDeviceTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetDeviceTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDeviceTime, 0, sizeof(struct ns1__GetDeviceTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetDeviceTime(struct soap *soap, const struct ns1__GetDeviceTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetDeviceTime);
	if (soap_out_ns1__GetDeviceTime(soap, tag?tag:"ns1:GetDeviceTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetDeviceTime * SOAP_FMAC4 soap_get_ns1__GetDeviceTime(struct soap *soap, struct ns1__GetDeviceTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDeviceTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetDeviceTime * SOAP_FMAC2 soap_instantiate_ns1__GetDeviceTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDeviceTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetDeviceTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDeviceTime);
		if (size)
			*size = sizeof(struct ns1__GetDeviceTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDeviceTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetDeviceTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetDeviceTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetDeviceTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetDeviceTime %p -> %p\n", q, p));
	*(struct ns1__GetDeviceTime*)p = *(struct ns1__GetDeviceTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetDeviceTimeResponse(struct soap *soap, struct ns1__GetDeviceTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GetDeviceTimeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetDeviceTimeResponse(struct soap *soap, const struct ns1__GetDeviceTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->GetDeviceTimeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetDeviceTimeResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetDeviceTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetDeviceTimeResponse), type))
		return soap->error;
	if (a->GetDeviceTimeReturn)
	{	if (soap_out_string(soap, "GetDeviceTimeReturn", -1, &a->GetDeviceTimeReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "GetDeviceTimeReturn"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetDeviceTimeResponse * SOAP_FMAC4 soap_in_ns1__GetDeviceTimeResponse(struct soap *soap, const char *tag, struct ns1__GetDeviceTimeResponse *a, const char *type)
{
	size_t soap_flag_GetDeviceTimeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetDeviceTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetDeviceTimeResponse, sizeof(struct ns1__GetDeviceTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetDeviceTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDeviceTimeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "GetDeviceTimeReturn", &a->GetDeviceTimeReturn, "xsd:string"))
				{	soap_flag_GetDeviceTimeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetDeviceTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetDeviceTimeResponse, 0, sizeof(struct ns1__GetDeviceTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetDeviceTimeReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetDeviceTimeResponse(struct soap *soap, const struct ns1__GetDeviceTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetDeviceTimeResponse);
	if (soap_out_ns1__GetDeviceTimeResponse(soap, tag?tag:"ns1:GetDeviceTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetDeviceTimeResponse * SOAP_FMAC4 soap_get_ns1__GetDeviceTimeResponse(struct soap *soap, struct ns1__GetDeviceTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetDeviceTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetDeviceTimeResponse * SOAP_FMAC2 soap_instantiate_ns1__GetDeviceTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetDeviceTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetDeviceTimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDeviceTimeResponse);
		if (size)
			*size = sizeof(struct ns1__GetDeviceTimeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetDeviceTimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetDeviceTimeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetDeviceTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetDeviceTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetDeviceTimeResponse %p -> %p\n", q, p));
	*(struct ns1__GetDeviceTimeResponse*)p = *(struct ns1__GetDeviceTimeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetChannelStatus(struct soap *soap, struct ns1__GetChannelStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetChannelStatus(struct soap *soap, const struct ns1__GetChannelStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetChannelStatus(struct soap *soap, const char *tag, int id, const struct ns1__GetChannelStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetChannelStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetChannelStatus * SOAP_FMAC4 soap_in_ns1__GetChannelStatus(struct soap *soap, const char *tag, struct ns1__GetChannelStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetChannelStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetChannelStatus, sizeof(struct ns1__GetChannelStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetChannelStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetChannelStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetChannelStatus, 0, sizeof(struct ns1__GetChannelStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetChannelStatus(struct soap *soap, const struct ns1__GetChannelStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetChannelStatus);
	if (soap_out_ns1__GetChannelStatus(soap, tag?tag:"ns1:GetChannelStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetChannelStatus * SOAP_FMAC4 soap_get_ns1__GetChannelStatus(struct soap *soap, struct ns1__GetChannelStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetChannelStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetChannelStatus * SOAP_FMAC2 soap_instantiate_ns1__GetChannelStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetChannelStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetChannelStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelStatus);
		if (size)
			*size = sizeof(struct ns1__GetChannelStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetChannelStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetChannelStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetChannelStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetChannelStatus %p -> %p\n", q, p));
	*(struct ns1__GetChannelStatus*)p = *(struct ns1__GetChannelStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetChannelStatusResponse(struct soap *soap, struct ns1__GetChannelStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetChannelStatusReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetChannelStatusResponse(struct soap *soap, const struct ns1__GetChannelStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TotalChStatus(soap, &a->GetChannelStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetChannelStatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetChannelStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetChannelStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TotalChStatus(soap, "GetChannelStatusReturn", -1, &a->GetChannelStatusReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetChannelStatusResponse * SOAP_FMAC4 soap_in_ns1__GetChannelStatusResponse(struct soap *soap, const char *tag, struct ns1__GetChannelStatusResponse *a, const char *type)
{
	size_t soap_flag_GetChannelStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetChannelStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetChannelStatusResponse, sizeof(struct ns1__GetChannelStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetChannelStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetChannelStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TotalChStatus(soap, "GetChannelStatusReturn", &a->GetChannelStatusReturn, "ns1:TotalChStatus"))
				{	soap_flag_GetChannelStatusReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetChannelStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetChannelStatusResponse, 0, sizeof(struct ns1__GetChannelStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetChannelStatusResponse(struct soap *soap, const struct ns1__GetChannelStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetChannelStatusResponse);
	if (soap_out_ns1__GetChannelStatusResponse(soap, tag?tag:"ns1:GetChannelStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetChannelStatusResponse * SOAP_FMAC4 soap_get_ns1__GetChannelStatusResponse(struct soap *soap, struct ns1__GetChannelStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetChannelStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetChannelStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__GetChannelStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetChannelStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetChannelStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelStatusResponse);
		if (size)
			*size = sizeof(struct ns1__GetChannelStatusResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetChannelStatusResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetChannelStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetChannelStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetChannelStatusResponse %p -> %p\n", q, p));
	*(struct ns1__GetChannelStatusResponse*)p = *(struct ns1__GetChannelStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetChannelRunningStatus(struct soap *soap, struct ns1__GetChannelRunningStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ChID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetChannelRunningStatus(struct soap *soap, const struct ns1__GetChannelRunningStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetChannelRunningStatus(struct soap *soap, const char *tag, int id, const struct ns1__GetChannelRunningStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetChannelRunningStatus), type))
		return soap->error;
	if (soap_out_int(soap, "ChID", -1, &a->ChID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetChannelRunningStatus * SOAP_FMAC4 soap_in_ns1__GetChannelRunningStatus(struct soap *soap, const char *tag, struct ns1__GetChannelRunningStatus *a, const char *type)
{
	size_t soap_flag_ChID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetChannelRunningStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetChannelRunningStatus, sizeof(struct ns1__GetChannelRunningStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetChannelRunningStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ChID", &a->ChID, "xsd:int"))
				{	soap_flag_ChID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetChannelRunningStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetChannelRunningStatus, 0, sizeof(struct ns1__GetChannelRunningStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetChannelRunningStatus(struct soap *soap, const struct ns1__GetChannelRunningStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetChannelRunningStatus);
	if (soap_out_ns1__GetChannelRunningStatus(soap, tag?tag:"ns1:GetChannelRunningStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetChannelRunningStatus * SOAP_FMAC4 soap_get_ns1__GetChannelRunningStatus(struct soap *soap, struct ns1__GetChannelRunningStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetChannelRunningStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetChannelRunningStatus * SOAP_FMAC2 soap_instantiate_ns1__GetChannelRunningStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetChannelRunningStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetChannelRunningStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelRunningStatus);
		if (size)
			*size = sizeof(struct ns1__GetChannelRunningStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelRunningStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetChannelRunningStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetChannelRunningStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetChannelRunningStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetChannelRunningStatus %p -> %p\n", q, p));
	*(struct ns1__GetChannelRunningStatus*)p = *(struct ns1__GetChannelRunningStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetChannelRunningStatusResponse(struct soap *soap, struct ns1__GetChannelRunningStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetChannelRunningStatusReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetChannelRunningStatusResponse(struct soap *soap, const struct ns1__GetChannelRunningStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ChRunStatus(soap, &a->GetChannelRunningStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetChannelRunningStatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetChannelRunningStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetChannelRunningStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ChRunStatus(soap, "GetChannelRunningStatusReturn", -1, &a->GetChannelRunningStatusReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetChannelRunningStatusResponse * SOAP_FMAC4 soap_in_ns1__GetChannelRunningStatusResponse(struct soap *soap, const char *tag, struct ns1__GetChannelRunningStatusResponse *a, const char *type)
{
	size_t soap_flag_GetChannelRunningStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetChannelRunningStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetChannelRunningStatusResponse, sizeof(struct ns1__GetChannelRunningStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetChannelRunningStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetChannelRunningStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ChRunStatus(soap, "GetChannelRunningStatusReturn", &a->GetChannelRunningStatusReturn, "ns1:ChRunStatus"))
				{	soap_flag_GetChannelRunningStatusReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetChannelRunningStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetChannelRunningStatusResponse, 0, sizeof(struct ns1__GetChannelRunningStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetChannelRunningStatusResponse(struct soap *soap, const struct ns1__GetChannelRunningStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetChannelRunningStatusResponse);
	if (soap_out_ns1__GetChannelRunningStatusResponse(soap, tag?tag:"ns1:GetChannelRunningStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetChannelRunningStatusResponse * SOAP_FMAC4 soap_get_ns1__GetChannelRunningStatusResponse(struct soap *soap, struct ns1__GetChannelRunningStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetChannelRunningStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetChannelRunningStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__GetChannelRunningStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetChannelRunningStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetChannelRunningStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelRunningStatusResponse);
		if (size)
			*size = sizeof(struct ns1__GetChannelRunningStatusResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelRunningStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetChannelRunningStatusResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetChannelRunningStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetChannelRunningStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetChannelRunningStatusResponse %p -> %p\n", q, p));
	*(struct ns1__GetChannelRunningStatusResponse*)p = *(struct ns1__GetChannelRunningStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetChannelCfg(struct soap *soap, struct ns1__GetChannelCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ChID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetChannelCfg(struct soap *soap, const struct ns1__GetChannelCfg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetChannelCfg(struct soap *soap, const char *tag, int id, const struct ns1__GetChannelCfg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetChannelCfg), type))
		return soap->error;
	if (soap_out_int(soap, "ChID", -1, &a->ChID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetChannelCfg * SOAP_FMAC4 soap_in_ns1__GetChannelCfg(struct soap *soap, const char *tag, struct ns1__GetChannelCfg *a, const char *type)
{
	size_t soap_flag_ChID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetChannelCfg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetChannelCfg, sizeof(struct ns1__GetChannelCfg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetChannelCfg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ChID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ChID", &a->ChID, "xsd:int"))
				{	soap_flag_ChID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetChannelCfg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetChannelCfg, 0, sizeof(struct ns1__GetChannelCfg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetChannelCfg(struct soap *soap, const struct ns1__GetChannelCfg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetChannelCfg);
	if (soap_out_ns1__GetChannelCfg(soap, tag?tag:"ns1:GetChannelCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetChannelCfg * SOAP_FMAC4 soap_get_ns1__GetChannelCfg(struct soap *soap, struct ns1__GetChannelCfg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetChannelCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetChannelCfg * SOAP_FMAC2 soap_instantiate_ns1__GetChannelCfg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetChannelCfg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetChannelCfg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelCfg);
		if (size)
			*size = sizeof(struct ns1__GetChannelCfg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelCfg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetChannelCfg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetChannelCfg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetChannelCfg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetChannelCfg %p -> %p\n", q, p));
	*(struct ns1__GetChannelCfg*)p = *(struct ns1__GetChannelCfg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetChannelCfgResponse(struct soap *soap, struct ns1__GetChannelCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetChannelCfgReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetChannelCfgResponse(struct soap *soap, const struct ns1__GetChannelCfgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ChannelCfg(soap, &a->GetChannelCfgReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetChannelCfgResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetChannelCfgResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetChannelCfgResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ChannelCfg(soap, "GetChannelCfgReturn", -1, &a->GetChannelCfgReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetChannelCfgResponse * SOAP_FMAC4 soap_in_ns1__GetChannelCfgResponse(struct soap *soap, const char *tag, struct ns1__GetChannelCfgResponse *a, const char *type)
{
	size_t soap_flag_GetChannelCfgReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetChannelCfgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetChannelCfgResponse, sizeof(struct ns1__GetChannelCfgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetChannelCfgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetChannelCfgReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ChannelCfg(soap, "GetChannelCfgReturn", &a->GetChannelCfgReturn, "ns1:ChannelCfg"))
				{	soap_flag_GetChannelCfgReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetChannelCfgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetChannelCfgResponse, 0, sizeof(struct ns1__GetChannelCfgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetChannelCfgResponse(struct soap *soap, const struct ns1__GetChannelCfgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetChannelCfgResponse);
	if (soap_out_ns1__GetChannelCfgResponse(soap, tag?tag:"ns1:GetChannelCfgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetChannelCfgResponse * SOAP_FMAC4 soap_get_ns1__GetChannelCfgResponse(struct soap *soap, struct ns1__GetChannelCfgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetChannelCfgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetChannelCfgResponse * SOAP_FMAC2 soap_instantiate_ns1__GetChannelCfgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetChannelCfgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetChannelCfgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelCfgResponse);
		if (size)
			*size = sizeof(struct ns1__GetChannelCfgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetChannelCfgResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__GetChannelCfgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__GetChannelCfgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetChannelCfgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetChannelCfgResponse %p -> %p\n", q, p));
	*(struct ns1__GetChannelCfgResponse*)p = *(struct ns1__GetChannelCfgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExecuteSQL(struct soap *soap, struct ns1__ExecuteSQL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SqlQuerymsg);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExecuteSQL(struct soap *soap, const struct ns1__ExecuteSQL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SqlQuerymsg);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExecuteSQL(struct soap *soap, const char *tag, int id, const struct ns1__ExecuteSQL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExecuteSQL), type))
		return soap->error;
	if (soap_out_string(soap, "SqlQuerymsg", -1, &a->SqlQuerymsg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ExecuteSQL * SOAP_FMAC4 soap_in_ns1__ExecuteSQL(struct soap *soap, const char *tag, struct ns1__ExecuteSQL *a, const char *type)
{
	size_t soap_flag_SqlQuerymsg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ExecuteSQL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExecuteSQL, sizeof(struct ns1__ExecuteSQL), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ExecuteSQL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SqlQuerymsg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SqlQuerymsg", &a->SqlQuerymsg, "xsd:string"))
				{	soap_flag_SqlQuerymsg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ExecuteSQL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExecuteSQL, 0, sizeof(struct ns1__ExecuteSQL), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExecuteSQL(struct soap *soap, const struct ns1__ExecuteSQL *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ExecuteSQL);
	if (soap_out_ns1__ExecuteSQL(soap, tag?tag:"ns1:ExecuteSQL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ExecuteSQL * SOAP_FMAC4 soap_get_ns1__ExecuteSQL(struct soap *soap, struct ns1__ExecuteSQL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExecuteSQL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__ExecuteSQL * SOAP_FMAC2 soap_instantiate_ns1__ExecuteSQL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExecuteSQL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ExecuteSQL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__ExecuteSQL);
		if (size)
			*size = sizeof(struct ns1__ExecuteSQL);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__ExecuteSQL[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ExecuteSQL);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ExecuteSQL*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ExecuteSQL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ExecuteSQL %p -> %p\n", q, p));
	*(struct ns1__ExecuteSQL*)p = *(struct ns1__ExecuteSQL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExecuteSQLResponse(struct soap *soap, struct ns1__ExecuteSQLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ExecuteSQLReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExecuteSQLResponse(struct soap *soap, const struct ns1__ExecuteSQLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SqlResult(soap, &a->ExecuteSQLReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExecuteSQLResponse(struct soap *soap, const char *tag, int id, const struct ns1__ExecuteSQLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExecuteSQLResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__SqlResult(soap, "ExecuteSQLReturn", -1, &a->ExecuteSQLReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ExecuteSQLResponse * SOAP_FMAC4 soap_in_ns1__ExecuteSQLResponse(struct soap *soap, const char *tag, struct ns1__ExecuteSQLResponse *a, const char *type)
{
	size_t soap_flag_ExecuteSQLReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ExecuteSQLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExecuteSQLResponse, sizeof(struct ns1__ExecuteSQLResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ExecuteSQLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExecuteSQLReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SqlResult(soap, "ExecuteSQLReturn", &a->ExecuteSQLReturn, "ns1:SqlResult"))
				{	soap_flag_ExecuteSQLReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ExecuteSQLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExecuteSQLResponse, 0, sizeof(struct ns1__ExecuteSQLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExecuteSQLResponse(struct soap *soap, const struct ns1__ExecuteSQLResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ExecuteSQLResponse);
	if (soap_out_ns1__ExecuteSQLResponse(soap, tag?tag:"ns1:ExecuteSQLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ExecuteSQLResponse * SOAP_FMAC4 soap_get_ns1__ExecuteSQLResponse(struct soap *soap, struct ns1__ExecuteSQLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExecuteSQLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__ExecuteSQLResponse * SOAP_FMAC2 soap_instantiate_ns1__ExecuteSQLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExecuteSQLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ExecuteSQLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__ExecuteSQLResponse);
		if (size)
			*size = sizeof(struct ns1__ExecuteSQLResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__ExecuteSQLResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__ExecuteSQLResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__ExecuteSQLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ExecuteSQLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ExecuteSQLResponse %p -> %p\n", q, p));
	*(struct ns1__ExecuteSQLResponse*)p = *(struct ns1__ExecuteSQLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DelRecordFile(struct soap *soap, struct ns1__DelRecordFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->StartDate);
	soap_default_string(soap, &a->StartTime);
	soap_default_string(soap, &a->EndDate);
	soap_default_string(soap, &a->EndTime);
	soap_default_int(soap, &a->StartChnl);
	soap_default_int(soap, &a->EndChnl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DelRecordFile(struct soap *soap, const struct ns1__DelRecordFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->StartDate);
	soap_serialize_string(soap, &a->StartTime);
	soap_serialize_string(soap, &a->EndDate);
	soap_serialize_string(soap, &a->EndTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DelRecordFile(struct soap *soap, const char *tag, int id, const struct ns1__DelRecordFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DelRecordFile), type))
		return soap->error;
	if (soap_out_string(soap, "StartDate", -1, &a->StartDate, ""))
		return soap->error;
	if (soap_out_string(soap, "StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_string(soap, "EndDate", -1, &a->EndDate, ""))
		return soap->error;
	if (soap_out_string(soap, "EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_int(soap, "StartChnl", -1, &a->StartChnl, ""))
		return soap->error;
	if (soap_out_int(soap, "EndChnl", -1, &a->EndChnl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DelRecordFile * SOAP_FMAC4 soap_in_ns1__DelRecordFile(struct soap *soap, const char *tag, struct ns1__DelRecordFile *a, const char *type)
{
	size_t soap_flag_StartDate = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndDate = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_StartChnl = 1;
	size_t soap_flag_EndChnl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DelRecordFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DelRecordFile, sizeof(struct ns1__DelRecordFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DelRecordFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "StartDate", &a->StartDate, "xsd:string"))
				{	soap_flag_StartDate--;
					continue;
				}
			if (soap_flag_StartTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "StartTime", &a->StartTime, "xsd:string"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "EndDate", &a->EndDate, "xsd:string"))
				{	soap_flag_EndDate--;
					continue;
				}
			if (soap_flag_EndTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "EndTime", &a->EndTime, "xsd:string"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_StartChnl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "StartChnl", &a->StartChnl, "xsd:int"))
				{	soap_flag_StartChnl--;
					continue;
				}
			if (soap_flag_EndChnl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "EndChnl", &a->EndChnl, "xsd:int"))
				{	soap_flag_EndChnl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DelRecordFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DelRecordFile, 0, sizeof(struct ns1__DelRecordFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartChnl > 0 || soap_flag_EndChnl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DelRecordFile(struct soap *soap, const struct ns1__DelRecordFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DelRecordFile);
	if (soap_out_ns1__DelRecordFile(soap, tag?tag:"ns1:DelRecordFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DelRecordFile * SOAP_FMAC4 soap_get_ns1__DelRecordFile(struct soap *soap, struct ns1__DelRecordFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DelRecordFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DelRecordFile * SOAP_FMAC2 soap_instantiate_ns1__DelRecordFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DelRecordFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DelRecordFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DelRecordFile);
		if (size)
			*size = sizeof(struct ns1__DelRecordFile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DelRecordFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__DelRecordFile);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__DelRecordFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DelRecordFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DelRecordFile %p -> %p\n", q, p));
	*(struct ns1__DelRecordFile*)p = *(struct ns1__DelRecordFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DelRecordFileResponse(struct soap *soap, struct ns1__DelRecordFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->DelRecordFileReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DelRecordFileResponse(struct soap *soap, const struct ns1__DelRecordFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DelRecordFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__DelRecordFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DelRecordFileResponse), type))
		return soap->error;
	if (soap_out_int(soap, "DelRecordFileReturn", -1, &a->DelRecordFileReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DelRecordFileResponse * SOAP_FMAC4 soap_in_ns1__DelRecordFileResponse(struct soap *soap, const char *tag, struct ns1__DelRecordFileResponse *a, const char *type)
{
	size_t soap_flag_DelRecordFileReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DelRecordFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DelRecordFileResponse, sizeof(struct ns1__DelRecordFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DelRecordFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DelRecordFileReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "DelRecordFileReturn", &a->DelRecordFileReturn, "xsd:int"))
				{	soap_flag_DelRecordFileReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DelRecordFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DelRecordFileResponse, 0, sizeof(struct ns1__DelRecordFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DelRecordFileReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DelRecordFileResponse(struct soap *soap, const struct ns1__DelRecordFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DelRecordFileResponse);
	if (soap_out_ns1__DelRecordFileResponse(soap, tag?tag:"ns1:DelRecordFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DelRecordFileResponse * SOAP_FMAC4 soap_get_ns1__DelRecordFileResponse(struct soap *soap, struct ns1__DelRecordFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DelRecordFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DelRecordFileResponse * SOAP_FMAC2 soap_instantiate_ns1__DelRecordFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DelRecordFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DelRecordFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DelRecordFileResponse);
		if (size)
			*size = sizeof(struct ns1__DelRecordFileResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DelRecordFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__DelRecordFileResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__DelRecordFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DelRecordFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DelRecordFileResponse %p -> %p\n", q, p));
	*(struct ns1__DelRecordFileResponse*)p = *(struct ns1__DelRecordFileResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteFile(struct soap *soap, struct ns1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteFile(struct soap *soap, const struct ns1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteFile(struct soap *soap, const char *tag, int id, const struct ns1__DeleteFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteFile), type))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteFile * SOAP_FMAC4 soap_in_ns1__DeleteFile(struct soap *soap, const char *tag, struct ns1__DeleteFile *a, const char *type)
{
	size_t soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteFile, sizeof(struct ns1__DeleteFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteFile, 0, sizeof(struct ns1__DeleteFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteFile(struct soap *soap, const struct ns1__DeleteFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DeleteFile);
	if (soap_out_ns1__DeleteFile(soap, tag?tag:"ns1:DeleteFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteFile * SOAP_FMAC4 soap_get_ns1__DeleteFile(struct soap *soap, struct ns1__DeleteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DeleteFile * SOAP_FMAC2 soap_instantiate_ns1__DeleteFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DeleteFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DeleteFile);
		if (size)
			*size = sizeof(struct ns1__DeleteFile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DeleteFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__DeleteFile);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__DeleteFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DeleteFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DeleteFile %p -> %p\n", q, p));
	*(struct ns1__DeleteFile*)p = *(struct ns1__DeleteFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->DeleteFileReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteFileResponse(struct soap *soap, const struct ns1__DeleteFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteFileResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "DeleteFileReturn", -1, &a->DeleteFileReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteFileResponse * SOAP_FMAC4 soap_in_ns1__DeleteFileResponse(struct soap *soap, const char *tag, struct ns1__DeleteFileResponse *a, const char *type)
{
	size_t soap_flag_DeleteFileReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteFileResponse, sizeof(struct ns1__DeleteFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeleteFileReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "DeleteFileReturn", &a->DeleteFileReturn, "xsd:boolean"))
				{	soap_flag_DeleteFileReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteFileResponse, 0, sizeof(struct ns1__DeleteFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DeleteFileReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteFileResponse(struct soap *soap, const struct ns1__DeleteFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DeleteFileResponse);
	if (soap_out_ns1__DeleteFileResponse(soap, tag?tag:"ns1:DeleteFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteFileResponse * SOAP_FMAC4 soap_get_ns1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DeleteFileResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DeleteFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DeleteFileResponse);
		if (size)
			*size = sizeof(struct ns1__DeleteFileResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DeleteFileResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__DeleteFileResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__DeleteFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DeleteFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DeleteFileResponse %p -> %p\n", q, p));
	*(struct ns1__DeleteFileResponse*)p = *(struct ns1__DeleteFileResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CalculateInput(struct soap *soap, ns1__CalculateInput *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CalculateInput))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CalculateInput(struct soap *soap, const char *tag, int id, ns1__CalculateInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CalculateInput);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CalculateInput ** SOAP_FMAC4 soap_in_PointerTons1__CalculateInput(struct soap *soap, const char *tag, ns1__CalculateInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CalculateInput **)soap_malloc(soap, sizeof(ns1__CalculateInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CalculateInput *)soap_instantiate_ns1__CalculateInput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CalculateInput ** p = (ns1__CalculateInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CalculateInput, sizeof(ns1__CalculateInput), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CalculateInput(struct soap *soap, ns1__CalculateInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CalculateInput);
	if (soap_out_PointerTons1__CalculateInput(soap, tag?tag:"ns1:CalculateInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CalculateInput ** SOAP_FMAC4 soap_get_PointerTons1__CalculateInput(struct soap *soap, ns1__CalculateInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CalculateInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CalculateRet(struct soap *soap, ns1__CalculateRet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CalculateRet))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CalculateRet(struct soap *soap, const char *tag, int id, ns1__CalculateRet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CalculateRet);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CalculateRet ** SOAP_FMAC4 soap_in_PointerTons1__CalculateRet(struct soap *soap, const char *tag, ns1__CalculateRet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CalculateRet **)soap_malloc(soap, sizeof(ns1__CalculateRet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CalculateRet *)soap_instantiate_ns1__CalculateRet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CalculateRet ** p = (ns1__CalculateRet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CalculateRet, sizeof(ns1__CalculateRet), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CalculateRet(struct soap *soap, ns1__CalculateRet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CalculateRet);
	if (soap_out_PointerTons1__CalculateRet(soap, tag?tag:"ns1:CalculateRet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CalculateRet ** SOAP_FMAC4 soap_get_PointerTons1__CalculateRet(struct soap *soap, ns1__CalculateRet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CalculateRet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MonitorInfo(struct soap *soap, ns1__MonitorInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MonitorInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MonitorInfo(struct soap *soap, const char *tag, int id, ns1__MonitorInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MonitorInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MonitorInfo ** SOAP_FMAC4 soap_in_PointerTons1__MonitorInfo(struct soap *soap, const char *tag, ns1__MonitorInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MonitorInfo **)soap_malloc(soap, sizeof(ns1__MonitorInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MonitorInfo *)soap_instantiate_ns1__MonitorInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MonitorInfo ** p = (ns1__MonitorInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MonitorInfo, sizeof(ns1__MonitorInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MonitorInfo(struct soap *soap, ns1__MonitorInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MonitorInfo);
	if (soap_out_PointerTons1__MonitorInfo(soap, tag?tag:"ns1:MonitorInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MonitorInfo ** SOAP_FMAC4 soap_get_PointerTons1__MonitorInfo(struct soap *soap, ns1__MonitorInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MonitorInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NetCfg(struct soap *soap, ns1__NetCfg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NetCfg))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NetCfg(struct soap *soap, const char *tag, int id, ns1__NetCfg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NetCfg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NetCfg ** SOAP_FMAC4 soap_in_PointerTons1__NetCfg(struct soap *soap, const char *tag, ns1__NetCfg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NetCfg **)soap_malloc(soap, sizeof(ns1__NetCfg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NetCfg *)soap_instantiate_ns1__NetCfg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NetCfg ** p = (ns1__NetCfg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NetCfg, sizeof(ns1__NetCfg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NetCfg(struct soap *soap, ns1__NetCfg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NetCfg);
	if (soap_out_PointerTons1__NetCfg(soap, tag?tag:"ns1:NetCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NetCfg ** SOAP_FMAC4 soap_get_PointerTons1__NetCfg(struct soap *soap, ns1__NetCfg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NetCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TotalChVol(struct soap *soap, ns1__TotalChVol *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TotalChVol))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TotalChVol(struct soap *soap, const char *tag, int id, ns1__TotalChVol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TotalChVol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TotalChVol ** SOAP_FMAC4 soap_in_PointerTons1__TotalChVol(struct soap *soap, const char *tag, ns1__TotalChVol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TotalChVol **)soap_malloc(soap, sizeof(ns1__TotalChVol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TotalChVol *)soap_instantiate_ns1__TotalChVol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TotalChVol ** p = (ns1__TotalChVol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TotalChVol, sizeof(ns1__TotalChVol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TotalChVol(struct soap *soap, ns1__TotalChVol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TotalChVol);
	if (soap_out_PointerTons1__TotalChVol(soap, tag?tag:"ns1:TotalChVol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TotalChVol ** SOAP_FMAC4 soap_get_PointerTons1__TotalChVol(struct soap *soap, ns1__TotalChVol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TotalChVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HardwareInfo(struct soap *soap, ns1__HardwareInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HardwareInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HardwareInfo(struct soap *soap, const char *tag, int id, ns1__HardwareInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HardwareInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HardwareInfo ** SOAP_FMAC4 soap_in_PointerTons1__HardwareInfo(struct soap *soap, const char *tag, ns1__HardwareInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HardwareInfo **)soap_malloc(soap, sizeof(ns1__HardwareInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HardwareInfo *)soap_instantiate_ns1__HardwareInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__HardwareInfo ** p = (ns1__HardwareInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HardwareInfo, sizeof(ns1__HardwareInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HardwareInfo(struct soap *soap, ns1__HardwareInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HardwareInfo);
	if (soap_out_PointerTons1__HardwareInfo(soap, tag?tag:"ns1:HardwareInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__HardwareInfo ** SOAP_FMAC4 soap_get_PointerTons1__HardwareInfo(struct soap *soap, ns1__HardwareInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HardwareInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GlobalCfg(struct soap *soap, ns1__GlobalCfg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GlobalCfg))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GlobalCfg(struct soap *soap, const char *tag, int id, ns1__GlobalCfg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GlobalCfg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GlobalCfg ** SOAP_FMAC4 soap_in_PointerTons1__GlobalCfg(struct soap *soap, const char *tag, ns1__GlobalCfg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GlobalCfg **)soap_malloc(soap, sizeof(ns1__GlobalCfg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GlobalCfg *)soap_instantiate_ns1__GlobalCfg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GlobalCfg ** p = (ns1__GlobalCfg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GlobalCfg, sizeof(ns1__GlobalCfg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GlobalCfg(struct soap *soap, ns1__GlobalCfg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GlobalCfg);
	if (soap_out_PointerTons1__GlobalCfg(soap, tag?tag:"ns1:GlobalCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GlobalCfg ** SOAP_FMAC4 soap_get_PointerTons1__GlobalCfg(struct soap *soap, ns1__GlobalCfg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GlobalCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DiskSpace(struct soap *soap, ns1__DiskSpace *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DiskSpace))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DiskSpace(struct soap *soap, const char *tag, int id, ns1__DiskSpace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DiskSpace);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DiskSpace ** SOAP_FMAC4 soap_in_PointerTons1__DiskSpace(struct soap *soap, const char *tag, ns1__DiskSpace **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DiskSpace **)soap_malloc(soap, sizeof(ns1__DiskSpace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DiskSpace *)soap_instantiate_ns1__DiskSpace(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DiskSpace ** p = (ns1__DiskSpace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DiskSpace, sizeof(ns1__DiskSpace), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DiskSpace(struct soap *soap, ns1__DiskSpace *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DiskSpace);
	if (soap_out_PointerTons1__DiskSpace(soap, tag?tag:"ns1:DiskSpace", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DiskSpace ** SOAP_FMAC4 soap_get_PointerTons1__DiskSpace(struct soap *soap, ns1__DiskSpace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DiskSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TotalChStatus(struct soap *soap, ns1__TotalChStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TotalChStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TotalChStatus(struct soap *soap, const char *tag, int id, ns1__TotalChStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TotalChStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TotalChStatus ** SOAP_FMAC4 soap_in_PointerTons1__TotalChStatus(struct soap *soap, const char *tag, ns1__TotalChStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TotalChStatus **)soap_malloc(soap, sizeof(ns1__TotalChStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TotalChStatus *)soap_instantiate_ns1__TotalChStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TotalChStatus ** p = (ns1__TotalChStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TotalChStatus, sizeof(ns1__TotalChStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TotalChStatus(struct soap *soap, ns1__TotalChStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TotalChStatus);
	if (soap_out_PointerTons1__TotalChStatus(soap, tag?tag:"ns1:TotalChStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TotalChStatus ** SOAP_FMAC4 soap_get_PointerTons1__TotalChStatus(struct soap *soap, ns1__TotalChStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TotalChStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChRunStatus(struct soap *soap, ns1__ChRunStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChRunStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChRunStatus(struct soap *soap, const char *tag, int id, ns1__ChRunStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChRunStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ChRunStatus ** SOAP_FMAC4 soap_in_PointerTons1__ChRunStatus(struct soap *soap, const char *tag, ns1__ChRunStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChRunStatus **)soap_malloc(soap, sizeof(ns1__ChRunStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ChRunStatus *)soap_instantiate_ns1__ChRunStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ChRunStatus ** p = (ns1__ChRunStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChRunStatus, sizeof(ns1__ChRunStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChRunStatus(struct soap *soap, ns1__ChRunStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChRunStatus);
	if (soap_out_PointerTons1__ChRunStatus(soap, tag?tag:"ns1:ChRunStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ChRunStatus ** SOAP_FMAC4 soap_get_PointerTons1__ChRunStatus(struct soap *soap, ns1__ChRunStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChRunStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChannelCfg(struct soap *soap, ns1__ChannelCfg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChannelCfg))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChannelCfg(struct soap *soap, const char *tag, int id, ns1__ChannelCfg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChannelCfg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ChannelCfg ** SOAP_FMAC4 soap_in_PointerTons1__ChannelCfg(struct soap *soap, const char *tag, ns1__ChannelCfg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChannelCfg **)soap_malloc(soap, sizeof(ns1__ChannelCfg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ChannelCfg *)soap_instantiate_ns1__ChannelCfg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ChannelCfg ** p = (ns1__ChannelCfg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChannelCfg, sizeof(ns1__ChannelCfg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChannelCfg(struct soap *soap, ns1__ChannelCfg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChannelCfg);
	if (soap_out_PointerTons1__ChannelCfg(soap, tag?tag:"ns1:ChannelCfg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ChannelCfg ** SOAP_FMAC4 soap_get_PointerTons1__ChannelCfg(struct soap *soap, ns1__ChannelCfg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChannelCfg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SqlResult(struct soap *soap, ns1__SqlResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SqlResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SqlResult(struct soap *soap, const char *tag, int id, ns1__SqlResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SqlResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SqlResult ** SOAP_FMAC4 soap_in_PointerTons1__SqlResult(struct soap *soap, const char *tag, ns1__SqlResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SqlResult **)soap_malloc(soap, sizeof(ns1__SqlResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SqlResult *)soap_instantiate_ns1__SqlResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SqlResult ** p = (ns1__SqlResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SqlResult, sizeof(ns1__SqlResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SqlResult(struct soap *soap, ns1__SqlResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SqlResult);
	if (soap_out_PointerTons1__SqlResult(soap, tag?tag:"ns1:SqlResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SqlResult ** SOAP_FMAC4 soap_get_PointerTons1__SqlResult(struct soap *soap, ns1__SqlResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SqlResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
