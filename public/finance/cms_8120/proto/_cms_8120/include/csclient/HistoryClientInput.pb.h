// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csclient/HistoryClientInput.proto

#ifndef PROTOBUF_csclient_2fHistoryClientInput_2eproto__INCLUDED
#define PROTOBUF_csclient_2fHistoryClientInput_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_csclient_2fHistoryClientInput_2eproto();
void protobuf_AssignDesc_csclient_2fHistoryClientInput_2eproto();
void protobuf_ShutdownFile_csclient_2fHistoryClientInput_2eproto();

class HisClientInput;
class ReqHisClientInput;
class RspCHisClientInput;

// ===================================================================

class HisClientInput : public ::google::protobuf::Message {
 public:
  HisClientInput();
  virtual ~HisClientInput();
  
  HisClientInput(const HisClientInput& from);
  
  inline HisClientInput& operator=(const HisClientInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HisClientInput& default_instance();
  
  void Swap(HisClientInput* other);
  
  // implements Message ----------------------------------------------
  
  HisClientInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HisClientInput& from);
  void MergeFrom(const HisClientInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string nProId = 1;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNProIdFieldNumber = 1;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional int32 inputRegionId = 2;
  inline bool has_inputregionid() const;
  inline void clear_inputregionid();
  static const int kInputRegionIdFieldNumber = 2;
  inline ::google::protobuf::int32 inputregionid() const;
  inline void set_inputregionid(::google::protobuf::int32 value);
  
  // optional string inputRegionCode = 3;
  inline bool has_inputregioncode() const;
  inline void clear_inputregioncode();
  static const int kInputRegionCodeFieldNumber = 3;
  inline const ::std::string& inputregioncode() const;
  inline void set_inputregioncode(const ::std::string& value);
  inline void set_inputregioncode(const char* value);
  inline void set_inputregioncode(const char* value, size_t size);
  inline ::std::string* mutable_inputregioncode();
  inline ::std::string* release_inputregioncode();
  
  // optional string inputRegionName = 5;
  inline bool has_inputregionname() const;
  inline void clear_inputregionname();
  static const int kInputRegionNameFieldNumber = 5;
  inline const ::std::string& inputregionname() const;
  inline void set_inputregionname(const ::std::string& value);
  inline void set_inputregionname(const char* value);
  inline void set_inputregionname(const char* value, size_t size);
  inline ::std::string* mutable_inputregionname();
  inline ::std::string* release_inputregionname();
  
  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string strCreditPhone = 7;
  inline bool has_strcreditphone() const;
  inline void clear_strcreditphone();
  static const int kStrCreditPhoneFieldNumber = 7;
  inline const ::std::string& strcreditphone() const;
  inline void set_strcreditphone(const ::std::string& value);
  inline void set_strcreditphone(const char* value);
  inline void set_strcreditphone(const char* value, size_t size);
  inline ::std::string* mutable_strcreditphone();
  inline ::std::string* release_strcreditphone();
  
  // optional int32 creditId = 8;
  inline bool has_creditid() const;
  inline void clear_creditid();
  static const int kCreditIdFieldNumber = 8;
  inline ::google::protobuf::int32 creditid() const;
  inline void set_creditid(::google::protobuf::int32 value);
  
  // optional string creditCode = 9;
  inline bool has_creditcode() const;
  inline void clear_creditcode();
  static const int kCreditCodeFieldNumber = 9;
  inline const ::std::string& creditcode() const;
  inline void set_creditcode(const ::std::string& value);
  inline void set_creditcode(const char* value);
  inline void set_creditcode(const char* value, size_t size);
  inline ::std::string* mutable_creditcode();
  inline ::std::string* release_creditcode();
  
  // optional int32 productTypeId = 10;
  inline bool has_producttypeid() const;
  inline void clear_producttypeid();
  static const int kProductTypeIdFieldNumber = 10;
  inline ::google::protobuf::int32 producttypeid() const;
  inline void set_producttypeid(::google::protobuf::int32 value);
  
  // optional string productTypeName = 11;
  inline bool has_producttypename() const;
  inline void clear_producttypename();
  static const int kProductTypeNameFieldNumber = 11;
  inline const ::std::string& producttypename() const;
  inline void set_producttypename(const ::std::string& value);
  inline void set_producttypename(const char* value);
  inline void set_producttypename(const char* value, size_t size);
  inline ::std::string* mutable_producttypename();
  inline ::std::string* release_producttypename();
  
  // optional int32 productId = 12;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 12;
  inline ::google::protobuf::int32 productid() const;
  inline void set_productid(::google::protobuf::int32 value);
  
  // optional string productName = 13;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 13;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string productCode = 14;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 14;
  inline const ::std::string& productcode() const;
  inline void set_productcode(const ::std::string& value);
  inline void set_productcode(const char* value);
  inline void set_productcode(const char* value, size_t size);
  inline ::std::string* mutable_productcode();
  inline ::std::string* release_productcode();
  
  // optional string strGrade = 15;
  inline bool has_strgrade() const;
  inline void clear_strgrade();
  static const int kStrGradeFieldNumber = 15;
  inline const ::std::string& strgrade() const;
  inline void set_strgrade(const ::std::string& value);
  inline void set_strgrade(const char* value);
  inline void set_strgrade(const char* value, size_t size);
  inline ::std::string* mutable_strgrade();
  inline ::std::string* release_strgrade();
  
  // optional string strBuyMoney = 16;
  inline bool has_strbuymoney() const;
  inline void clear_strbuymoney();
  static const int kStrBuyMoneyFieldNumber = 16;
  inline const ::std::string& strbuymoney() const;
  inline void set_strbuymoney(const ::std::string& value);
  inline void set_strbuymoney(const char* value);
  inline void set_strbuymoney(const char* value, size_t size);
  inline ::std::string* mutable_strbuymoney();
  inline ::std::string* release_strbuymoney();
  
  // optional int32 inputUser = 17;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 17;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // optional string businessTime = 18;
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 18;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // optional int32 clientId = 19;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 19;
  inline ::google::protobuf::int32 clientid() const;
  inline void set_clientid(::google::protobuf::int32 value);
  
  // optional string pictureStrart = 20;
  inline bool has_picturestrart() const;
  inline void clear_picturestrart();
  static const int kPictureStrartFieldNumber = 20;
  inline const ::std::string& picturestrart() const;
  inline void set_picturestrart(const ::std::string& value);
  inline void set_picturestrart(const char* value);
  inline void set_picturestrart(const char* value, size_t size);
  inline ::std::string* mutable_picturestrart();
  inline ::std::string* release_picturestrart();
  
  // optional string pictureEnd = 21;
  inline bool has_pictureend() const;
  inline void clear_pictureend();
  static const int kPictureEndFieldNumber = 21;
  inline const ::std::string& pictureend() const;
  inline void set_pictureend(const ::std::string& value);
  inline void set_pictureend(const char* value);
  inline void set_pictureend(const char* value, size_t size);
  inline ::std::string* mutable_pictureend();
  inline ::std::string* release_pictureend();
  
  // @@protoc_insertion_point(class_scope:cms_8120.HisClientInput)
 private:
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_inputregionid();
  inline void clear_has_inputregionid();
  inline void set_has_inputregioncode();
  inline void clear_has_inputregioncode();
  inline void set_has_inputregionname();
  inline void clear_has_inputregionname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_strcreditphone();
  inline void clear_has_strcreditphone();
  inline void set_has_creditid();
  inline void clear_has_creditid();
  inline void set_has_creditcode();
  inline void clear_has_creditcode();
  inline void set_has_producttypeid();
  inline void clear_has_producttypeid();
  inline void set_has_producttypename();
  inline void clear_has_producttypename();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_strgrade();
  inline void clear_has_strgrade();
  inline void set_has_strbuymoney();
  inline void clear_has_strbuymoney();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_picturestrart();
  inline void clear_has_picturestrart();
  inline void set_has_pictureend();
  inline void clear_has_pictureend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nproid_;
  ::std::string* inputregioncode_;
  ::std::string* inputregionname_;
  ::google::protobuf::int32 inputregionid_;
  ::google::protobuf::int32 creditid_;
  ::std::string* name_;
  ::std::string* strcreditphone_;
  ::std::string* creditcode_;
  ::std::string* producttypename_;
  ::google::protobuf::int32 producttypeid_;
  ::google::protobuf::int32 productid_;
  ::std::string* productname_;
  ::std::string* productcode_;
  ::std::string* strgrade_;
  ::std::string* strbuymoney_;
  ::std::string* businesstime_;
  ::google::protobuf::int32 inputuser_;
  ::google::protobuf::int32 clientid_;
  ::std::string* picturestrart_;
  ::std::string* pictureend_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fHistoryClientInput_2eproto();
  friend void protobuf_AssignDesc_csclient_2fHistoryClientInput_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fHistoryClientInput_2eproto();
  
  void InitAsDefaultInstance();
  static HisClientInput* default_instance_;
};
// -------------------------------------------------------------------

class ReqHisClientInput : public ::google::protobuf::Message {
 public:
  ReqHisClientInput();
  virtual ~ReqHisClientInput();
  
  ReqHisClientInput(const ReqHisClientInput& from);
  
  inline ReqHisClientInput& operator=(const ReqHisClientInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHisClientInput& default_instance();
  
  void Swap(ReqHisClientInput* other);
  
  // implements Message ----------------------------------------------
  
  ReqHisClientInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHisClientInput& from);
  void MergeFrom(const ReqHisClientInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional string startDate = 2;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartDateFieldNumber = 2;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  
  // optional string endDate = 3;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEndDateFieldNumber = 3;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  
  // optional string custName = 4;
  inline bool has_custname() const;
  inline void clear_custname();
  static const int kCustNameFieldNumber = 4;
  inline const ::std::string& custname() const;
  inline void set_custname(const ::std::string& value);
  inline void set_custname(const char* value);
  inline void set_custname(const char* value, size_t size);
  inline ::std::string* mutable_custname();
  inline ::std::string* release_custname();
  
  // optional string nproId = 5;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNproIdFieldNumber = 5;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional int32 inputUser = 6;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 6;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // optional int32 pageNo = 7;
  inline bool has_pageno() const;
  inline void clear_pageno();
  static const int kPageNoFieldNumber = 7;
  inline ::google::protobuf::int32 pageno() const;
  inline void set_pageno(::google::protobuf::int32 value);
  
  // optional int32 pageSize = 8;
  inline bool has_pagesize() const;
  inline void clear_pagesize();
  static const int kPageSizeFieldNumber = 8;
  inline ::google::protobuf::int32 pagesize() const;
  inline void set_pagesize(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqHisClientInput)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_custname();
  inline void clear_has_custname();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  inline void set_has_pageno();
  inline void clear_has_pageno();
  inline void set_has_pagesize();
  inline void clear_has_pagesize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* startdate_;
  ::std::string* enddate_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 inputuser_;
  ::std::string* custname_;
  ::std::string* nproid_;
  ::google::protobuf::int32 pageno_;
  ::google::protobuf::int32 pagesize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fHistoryClientInput_2eproto();
  friend void protobuf_AssignDesc_csclient_2fHistoryClientInput_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fHistoryClientInput_2eproto();
  
  void InitAsDefaultInstance();
  static ReqHisClientInput* default_instance_;
};
// -------------------------------------------------------------------

class RspCHisClientInput : public ::google::protobuf::Message {
 public:
  RspCHisClientInput();
  virtual ~RspCHisClientInput();
  
  RspCHisClientInput(const RspCHisClientInput& from);
  
  inline RspCHisClientInput& operator=(const RspCHisClientInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RspCHisClientInput& default_instance();
  
  void Swap(RspCHisClientInput* other);
  
  // implements Message ----------------------------------------------
  
  RspCHisClientInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspCHisClientInput& from);
  void MergeFrom(const RspCHisClientInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string result_info = 3;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 3;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const char* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  
  // repeated .cms_8120.HisClientInput hisClientInput = 4;
  inline int hisclientinput_size() const;
  inline void clear_hisclientinput();
  static const int kHisClientInputFieldNumber = 4;
  inline const ::cms_8120::HisClientInput& hisclientinput(int index) const;
  inline ::cms_8120::HisClientInput* mutable_hisclientinput(int index);
  inline ::cms_8120::HisClientInput* add_hisclientinput();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::HisClientInput >&
      hisclientinput() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::HisClientInput >*
      mutable_hisclientinput();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RspCHisClientInput)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_info();
  inline void clear_has_result_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 result_;
  ::std::string* result_info_;
  ::google::protobuf::RepeatedPtrField< ::cms_8120::HisClientInput > hisclientinput_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fHistoryClientInput_2eproto();
  friend void protobuf_AssignDesc_csclient_2fHistoryClientInput_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fHistoryClientInput_2eproto();
  
  void InitAsDefaultInstance();
  static RspCHisClientInput* default_instance_;
};
// ===================================================================


// ===================================================================

// HisClientInput

// optional string nProId = 1;
inline bool HisClientInput::has_nproid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HisClientInput::set_has_nproid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HisClientInput::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HisClientInput::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& HisClientInput::nproid() const {
  return *nproid_;
}
inline void HisClientInput::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void HisClientInput::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void HisClientInput::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* HisClientInput::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 inputRegionId = 2;
inline bool HisClientInput::has_inputregionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HisClientInput::set_has_inputregionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HisClientInput::clear_has_inputregionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HisClientInput::clear_inputregionid() {
  inputregionid_ = 0;
  clear_has_inputregionid();
}
inline ::google::protobuf::int32 HisClientInput::inputregionid() const {
  return inputregionid_;
}
inline void HisClientInput::set_inputregionid(::google::protobuf::int32 value) {
  set_has_inputregionid();
  inputregionid_ = value;
}

// optional string inputRegionCode = 3;
inline bool HisClientInput::has_inputregioncode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HisClientInput::set_has_inputregioncode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HisClientInput::clear_has_inputregioncode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HisClientInput::clear_inputregioncode() {
  if (inputregioncode_ != &::google::protobuf::internal::kEmptyString) {
    inputregioncode_->clear();
  }
  clear_has_inputregioncode();
}
inline const ::std::string& HisClientInput::inputregioncode() const {
  return *inputregioncode_;
}
inline void HisClientInput::set_inputregioncode(const ::std::string& value) {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  inputregioncode_->assign(value);
}
inline void HisClientInput::set_inputregioncode(const char* value) {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  inputregioncode_->assign(value);
}
inline void HisClientInput::set_inputregioncode(const char* value, size_t size) {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  inputregioncode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_inputregioncode() {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  return inputregioncode_;
}
inline ::std::string* HisClientInput::release_inputregioncode() {
  clear_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputregioncode_;
    inputregioncode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string inputRegionName = 5;
inline bool HisClientInput::has_inputregionname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HisClientInput::set_has_inputregionname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HisClientInput::clear_has_inputregionname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HisClientInput::clear_inputregionname() {
  if (inputregionname_ != &::google::protobuf::internal::kEmptyString) {
    inputregionname_->clear();
  }
  clear_has_inputregionname();
}
inline const ::std::string& HisClientInput::inputregionname() const {
  return *inputregionname_;
}
inline void HisClientInput::set_inputregionname(const ::std::string& value) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(value);
}
inline void HisClientInput::set_inputregionname(const char* value) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(value);
}
inline void HisClientInput::set_inputregionname(const char* value, size_t size) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_inputregionname() {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  return inputregionname_;
}
inline ::std::string* HisClientInput::release_inputregionname() {
  clear_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputregionname_;
    inputregionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 6;
inline bool HisClientInput::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HisClientInput::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HisClientInput::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HisClientInput::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HisClientInput::name() const {
  return *name_;
}
inline void HisClientInput::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HisClientInput::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HisClientInput::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* HisClientInput::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCreditPhone = 7;
inline bool HisClientInput::has_strcreditphone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HisClientInput::set_has_strcreditphone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HisClientInput::clear_has_strcreditphone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HisClientInput::clear_strcreditphone() {
  if (strcreditphone_ != &::google::protobuf::internal::kEmptyString) {
    strcreditphone_->clear();
  }
  clear_has_strcreditphone();
}
inline const ::std::string& HisClientInput::strcreditphone() const {
  return *strcreditphone_;
}
inline void HisClientInput::set_strcreditphone(const ::std::string& value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void HisClientInput::set_strcreditphone(const char* value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void HisClientInput::set_strcreditphone(const char* value, size_t size) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_strcreditphone() {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  return strcreditphone_;
}
inline ::std::string* HisClientInput::release_strcreditphone() {
  clear_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcreditphone_;
    strcreditphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 creditId = 8;
inline bool HisClientInput::has_creditid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HisClientInput::set_has_creditid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HisClientInput::clear_has_creditid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HisClientInput::clear_creditid() {
  creditid_ = 0;
  clear_has_creditid();
}
inline ::google::protobuf::int32 HisClientInput::creditid() const {
  return creditid_;
}
inline void HisClientInput::set_creditid(::google::protobuf::int32 value) {
  set_has_creditid();
  creditid_ = value;
}

// optional string creditCode = 9;
inline bool HisClientInput::has_creditcode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HisClientInput::set_has_creditcode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HisClientInput::clear_has_creditcode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HisClientInput::clear_creditcode() {
  if (creditcode_ != &::google::protobuf::internal::kEmptyString) {
    creditcode_->clear();
  }
  clear_has_creditcode();
}
inline const ::std::string& HisClientInput::creditcode() const {
  return *creditcode_;
}
inline void HisClientInput::set_creditcode(const ::std::string& value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void HisClientInput::set_creditcode(const char* value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void HisClientInput::set_creditcode(const char* value, size_t size) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_creditcode() {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  return creditcode_;
}
inline ::std::string* HisClientInput::release_creditcode() {
  clear_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditcode_;
    creditcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productTypeId = 10;
inline bool HisClientInput::has_producttypeid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HisClientInput::set_has_producttypeid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HisClientInput::clear_has_producttypeid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HisClientInput::clear_producttypeid() {
  producttypeid_ = 0;
  clear_has_producttypeid();
}
inline ::google::protobuf::int32 HisClientInput::producttypeid() const {
  return producttypeid_;
}
inline void HisClientInput::set_producttypeid(::google::protobuf::int32 value) {
  set_has_producttypeid();
  producttypeid_ = value;
}

// optional string productTypeName = 11;
inline bool HisClientInput::has_producttypename() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HisClientInput::set_has_producttypename() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HisClientInput::clear_has_producttypename() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HisClientInput::clear_producttypename() {
  if (producttypename_ != &::google::protobuf::internal::kEmptyString) {
    producttypename_->clear();
  }
  clear_has_producttypename();
}
inline const ::std::string& HisClientInput::producttypename() const {
  return *producttypename_;
}
inline void HisClientInput::set_producttypename(const ::std::string& value) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(value);
}
inline void HisClientInput::set_producttypename(const char* value) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(value);
}
inline void HisClientInput::set_producttypename(const char* value, size_t size) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_producttypename() {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  return producttypename_;
}
inline ::std::string* HisClientInput::release_producttypename() {
  clear_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = producttypename_;
    producttypename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productId = 12;
inline bool HisClientInput::has_productid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HisClientInput::set_has_productid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HisClientInput::clear_has_productid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HisClientInput::clear_productid() {
  productid_ = 0;
  clear_has_productid();
}
inline ::google::protobuf::int32 HisClientInput::productid() const {
  return productid_;
}
inline void HisClientInput::set_productid(::google::protobuf::int32 value) {
  set_has_productid();
  productid_ = value;
}

// optional string productName = 13;
inline bool HisClientInput::has_productname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HisClientInput::set_has_productname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HisClientInput::clear_has_productname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HisClientInput::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& HisClientInput::productname() const {
  return *productname_;
}
inline void HisClientInput::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void HisClientInput::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void HisClientInput::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* HisClientInput::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productCode = 14;
inline bool HisClientInput::has_productcode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HisClientInput::set_has_productcode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HisClientInput::clear_has_productcode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HisClientInput::clear_productcode() {
  if (productcode_ != &::google::protobuf::internal::kEmptyString) {
    productcode_->clear();
  }
  clear_has_productcode();
}
inline const ::std::string& HisClientInput::productcode() const {
  return *productcode_;
}
inline void HisClientInput::set_productcode(const ::std::string& value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void HisClientInput::set_productcode(const char* value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void HisClientInput::set_productcode(const char* value, size_t size) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_productcode() {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  return productcode_;
}
inline ::std::string* HisClientInput::release_productcode() {
  clear_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productcode_;
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strGrade = 15;
inline bool HisClientInput::has_strgrade() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HisClientInput::set_has_strgrade() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HisClientInput::clear_has_strgrade() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HisClientInput::clear_strgrade() {
  if (strgrade_ != &::google::protobuf::internal::kEmptyString) {
    strgrade_->clear();
  }
  clear_has_strgrade();
}
inline const ::std::string& HisClientInput::strgrade() const {
  return *strgrade_;
}
inline void HisClientInput::set_strgrade(const ::std::string& value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void HisClientInput::set_strgrade(const char* value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void HisClientInput::set_strgrade(const char* value, size_t size) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_strgrade() {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  return strgrade_;
}
inline ::std::string* HisClientInput::release_strgrade() {
  clear_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgrade_;
    strgrade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBuyMoney = 16;
inline bool HisClientInput::has_strbuymoney() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void HisClientInput::set_has_strbuymoney() {
  _has_bits_[0] |= 0x00004000u;
}
inline void HisClientInput::clear_has_strbuymoney() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void HisClientInput::clear_strbuymoney() {
  if (strbuymoney_ != &::google::protobuf::internal::kEmptyString) {
    strbuymoney_->clear();
  }
  clear_has_strbuymoney();
}
inline const ::std::string& HisClientInput::strbuymoney() const {
  return *strbuymoney_;
}
inline void HisClientInput::set_strbuymoney(const ::std::string& value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void HisClientInput::set_strbuymoney(const char* value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void HisClientInput::set_strbuymoney(const char* value, size_t size) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_strbuymoney() {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  return strbuymoney_;
}
inline ::std::string* HisClientInput::release_strbuymoney() {
  clear_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbuymoney_;
    strbuymoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 inputUser = 17;
inline bool HisClientInput::has_inputuser() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void HisClientInput::set_has_inputuser() {
  _has_bits_[0] |= 0x00008000u;
}
inline void HisClientInput::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void HisClientInput::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 HisClientInput::inputuser() const {
  return inputuser_;
}
inline void HisClientInput::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// optional string businessTime = 18;
inline bool HisClientInput::has_businesstime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void HisClientInput::set_has_businesstime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void HisClientInput::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void HisClientInput::clear_businesstime() {
  if (businesstime_ != &::google::protobuf::internal::kEmptyString) {
    businesstime_->clear();
  }
  clear_has_businesstime();
}
inline const ::std::string& HisClientInput::businesstime() const {
  return *businesstime_;
}
inline void HisClientInput::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void HisClientInput::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void HisClientInput::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  return businesstime_;
}
inline ::std::string* HisClientInput::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 clientId = 19;
inline bool HisClientInput::has_clientid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void HisClientInput::set_has_clientid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void HisClientInput::clear_has_clientid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void HisClientInput::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 HisClientInput::clientid() const {
  return clientid_;
}
inline void HisClientInput::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string pictureStrart = 20;
inline bool HisClientInput::has_picturestrart() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void HisClientInput::set_has_picturestrart() {
  _has_bits_[0] |= 0x00040000u;
}
inline void HisClientInput::clear_has_picturestrart() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void HisClientInput::clear_picturestrart() {
  if (picturestrart_ != &::google::protobuf::internal::kEmptyString) {
    picturestrart_->clear();
  }
  clear_has_picturestrart();
}
inline const ::std::string& HisClientInput::picturestrart() const {
  return *picturestrart_;
}
inline void HisClientInput::set_picturestrart(const ::std::string& value) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(value);
}
inline void HisClientInput::set_picturestrart(const char* value) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(value);
}
inline void HisClientInput::set_picturestrart(const char* value, size_t size) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_picturestrart() {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  return picturestrart_;
}
inline ::std::string* HisClientInput::release_picturestrart() {
  clear_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picturestrart_;
    picturestrart_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pictureEnd = 21;
inline bool HisClientInput::has_pictureend() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void HisClientInput::set_has_pictureend() {
  _has_bits_[0] |= 0x00080000u;
}
inline void HisClientInput::clear_has_pictureend() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void HisClientInput::clear_pictureend() {
  if (pictureend_ != &::google::protobuf::internal::kEmptyString) {
    pictureend_->clear();
  }
  clear_has_pictureend();
}
inline const ::std::string& HisClientInput::pictureend() const {
  return *pictureend_;
}
inline void HisClientInput::set_pictureend(const ::std::string& value) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(value);
}
inline void HisClientInput::set_pictureend(const char* value) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(value);
}
inline void HisClientInput::set_pictureend(const char* value, size_t size) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HisClientInput::mutable_pictureend() {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  return pictureend_;
}
inline ::std::string* HisClientInput::release_pictureend() {
  clear_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pictureend_;
    pictureend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqHisClientInput

// optional int32 cmd = 1;
inline bool ReqHisClientInput::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqHisClientInput::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqHisClientInput::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqHisClientInput::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqHisClientInput::cmd() const {
  return cmd_;
}
inline void ReqHisClientInput::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string startDate = 2;
inline bool ReqHisClientInput::has_startdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqHisClientInput::set_has_startdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqHisClientInput::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqHisClientInput::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& ReqHisClientInput::startdate() const {
  return *startdate_;
}
inline void ReqHisClientInput::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void ReqHisClientInput::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void ReqHisClientInput::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqHisClientInput::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  return startdate_;
}
inline ::std::string* ReqHisClientInput::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string endDate = 3;
inline bool ReqHisClientInput::has_enddate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqHisClientInput::set_has_enddate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqHisClientInput::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqHisClientInput::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& ReqHisClientInput::enddate() const {
  return *enddate_;
}
inline void ReqHisClientInput::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void ReqHisClientInput::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void ReqHisClientInput::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqHisClientInput::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  return enddate_;
}
inline ::std::string* ReqHisClientInput::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string custName = 4;
inline bool ReqHisClientInput::has_custname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqHisClientInput::set_has_custname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqHisClientInput::clear_has_custname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqHisClientInput::clear_custname() {
  if (custname_ != &::google::protobuf::internal::kEmptyString) {
    custname_->clear();
  }
  clear_has_custname();
}
inline const ::std::string& ReqHisClientInput::custname() const {
  return *custname_;
}
inline void ReqHisClientInput::set_custname(const ::std::string& value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void ReqHisClientInput::set_custname(const char* value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void ReqHisClientInput::set_custname(const char* value, size_t size) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqHisClientInput::mutable_custname() {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  return custname_;
}
inline ::std::string* ReqHisClientInput::release_custname() {
  clear_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custname_;
    custname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nproId = 5;
inline bool ReqHisClientInput::has_nproid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqHisClientInput::set_has_nproid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqHisClientInput::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqHisClientInput::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& ReqHisClientInput::nproid() const {
  return *nproid_;
}
inline void ReqHisClientInput::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void ReqHisClientInput::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void ReqHisClientInput::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqHisClientInput::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* ReqHisClientInput::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 inputUser = 6;
inline bool ReqHisClientInput::has_inputuser() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqHisClientInput::set_has_inputuser() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqHisClientInput::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqHisClientInput::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 ReqHisClientInput::inputuser() const {
  return inputuser_;
}
inline void ReqHisClientInput::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// optional int32 pageNo = 7;
inline bool ReqHisClientInput::has_pageno() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqHisClientInput::set_has_pageno() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqHisClientInput::clear_has_pageno() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqHisClientInput::clear_pageno() {
  pageno_ = 0;
  clear_has_pageno();
}
inline ::google::protobuf::int32 ReqHisClientInput::pageno() const {
  return pageno_;
}
inline void ReqHisClientInput::set_pageno(::google::protobuf::int32 value) {
  set_has_pageno();
  pageno_ = value;
}

// optional int32 pageSize = 8;
inline bool ReqHisClientInput::has_pagesize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqHisClientInput::set_has_pagesize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqHisClientInput::clear_has_pagesize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqHisClientInput::clear_pagesize() {
  pagesize_ = 0;
  clear_has_pagesize();
}
inline ::google::protobuf::int32 ReqHisClientInput::pagesize() const {
  return pagesize_;
}
inline void ReqHisClientInput::set_pagesize(::google::protobuf::int32 value) {
  set_has_pagesize();
  pagesize_ = value;
}

// -------------------------------------------------------------------

// RspCHisClientInput

// optional int32 cmd = 1;
inline bool RspCHisClientInput::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspCHisClientInput::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspCHisClientInput::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspCHisClientInput::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 RspCHisClientInput::cmd() const {
  return cmd_;
}
inline void RspCHisClientInput::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 result = 2;
inline bool RspCHisClientInput::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspCHisClientInput::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspCHisClientInput::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspCHisClientInput::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RspCHisClientInput::result() const {
  return result_;
}
inline void RspCHisClientInput::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string result_info = 3;
inline bool RspCHisClientInput::has_result_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspCHisClientInput::set_has_result_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspCHisClientInput::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspCHisClientInput::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::kEmptyString) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& RspCHisClientInput::result_info() const {
  return *result_info_;
}
inline void RspCHisClientInput::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspCHisClientInput::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspCHisClientInput::set_result_info(const char* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspCHisClientInput::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  return result_info_;
}
inline ::std::string* RspCHisClientInput::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cms_8120.HisClientInput hisClientInput = 4;
inline int RspCHisClientInput::hisclientinput_size() const {
  return hisclientinput_.size();
}
inline void RspCHisClientInput::clear_hisclientinput() {
  hisclientinput_.Clear();
}
inline const ::cms_8120::HisClientInput& RspCHisClientInput::hisclientinput(int index) const {
  return hisclientinput_.Get(index);
}
inline ::cms_8120::HisClientInput* RspCHisClientInput::mutable_hisclientinput(int index) {
  return hisclientinput_.Mutable(index);
}
inline ::cms_8120::HisClientInput* RspCHisClientInput::add_hisclientinput() {
  return hisclientinput_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::HisClientInput >&
RspCHisClientInput::hisclientinput() const {
  return hisclientinput_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::HisClientInput >*
RspCHisClientInput::mutable_hisclientinput() {
  return &hisclientinput_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_csclient_2fHistoryClientInput_2eproto__INCLUDED
