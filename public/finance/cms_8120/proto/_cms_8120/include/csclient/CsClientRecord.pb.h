// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csclient/CsClientRecord.proto

#ifndef PROTOBUF_csclient_2fCsClientRecord_2eproto__INCLUDED
#define PROTOBUF_csclient_2fCsClientRecord_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();

class CSClientInput;
class CSRecords;
class ReqCsClientRecord;
class RspCsClientRecord;
class RecordsDetailInfo;
class RecordsInfo;
class ReqRecordsInfo;
class RspCsClientRecordsInfo;
class ErrRecordsInfo;
class RspErrRecordsInfo;
class ReqErrorRecord;
class ReqPrintRecord;
class RspPrintRecord;

// ===================================================================

class CSClientInput : public ::google::protobuf::Message {
 public:
  CSClientInput();
  virtual ~CSClientInput();
  
  CSClientInput(const CSClientInput& from);
  
  inline CSClientInput& operator=(const CSClientInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSClientInput& default_instance();
  
  void Swap(CSClientInput* other);
  
  // implements Message ----------------------------------------------
  
  CSClientInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSClientInput& from);
  void MergeFrom(const CSClientInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 inputRegionId = 2;
  inline bool has_inputregionid() const;
  inline void clear_inputregionid();
  static const int kInputRegionIdFieldNumber = 2;
  inline ::google::protobuf::int32 inputregionid() const;
  inline void set_inputregionid(::google::protobuf::int32 value);
  
  // optional int32 inputUser = 3;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 3;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // optional string nproId = 4;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNproIdFieldNumber = 4;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional string inputTime = 5;
  inline bool has_inputtime() const;
  inline void clear_inputtime();
  static const int kInputTimeFieldNumber = 5;
  inline const ::std::string& inputtime() const;
  inline void set_inputtime(const ::std::string& value);
  inline void set_inputtime(const char* value);
  inline void set_inputtime(const char* value, size_t size);
  inline ::std::string* mutable_inputtime();
  inline ::std::string* release_inputtime();
  
  // optional string businessTime = 6;
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 6;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // optional string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string creditCode = 8;
  inline bool has_creditcode() const;
  inline void clear_creditcode();
  static const int kCreditCodeFieldNumber = 8;
  inline const ::std::string& creditcode() const;
  inline void set_creditcode(const ::std::string& value);
  inline void set_creditcode(const char* value);
  inline void set_creditcode(const char* value, size_t size);
  inline ::std::string* mutable_creditcode();
  inline ::std::string* release_creditcode();
  
  // optional int32 creditId = 9;
  inline bool has_creditid() const;
  inline void clear_creditid();
  static const int kCreditIdFieldNumber = 9;
  inline ::google::protobuf::int32 creditid() const;
  inline void set_creditid(::google::protobuf::int32 value);
  
  // optional int32 productId = 10;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 10;
  inline ::google::protobuf::int32 productid() const;
  inline void set_productid(::google::protobuf::int32 value);
  
  // optional string strBankNo = 11;
  inline bool has_strbankno() const;
  inline void clear_strbankno();
  static const int kStrBankNoFieldNumber = 11;
  inline const ::std::string& strbankno() const;
  inline void set_strbankno(const ::std::string& value);
  inline void set_strbankno(const char* value);
  inline void set_strbankno(const char* value, size_t size);
  inline ::std::string* mutable_strbankno();
  inline ::std::string* release_strbankno();
  
  // optional string strBuyMoney = 12;
  inline bool has_strbuymoney() const;
  inline void clear_strbuymoney();
  static const int kStrBuyMoneyFieldNumber = 12;
  inline const ::std::string& strbuymoney() const;
  inline void set_strbuymoney(const ::std::string& value);
  inline void set_strbuymoney(const char* value);
  inline void set_strbuymoney(const char* value, size_t size);
  inline ::std::string* mutable_strbuymoney();
  inline ::std::string* release_strbuymoney();
  
  // optional string strCreditPhone = 13;
  inline bool has_strcreditphone() const;
  inline void clear_strcreditphone();
  static const int kStrCreditPhoneFieldNumber = 13;
  inline const ::std::string& strcreditphone() const;
  inline void set_strcreditphone(const ::std::string& value);
  inline void set_strcreditphone(const char* value);
  inline void set_strcreditphone(const char* value, size_t size);
  inline ::std::string* mutable_strcreditphone();
  inline ::std::string* release_strcreditphone();
  
  // @@protoc_insertion_point(class_scope:cms_8120.CSClientInput)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_inputregionid();
  inline void clear_has_inputregionid();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_inputtime();
  inline void clear_has_inputtime();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_creditcode();
  inline void clear_has_creditcode();
  inline void set_has_creditid();
  inline void clear_has_creditid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_strbankno();
  inline void clear_has_strbankno();
  inline void set_has_strbuymoney();
  inline void clear_has_strbuymoney();
  inline void set_has_strcreditphone();
  inline void clear_has_strcreditphone();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 inputregionid_;
  ::std::string* nproid_;
  ::std::string* inputtime_;
  ::std::string* businesstime_;
  ::google::protobuf::int32 inputuser_;
  ::google::protobuf::int32 creditid_;
  ::std::string* name_;
  ::std::string* creditcode_;
  ::std::string* strbankno_;
  ::std::string* strbuymoney_;
  ::std::string* strcreditphone_;
  ::google::protobuf::int32 productid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static CSClientInput* default_instance_;
};
// -------------------------------------------------------------------

class CSRecords : public ::google::protobuf::Message {
 public:
  CSRecords();
  virtual ~CSRecords();
  
  CSRecords(const CSRecords& from);
  
  inline CSRecords& operator=(const CSRecords& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRecords& default_instance();
  
  void Swap(CSRecords* other);
  
  // implements Message ----------------------------------------------
  
  CSRecords* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRecords& from);
  void MergeFrom(const CSRecords& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string strRecordName = 2;
  inline bool has_strrecordname() const;
  inline void clear_strrecordname();
  static const int kStrRecordNameFieldNumber = 2;
  inline const ::std::string& strrecordname() const;
  inline void set_strrecordname(const ::std::string& value);
  inline void set_strrecordname(const char* value);
  inline void set_strrecordname(const char* value, size_t size);
  inline ::std::string* mutable_strrecordname();
  inline ::std::string* release_strrecordname();
  
  // optional int32 inputUser = 3;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 3;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // optional int32 inputRegionId = 4;
  inline bool has_inputregionid() const;
  inline void clear_inputregionid();
  static const int kInputRegionIdFieldNumber = 4;
  inline ::google::protobuf::int32 inputregionid() const;
  inline void set_inputregionid(::google::protobuf::int32 value);
  
  // optional int32 nrecordFileType = 5;
  inline bool has_nrecordfiletype() const;
  inline void clear_nrecordfiletype();
  static const int kNrecordFileTypeFieldNumber = 5;
  inline ::google::protobuf::int32 nrecordfiletype() const;
  inline void set_nrecordfiletype(::google::protobuf::int32 value);
  
  // optional string startTime = 6;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 6;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  
  // optional string endTime = 7;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 7;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  
  // optional string strUrl = 8;
  inline bool has_strurl() const;
  inline void clear_strurl();
  static const int kStrUrlFieldNumber = 8;
  inline const ::std::string& strurl() const;
  inline void set_strurl(const ::std::string& value);
  inline void set_strurl(const char* value);
  inline void set_strurl(const char* value, size_t size);
  inline ::std::string* mutable_strurl();
  inline ::std::string* release_strurl();
  
  // optional int32 nupLoadPercent = 9;
  inline bool has_nuploadpercent() const;
  inline void clear_nuploadpercent();
  static const int kNupLoadPercentFieldNumber = 9;
  inline ::google::protobuf::int32 nuploadpercent() const;
  inline void set_nuploadpercent(::google::protobuf::int32 value);
  
  // optional int32 nfileSize = 10;
  inline bool has_nfilesize() const;
  inline void clear_nfilesize();
  static const int kNfileSizeFieldNumber = 10;
  inline ::google::protobuf::int32 nfilesize() const;
  inline void set_nfilesize(::google::protobuf::int32 value);
  
  // optional string screenshotSrc = 11;
  inline bool has_screenshotsrc() const;
  inline void clear_screenshotsrc();
  static const int kScreenshotSrcFieldNumber = 11;
  inline const ::std::string& screenshotsrc() const;
  inline void set_screenshotsrc(const ::std::string& value);
  inline void set_screenshotsrc(const char* value);
  inline void set_screenshotsrc(const char* value, size_t size);
  inline ::std::string* mutable_screenshotsrc();
  inline ::std::string* release_screenshotsrc();
  
  // optional string strCloudIp = 12;
  inline bool has_strcloudip() const;
  inline void clear_strcloudip();
  static const int kStrCloudIpFieldNumber = 12;
  inline const ::std::string& strcloudip() const;
  inline void set_strcloudip(const ::std::string& value);
  inline void set_strcloudip(const char* value);
  inline void set_strcloudip(const char* value, size_t size);
  inline ::std::string* mutable_strcloudip();
  inline ::std::string* release_strcloudip();
  
  // optional int32 strCloudPort = 13;
  inline bool has_strcloudport() const;
  inline void clear_strcloudport();
  static const int kStrCloudPortFieldNumber = 13;
  inline ::google::protobuf::int32 strcloudport() const;
  inline void set_strcloudport(::google::protobuf::int32 value);
  
  // optional string strAccessKey = 14;
  inline bool has_straccesskey() const;
  inline void clear_straccesskey();
  static const int kStrAccessKeyFieldNumber = 14;
  inline const ::std::string& straccesskey() const;
  inline void set_straccesskey(const ::std::string& value);
  inline void set_straccesskey(const char* value);
  inline void set_straccesskey(const char* value, size_t size);
  inline ::std::string* mutable_straccesskey();
  inline ::std::string* release_straccesskey();
  
  // optional string strSecretKey = 15;
  inline bool has_strsecretkey() const;
  inline void clear_strsecretkey();
  static const int kStrSecretKeyFieldNumber = 15;
  inline const ::std::string& strsecretkey() const;
  inline void set_strsecretkey(const ::std::string& value);
  inline void set_strsecretkey(const char* value);
  inline void set_strsecretkey(const char* value, size_t size);
  inline ::std::string* mutable_strsecretkey();
  inline ::std::string* release_strsecretkey();
  
  // optional string strBucket = 16;
  inline bool has_strbucket() const;
  inline void clear_strbucket();
  static const int kStrBucketFieldNumber = 16;
  inline const ::std::string& strbucket() const;
  inline void set_strbucket(const ::std::string& value);
  inline void set_strbucket(const char* value);
  inline void set_strbucket(const char* value, size_t size);
  inline ::std::string* mutable_strbucket();
  inline ::std::string* release_strbucket();
  
  // @@protoc_insertion_point(class_scope:cms_8120.CSRecords)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_strrecordname();
  inline void clear_has_strrecordname();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  inline void set_has_inputregionid();
  inline void clear_has_inputregionid();
  inline void set_has_nrecordfiletype();
  inline void clear_has_nrecordfiletype();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_strurl();
  inline void clear_has_strurl();
  inline void set_has_nuploadpercent();
  inline void clear_has_nuploadpercent();
  inline void set_has_nfilesize();
  inline void clear_has_nfilesize();
  inline void set_has_screenshotsrc();
  inline void clear_has_screenshotsrc();
  inline void set_has_strcloudip();
  inline void clear_has_strcloudip();
  inline void set_has_strcloudport();
  inline void clear_has_strcloudport();
  inline void set_has_straccesskey();
  inline void clear_has_straccesskey();
  inline void set_has_strsecretkey();
  inline void clear_has_strsecretkey();
  inline void set_has_strbucket();
  inline void clear_has_strbucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* strrecordname_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 inputuser_;
  ::google::protobuf::int32 inputregionid_;
  ::google::protobuf::int32 nrecordfiletype_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::std::string* strurl_;
  ::google::protobuf::int32 nuploadpercent_;
  ::google::protobuf::int32 nfilesize_;
  ::std::string* screenshotsrc_;
  ::std::string* strcloudip_;
  ::std::string* straccesskey_;
  ::std::string* strsecretkey_;
  ::std::string* strbucket_;
  ::google::protobuf::int32 strcloudport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static CSRecords* default_instance_;
};
// -------------------------------------------------------------------

class ReqCsClientRecord : public ::google::protobuf::Message {
 public:
  ReqCsClientRecord();
  virtual ~ReqCsClientRecord();
  
  ReqCsClientRecord(const ReqCsClientRecord& from);
  
  inline ReqCsClientRecord& operator=(const ReqCsClientRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCsClientRecord& default_instance();
  
  void Swap(ReqCsClientRecord* other);
  
  // implements Message ----------------------------------------------
  
  ReqCsClientRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCsClientRecord& from);
  void MergeFrom(const ReqCsClientRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional .cms_8120.CSClientInput clientInput = 2;
  inline bool has_clientinput() const;
  inline void clear_clientinput();
  static const int kClientInputFieldNumber = 2;
  inline const ::cms_8120::CSClientInput& clientinput() const;
  inline ::cms_8120::CSClientInput* mutable_clientinput();
  inline ::cms_8120::CSClientInput* release_clientinput();
  
  // repeated .cms_8120.CSRecords records = 3;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 3;
  inline const ::cms_8120::CSRecords& records(int index) const;
  inline ::cms_8120::CSRecords* mutable_records(int index);
  inline ::cms_8120::CSRecords* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::CSRecords >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::CSRecords >*
      mutable_records();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqCsClientRecord)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_clientinput();
  inline void clear_has_clientinput();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cms_8120::CSClientInput* clientinput_;
  ::google::protobuf::RepeatedPtrField< ::cms_8120::CSRecords > records_;
  ::google::protobuf::int32 cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static ReqCsClientRecord* default_instance_;
};
// -------------------------------------------------------------------

class RspCsClientRecord : public ::google::protobuf::Message {
 public:
  RspCsClientRecord();
  virtual ~RspCsClientRecord();
  
  RspCsClientRecord(const RspCsClientRecord& from);
  
  inline RspCsClientRecord& operator=(const RspCsClientRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RspCsClientRecord& default_instance();
  
  void Swap(RspCsClientRecord* other);
  
  // implements Message ----------------------------------------------
  
  RspCsClientRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspCsClientRecord& from);
  void MergeFrom(const RspCsClientRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string result_info = 3;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 3;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const char* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RspCsClientRecord)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_info();
  inline void clear_has_result_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 result_;
  ::std::string* result_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static RspCsClientRecord* default_instance_;
};
// -------------------------------------------------------------------

class RecordsDetailInfo : public ::google::protobuf::Message {
 public:
  RecordsDetailInfo();
  virtual ~RecordsDetailInfo();
  
  RecordsDetailInfo(const RecordsDetailInfo& from);
  
  inline RecordsDetailInfo& operator=(const RecordsDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordsDetailInfo& default_instance();
  
  void Swap(RecordsDetailInfo* other);
  
  // implements Message ----------------------------------------------
  
  RecordsDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordsDetailInfo& from);
  void MergeFrom(const RecordsDetailInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional int32 recordStatus = 2;
  inline bool has_recordstatus() const;
  inline void clear_recordstatus();
  static const int kRecordStatusFieldNumber = 2;
  inline ::google::protobuf::int32 recordstatus() const;
  inline void set_recordstatus(::google::protobuf::int32 value);
  
  // optional string strRecordStatus = 3;
  inline bool has_strrecordstatus() const;
  inline void clear_strrecordstatus();
  static const int kStrRecordStatusFieldNumber = 3;
  inline const ::std::string& strrecordstatus() const;
  inline void set_strrecordstatus(const ::std::string& value);
  inline void set_strrecordstatus(const char* value);
  inline void set_strrecordstatus(const char* value, size_t size);
  inline ::std::string* mutable_strrecordstatus();
  inline ::std::string* release_strrecordstatus();
  
  // optional string errorMsg = 4;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 4;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  
  // optional string strUrl = 5;
  inline bool has_strurl() const;
  inline void clear_strurl();
  static const int kStrUrlFieldNumber = 5;
  inline const ::std::string& strurl() const;
  inline void set_strurl(const ::std::string& value);
  inline void set_strurl(const char* value);
  inline void set_strurl(const char* value, size_t size);
  inline ::std::string* mutable_strurl();
  inline ::std::string* release_strurl();
  
  // optional int32 videoId = 6;
  inline bool has_videoid() const;
  inline void clear_videoid();
  static const int kVideoIdFieldNumber = 6;
  inline ::google::protobuf::int32 videoid() const;
  inline void set_videoid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.RecordsDetailInfo)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_recordstatus();
  inline void clear_has_recordstatus();
  inline void set_has_strrecordstatus();
  inline void clear_has_strrecordstatus();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  inline void set_has_strurl();
  inline void clear_has_strurl();
  inline void set_has_videoid();
  inline void clear_has_videoid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  ::std::string* strrecordstatus_;
  ::std::string* errormsg_;
  ::google::protobuf::int32 recordstatus_;
  ::google::protobuf::int32 videoid_;
  ::std::string* strurl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static RecordsDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class RecordsInfo : public ::google::protobuf::Message {
 public:
  RecordsInfo();
  virtual ~RecordsInfo();
  
  RecordsInfo(const RecordsInfo& from);
  
  inline RecordsInfo& operator=(const RecordsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordsInfo& default_instance();
  
  void Swap(RecordsInfo* other);
  
  // implements Message ----------------------------------------------
  
  RecordsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordsInfo& from);
  void MergeFrom(const RecordsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string nProId = 2;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNProIdFieldNumber = 2;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional int32 inputRegionId = 3;
  inline bool has_inputregionid() const;
  inline void clear_inputregionid();
  static const int kInputRegionIdFieldNumber = 3;
  inline ::google::protobuf::int32 inputregionid() const;
  inline void set_inputregionid(::google::protobuf::int32 value);
  
  // optional string inputRegionCode = 4;
  inline bool has_inputregioncode() const;
  inline void clear_inputregioncode();
  static const int kInputRegionCodeFieldNumber = 4;
  inline const ::std::string& inputregioncode() const;
  inline void set_inputregioncode(const ::std::string& value);
  inline void set_inputregioncode(const char* value);
  inline void set_inputregioncode(const char* value, size_t size);
  inline ::std::string* mutable_inputregioncode();
  inline ::std::string* release_inputregioncode();
  
  // optional string inputRegionName = 5;
  inline bool has_inputregionname() const;
  inline void clear_inputregionname();
  static const int kInputRegionNameFieldNumber = 5;
  inline const ::std::string& inputregionname() const;
  inline void set_inputregionname(const ::std::string& value);
  inline void set_inputregionname(const char* value);
  inline void set_inputregionname(const char* value, size_t size);
  inline ::std::string* mutable_inputregionname();
  inline ::std::string* release_inputregionname();
  
  // optional string custName = 6;
  inline bool has_custname() const;
  inline void clear_custname();
  static const int kCustNameFieldNumber = 6;
  inline const ::std::string& custname() const;
  inline void set_custname(const ::std::string& value);
  inline void set_custname(const char* value);
  inline void set_custname(const char* value, size_t size);
  inline ::std::string* mutable_custname();
  inline ::std::string* release_custname();
  
  // optional string strCreditPhone = 7;
  inline bool has_strcreditphone() const;
  inline void clear_strcreditphone();
  static const int kStrCreditPhoneFieldNumber = 7;
  inline const ::std::string& strcreditphone() const;
  inline void set_strcreditphone(const ::std::string& value);
  inline void set_strcreditphone(const char* value);
  inline void set_strcreditphone(const char* value, size_t size);
  inline ::std::string* mutable_strcreditphone();
  inline ::std::string* release_strcreditphone();
  
  // optional int32 creditId = 8;
  inline bool has_creditid() const;
  inline void clear_creditid();
  static const int kCreditIdFieldNumber = 8;
  inline ::google::protobuf::int32 creditid() const;
  inline void set_creditid(::google::protobuf::int32 value);
  
  // optional string creditName = 9;
  inline bool has_creditname() const;
  inline void clear_creditname();
  static const int kCreditNameFieldNumber = 9;
  inline const ::std::string& creditname() const;
  inline void set_creditname(const ::std::string& value);
  inline void set_creditname(const char* value);
  inline void set_creditname(const char* value, size_t size);
  inline ::std::string* mutable_creditname();
  inline ::std::string* release_creditname();
  
  // optional string creditCode = 10;
  inline bool has_creditcode() const;
  inline void clear_creditcode();
  static const int kCreditCodeFieldNumber = 10;
  inline const ::std::string& creditcode() const;
  inline void set_creditcode(const ::std::string& value);
  inline void set_creditcode(const char* value);
  inline void set_creditcode(const char* value, size_t size);
  inline ::std::string* mutable_creditcode();
  inline ::std::string* release_creditcode();
  
  // optional int32 productTypeId = 11;
  inline bool has_producttypeid() const;
  inline void clear_producttypeid();
  static const int kProductTypeIdFieldNumber = 11;
  inline ::google::protobuf::int32 producttypeid() const;
  inline void set_producttypeid(::google::protobuf::int32 value);
  
  // optional string productTypeName = 12;
  inline bool has_producttypename() const;
  inline void clear_producttypename();
  static const int kProductTypeNameFieldNumber = 12;
  inline const ::std::string& producttypename() const;
  inline void set_producttypename(const ::std::string& value);
  inline void set_producttypename(const char* value);
  inline void set_producttypename(const char* value, size_t size);
  inline ::std::string* mutable_producttypename();
  inline ::std::string* release_producttypename();
  
  // optional int32 productId = 13;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 13;
  inline ::google::protobuf::int32 productid() const;
  inline void set_productid(::google::protobuf::int32 value);
  
  // optional string productCode = 14;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 14;
  inline const ::std::string& productcode() const;
  inline void set_productcode(const ::std::string& value);
  inline void set_productcode(const char* value);
  inline void set_productcode(const char* value, size_t size);
  inline ::std::string* mutable_productcode();
  inline ::std::string* release_productcode();
  
  // optional string productName = 15;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 15;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string strBuyMoney = 16;
  inline bool has_strbuymoney() const;
  inline void clear_strbuymoney();
  static const int kStrBuyMoneyFieldNumber = 16;
  inline const ::std::string& strbuymoney() const;
  inline void set_strbuymoney(const ::std::string& value);
  inline void set_strbuymoney(const char* value);
  inline void set_strbuymoney(const char* value, size_t size);
  inline ::std::string* mutable_strbuymoney();
  inline ::std::string* release_strbuymoney();
  
  // optional string strGrade = 17;
  inline bool has_strgrade() const;
  inline void clear_strgrade();
  static const int kStrGradeFieldNumber = 17;
  inline const ::std::string& strgrade() const;
  inline void set_strgrade(const ::std::string& value);
  inline void set_strgrade(const char* value);
  inline void set_strgrade(const char* value, size_t size);
  inline ::std::string* mutable_strgrade();
  inline ::std::string* release_strgrade();
  
  // optional int32 videoNum = 18;
  inline bool has_videonum() const;
  inline void clear_videonum();
  static const int kVideoNumFieldNumber = 18;
  inline ::google::protobuf::int32 videonum() const;
  inline void set_videonum(::google::protobuf::int32 value);
  
  // optional string businessTime = 19;
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 19;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // optional int32 lockClient = 20;
  inline bool has_lockclient() const;
  inline void clear_lockclient();
  static const int kLockClientFieldNumber = 20;
  inline ::google::protobuf::int32 lockclient() const;
  inline void set_lockclient(::google::protobuf::int32 value);
  
  // optional string strlockClient = 21;
  inline bool has_strlockclient() const;
  inline void clear_strlockclient();
  static const int kStrlockClientFieldNumber = 21;
  inline const ::std::string& strlockclient() const;
  inline void set_strlockclient(const ::std::string& value);
  inline void set_strlockclient(const char* value);
  inline void set_strlockclient(const char* value, size_t size);
  inline ::std::string* mutable_strlockclient();
  inline ::std::string* release_strlockclient();
  
  // optional int32 recordStatus = 22;
  inline bool has_recordstatus() const;
  inline void clear_recordstatus();
  static const int kRecordStatusFieldNumber = 22;
  inline ::google::protobuf::int32 recordstatus() const;
  inline void set_recordstatus(::google::protobuf::int32 value);
  
  // optional string strRecordStatus = 23;
  inline bool has_strrecordstatus() const;
  inline void clear_strrecordstatus();
  static const int kStrRecordStatusFieldNumber = 23;
  inline const ::std::string& strrecordstatus() const;
  inline void set_strrecordstatus(const ::std::string& value);
  inline void set_strrecordstatus(const char* value);
  inline void set_strrecordstatus(const char* value, size_t size);
  inline ::std::string* mutable_strrecordstatus();
  inline ::std::string* release_strrecordstatus();
  
  // optional string pictureStrart = 24;
  inline bool has_picturestrart() const;
  inline void clear_picturestrart();
  static const int kPictureStrartFieldNumber = 24;
  inline const ::std::string& picturestrart() const;
  inline void set_picturestrart(const ::std::string& value);
  inline void set_picturestrart(const char* value);
  inline void set_picturestrart(const char* value, size_t size);
  inline ::std::string* mutable_picturestrart();
  inline ::std::string* release_picturestrart();
  
  // optional string pictureEnd = 25;
  inline bool has_pictureend() const;
  inline void clear_pictureend();
  static const int kPictureEndFieldNumber = 25;
  inline const ::std::string& pictureend() const;
  inline void set_pictureend(const ::std::string& value);
  inline void set_pictureend(const char* value);
  inline void set_pictureend(const char* value, size_t size);
  inline ::std::string* mutable_pictureend();
  inline ::std::string* release_pictureend();
  
  // repeated .cms_8120.RecordsDetailInfo recordsDetailInfo = 26;
  inline int recordsdetailinfo_size() const;
  inline void clear_recordsdetailinfo();
  static const int kRecordsDetailInfoFieldNumber = 26;
  inline const ::cms_8120::RecordsDetailInfo& recordsdetailinfo(int index) const;
  inline ::cms_8120::RecordsDetailInfo* mutable_recordsdetailinfo(int index);
  inline ::cms_8120::RecordsDetailInfo* add_recordsdetailinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsDetailInfo >&
      recordsdetailinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsDetailInfo >*
      mutable_recordsdetailinfo();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RecordsInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_inputregionid();
  inline void clear_has_inputregionid();
  inline void set_has_inputregioncode();
  inline void clear_has_inputregioncode();
  inline void set_has_inputregionname();
  inline void clear_has_inputregionname();
  inline void set_has_custname();
  inline void clear_has_custname();
  inline void set_has_strcreditphone();
  inline void clear_has_strcreditphone();
  inline void set_has_creditid();
  inline void clear_has_creditid();
  inline void set_has_creditname();
  inline void clear_has_creditname();
  inline void set_has_creditcode();
  inline void clear_has_creditcode();
  inline void set_has_producttypeid();
  inline void clear_has_producttypeid();
  inline void set_has_producttypename();
  inline void clear_has_producttypename();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_strbuymoney();
  inline void clear_has_strbuymoney();
  inline void set_has_strgrade();
  inline void clear_has_strgrade();
  inline void set_has_videonum();
  inline void clear_has_videonum();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  inline void set_has_lockclient();
  inline void clear_has_lockclient();
  inline void set_has_strlockclient();
  inline void clear_has_strlockclient();
  inline void set_has_recordstatus();
  inline void clear_has_recordstatus();
  inline void set_has_strrecordstatus();
  inline void clear_has_strrecordstatus();
  inline void set_has_picturestrart();
  inline void clear_has_picturestrart();
  inline void set_has_pictureend();
  inline void clear_has_pictureend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nproid_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 inputregionid_;
  ::std::string* inputregioncode_;
  ::std::string* inputregionname_;
  ::std::string* custname_;
  ::std::string* strcreditphone_;
  ::std::string* creditname_;
  ::google::protobuf::int32 creditid_;
  ::google::protobuf::int32 producttypeid_;
  ::std::string* creditcode_;
  ::std::string* producttypename_;
  ::std::string* productcode_;
  ::std::string* productname_;
  ::google::protobuf::int32 productid_;
  ::google::protobuf::int32 videonum_;
  ::std::string* strbuymoney_;
  ::std::string* strgrade_;
  ::std::string* businesstime_;
  ::std::string* strlockclient_;
  ::google::protobuf::int32 lockclient_;
  ::google::protobuf::int32 recordstatus_;
  ::std::string* strrecordstatus_;
  ::std::string* picturestrart_;
  ::std::string* pictureend_;
  ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsDetailInfo > recordsdetailinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static RecordsInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqRecordsInfo : public ::google::protobuf::Message {
 public:
  ReqRecordsInfo();
  virtual ~ReqRecordsInfo();
  
  ReqRecordsInfo(const ReqRecordsInfo& from);
  
  inline ReqRecordsInfo& operator=(const ReqRecordsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqRecordsInfo& default_instance();
  
  void Swap(ReqRecordsInfo* other);
  
  // implements Message ----------------------------------------------
  
  ReqRecordsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqRecordsInfo& from);
  void MergeFrom(const ReqRecordsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 recordTab = 2;
  inline bool has_recordtab() const;
  inline void clear_recordtab();
  static const int kRecordTabFieldNumber = 2;
  inline ::google::protobuf::int32 recordtab() const;
  inline void set_recordtab(::google::protobuf::int32 value);
  
  // optional string startDate = 3;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartDateFieldNumber = 3;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  
  // optional string endDate = 4;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEndDateFieldNumber = 4;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  
  // optional int32 pageNo = 5;
  inline bool has_pageno() const;
  inline void clear_pageno();
  static const int kPageNoFieldNumber = 5;
  inline ::google::protobuf::int32 pageno() const;
  inline void set_pageno(::google::protobuf::int32 value);
  
  // optional int32 pageSize = 6;
  inline bool has_pagesize() const;
  inline void clear_pagesize();
  static const int kPageSizeFieldNumber = 6;
  inline ::google::protobuf::int32 pagesize() const;
  inline void set_pagesize(::google::protobuf::int32 value);
  
  // optional int32 inputUser = 7;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 7;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // optional string productName = 8;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 8;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string custName = 9;
  inline bool has_custname() const;
  inline void clear_custname();
  static const int kCustNameFieldNumber = 9;
  inline const ::std::string& custname() const;
  inline void set_custname(const ::std::string& value);
  inline void set_custname(const char* value);
  inline void set_custname(const char* value, size_t size);
  inline ::std::string* mutable_custname();
  inline ::std::string* release_custname();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqRecordsInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_recordtab();
  inline void clear_has_recordtab();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_pageno();
  inline void clear_has_pageno();
  inline void set_has_pagesize();
  inline void clear_has_pagesize();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_custname();
  inline void clear_has_custname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 recordtab_;
  ::std::string* startdate_;
  ::std::string* enddate_;
  ::google::protobuf::int32 pageno_;
  ::google::protobuf::int32 pagesize_;
  ::std::string* productname_;
  ::std::string* custname_;
  ::google::protobuf::int32 inputuser_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static ReqRecordsInfo* default_instance_;
};
// -------------------------------------------------------------------

class RspCsClientRecordsInfo : public ::google::protobuf::Message {
 public:
  RspCsClientRecordsInfo();
  virtual ~RspCsClientRecordsInfo();
  
  RspCsClientRecordsInfo(const RspCsClientRecordsInfo& from);
  
  inline RspCsClientRecordsInfo& operator=(const RspCsClientRecordsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RspCsClientRecordsInfo& default_instance();
  
  void Swap(RspCsClientRecordsInfo* other);
  
  // implements Message ----------------------------------------------
  
  RspCsClientRecordsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspCsClientRecordsInfo& from);
  void MergeFrom(const RspCsClientRecordsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string result_info = 3;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 3;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const char* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  
  // repeated .cms_8120.RecordsInfo recordsInfo = 4;
  inline int recordsinfo_size() const;
  inline void clear_recordsinfo();
  static const int kRecordsInfoFieldNumber = 4;
  inline const ::cms_8120::RecordsInfo& recordsinfo(int index) const;
  inline ::cms_8120::RecordsInfo* mutable_recordsinfo(int index);
  inline ::cms_8120::RecordsInfo* add_recordsinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsInfo >&
      recordsinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsInfo >*
      mutable_recordsinfo();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RspCsClientRecordsInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_info();
  inline void clear_has_result_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 result_;
  ::std::string* result_info_;
  ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsInfo > recordsinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static RspCsClientRecordsInfo* default_instance_;
};
// -------------------------------------------------------------------

class ErrRecordsInfo : public ::google::protobuf::Message {
 public:
  ErrRecordsInfo();
  virtual ~ErrRecordsInfo();
  
  ErrRecordsInfo(const ErrRecordsInfo& from);
  
  inline ErrRecordsInfo& operator=(const ErrRecordsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrRecordsInfo& default_instance();
  
  void Swap(ErrRecordsInfo* other);
  
  // implements Message ----------------------------------------------
  
  ErrRecordsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrRecordsInfo& from);
  void MergeFrom(const ErrRecordsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string fileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional string nProId = 3;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNProIdFieldNumber = 3;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional string custName = 4;
  inline bool has_custname() const;
  inline void clear_custname();
  static const int kCustNameFieldNumber = 4;
  inline const ::std::string& custname() const;
  inline void set_custname(const ::std::string& value);
  inline void set_custname(const char* value);
  inline void set_custname(const char* value, size_t size);
  inline ::std::string* mutable_custname();
  inline ::std::string* release_custname();
  
  // optional string businessTime = 5;
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 5;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // optional int32 recordStatus = 6;
  inline bool has_recordstatus() const;
  inline void clear_recordstatus();
  static const int kRecordStatusFieldNumber = 6;
  inline ::google::protobuf::int32 recordstatus() const;
  inline void set_recordstatus(::google::protobuf::int32 value);
  
  // optional string strRecordStatus = 7;
  inline bool has_strrecordstatus() const;
  inline void clear_strrecordstatus();
  static const int kStrRecordStatusFieldNumber = 7;
  inline const ::std::string& strrecordstatus() const;
  inline void set_strrecordstatus(const ::std::string& value);
  inline void set_strrecordstatus(const char* value);
  inline void set_strrecordstatus(const char* value, size_t size);
  inline ::std::string* mutable_strrecordstatus();
  inline ::std::string* release_strrecordstatus();
  
  // optional int32 productTypeId = 8;
  inline bool has_producttypeid() const;
  inline void clear_producttypeid();
  static const int kProductTypeIdFieldNumber = 8;
  inline ::google::protobuf::int32 producttypeid() const;
  inline void set_producttypeid(::google::protobuf::int32 value);
  
  // optional string productTypeName = 9;
  inline bool has_producttypename() const;
  inline void clear_producttypename();
  static const int kProductTypeNameFieldNumber = 9;
  inline const ::std::string& producttypename() const;
  inline void set_producttypename(const ::std::string& value);
  inline void set_producttypename(const char* value);
  inline void set_producttypename(const char* value, size_t size);
  inline ::std::string* mutable_producttypename();
  inline ::std::string* release_producttypename();
  
  // optional int32 productId = 10;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 10;
  inline ::google::protobuf::int32 productid() const;
  inline void set_productid(::google::protobuf::int32 value);
  
  // optional string productCode = 11;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 11;
  inline const ::std::string& productcode() const;
  inline void set_productcode(const ::std::string& value);
  inline void set_productcode(const char* value);
  inline void set_productcode(const char* value, size_t size);
  inline ::std::string* mutable_productcode();
  inline ::std::string* release_productcode();
  
  // optional string productName = 12;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 12;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string strBuyMoney = 13;
  inline bool has_strbuymoney() const;
  inline void clear_strbuymoney();
  static const int kStrBuyMoneyFieldNumber = 13;
  inline const ::std::string& strbuymoney() const;
  inline void set_strbuymoney(const ::std::string& value);
  inline void set_strbuymoney(const char* value);
  inline void set_strbuymoney(const char* value, size_t size);
  inline ::std::string* mutable_strbuymoney();
  inline ::std::string* release_strbuymoney();
  
  // optional int32 recordCheck = 14;
  inline bool has_recordcheck() const;
  inline void clear_recordcheck();
  static const int kRecordCheckFieldNumber = 14;
  inline ::google::protobuf::int32 recordcheck() const;
  inline void set_recordcheck(::google::protobuf::int32 value);
  
  // optional string strRecordCheck = 15;
  inline bool has_strrecordcheck() const;
  inline void clear_strrecordcheck();
  static const int kStrRecordCheckFieldNumber = 15;
  inline const ::std::string& strrecordcheck() const;
  inline void set_strrecordcheck(const ::std::string& value);
  inline void set_strrecordcheck(const char* value);
  inline void set_strrecordcheck(const char* value, size_t size);
  inline ::std::string* mutable_strrecordcheck();
  inline ::std::string* release_strrecordcheck();
  
  // optional string strUrl = 16;
  inline bool has_strurl() const;
  inline void clear_strurl();
  static const int kStrUrlFieldNumber = 16;
  inline const ::std::string& strurl() const;
  inline void set_strurl(const ::std::string& value);
  inline void set_strurl(const char* value);
  inline void set_strurl(const char* value, size_t size);
  inline ::std::string* mutable_strurl();
  inline ::std::string* release_strurl();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ErrRecordsInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_custname();
  inline void clear_has_custname();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  inline void set_has_recordstatus();
  inline void clear_has_recordstatus();
  inline void set_has_strrecordstatus();
  inline void clear_has_strrecordstatus();
  inline void set_has_producttypeid();
  inline void clear_has_producttypeid();
  inline void set_has_producttypename();
  inline void clear_has_producttypename();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_strbuymoney();
  inline void clear_has_strbuymoney();
  inline void set_has_recordcheck();
  inline void clear_has_recordcheck();
  inline void set_has_strrecordcheck();
  inline void clear_has_strrecordcheck();
  inline void set_has_strurl();
  inline void clear_has_strurl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  ::std::string* nproid_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 recordstatus_;
  ::std::string* custname_;
  ::std::string* businesstime_;
  ::std::string* strrecordstatus_;
  ::std::string* producttypename_;
  ::google::protobuf::int32 producttypeid_;
  ::google::protobuf::int32 productid_;
  ::std::string* productcode_;
  ::std::string* productname_;
  ::std::string* strbuymoney_;
  ::std::string* strrecordcheck_;
  ::std::string* strurl_;
  ::google::protobuf::int32 recordcheck_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static ErrRecordsInfo* default_instance_;
};
// -------------------------------------------------------------------

class RspErrRecordsInfo : public ::google::protobuf::Message {
 public:
  RspErrRecordsInfo();
  virtual ~RspErrRecordsInfo();
  
  RspErrRecordsInfo(const RspErrRecordsInfo& from);
  
  inline RspErrRecordsInfo& operator=(const RspErrRecordsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RspErrRecordsInfo& default_instance();
  
  void Swap(RspErrRecordsInfo* other);
  
  // implements Message ----------------------------------------------
  
  RspErrRecordsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspErrRecordsInfo& from);
  void MergeFrom(const RspErrRecordsInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string result_info = 3;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 3;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const char* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  
  // repeated .cms_8120.ErrRecordsInfo errRecordsInfo = 4;
  inline int errrecordsinfo_size() const;
  inline void clear_errrecordsinfo();
  static const int kErrRecordsInfoFieldNumber = 4;
  inline const ::cms_8120::ErrRecordsInfo& errrecordsinfo(int index) const;
  inline ::cms_8120::ErrRecordsInfo* mutable_errrecordsinfo(int index);
  inline ::cms_8120::ErrRecordsInfo* add_errrecordsinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::ErrRecordsInfo >&
      errrecordsinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::ErrRecordsInfo >*
      mutable_errrecordsinfo();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RspErrRecordsInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_info();
  inline void clear_has_result_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 result_;
  ::std::string* result_info_;
  ::google::protobuf::RepeatedPtrField< ::cms_8120::ErrRecordsInfo > errrecordsinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static RspErrRecordsInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqErrorRecord : public ::google::protobuf::Message {
 public:
  ReqErrorRecord();
  virtual ~ReqErrorRecord();
  
  ReqErrorRecord(const ReqErrorRecord& from);
  
  inline ReqErrorRecord& operator=(const ReqErrorRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqErrorRecord& default_instance();
  
  void Swap(ReqErrorRecord* other);
  
  // implements Message ----------------------------------------------
  
  ReqErrorRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqErrorRecord& from);
  void MergeFrom(const ReqErrorRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // repeated int32 id = 2;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();
  
  // optional int32 inputUser = 3;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 3;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqErrorRecord)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 inputuser_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static ReqErrorRecord* default_instance_;
};
// -------------------------------------------------------------------

class ReqPrintRecord : public ::google::protobuf::Message {
 public:
  ReqPrintRecord();
  virtual ~ReqPrintRecord();
  
  ReqPrintRecord(const ReqPrintRecord& from);
  
  inline ReqPrintRecord& operator=(const ReqPrintRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPrintRecord& default_instance();
  
  void Swap(ReqPrintRecord* other);
  
  // implements Message ----------------------------------------------
  
  ReqPrintRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqPrintRecord& from);
  void MergeFrom(const ReqPrintRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 inputUser = 3;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 3;
  inline ::google::protobuf::int32 inputuser() const;
  inline void set_inputuser(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqPrintRecord)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 inputuser_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static ReqPrintRecord* default_instance_;
};
// -------------------------------------------------------------------

class RspPrintRecord : public ::google::protobuf::Message {
 public:
  RspPrintRecord();
  virtual ~RspPrintRecord();
  
  RspPrintRecord(const RspPrintRecord& from);
  
  inline RspPrintRecord& operator=(const RspPrintRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RspPrintRecord& default_instance();
  
  void Swap(RspPrintRecord* other);
  
  // implements Message ----------------------------------------------
  
  RspPrintRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspPrintRecord& from);
  void MergeFrom(const RspPrintRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string result_info = 3;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 3;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const char* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  
  // optional int32 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string creditName = 6;
  inline bool has_creditname() const;
  inline void clear_creditname();
  static const int kCreditNameFieldNumber = 6;
  inline const ::std::string& creditname() const;
  inline void set_creditname(const ::std::string& value);
  inline void set_creditname(const char* value);
  inline void set_creditname(const char* value, size_t size);
  inline ::std::string* mutable_creditname();
  inline ::std::string* release_creditname();
  
  // optional string creditCode = 7;
  inline bool has_creditcode() const;
  inline void clear_creditcode();
  static const int kCreditCodeFieldNumber = 7;
  inline const ::std::string& creditcode() const;
  inline void set_creditcode(const ::std::string& value);
  inline void set_creditcode(const char* value);
  inline void set_creditcode(const char* value, size_t size);
  inline ::std::string* mutable_creditcode();
  inline ::std::string* release_creditcode();
  
  // optional string nproId = 8;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNproIdFieldNumber = 8;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional string strGrade = 9;
  inline bool has_strgrade() const;
  inline void clear_strgrade();
  static const int kStrGradeFieldNumber = 9;
  inline const ::std::string& strgrade() const;
  inline void set_strgrade(const ::std::string& value);
  inline void set_strgrade(const char* value);
  inline void set_strgrade(const char* value, size_t size);
  inline ::std::string* mutable_strgrade();
  inline ::std::string* release_strgrade();
  
  // optional string productType = 10;
  inline bool has_producttype() const;
  inline void clear_producttype();
  static const int kProductTypeFieldNumber = 10;
  inline const ::std::string& producttype() const;
  inline void set_producttype(const ::std::string& value);
  inline void set_producttype(const char* value);
  inline void set_producttype(const char* value, size_t size);
  inline ::std::string* mutable_producttype();
  inline ::std::string* release_producttype();
  
  // optional string productName = 11;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 11;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string proName = 12;
  inline bool has_proname() const;
  inline void clear_proname();
  static const int kProNameFieldNumber = 12;
  inline const ::std::string& proname() const;
  inline void set_proname(const ::std::string& value);
  inline void set_proname(const char* value);
  inline void set_proname(const char* value, size_t size);
  inline ::std::string* mutable_proname();
  inline ::std::string* release_proname();
  
  // optional string proUserNo = 13;
  inline bool has_prouserno() const;
  inline void clear_prouserno();
  static const int kProUserNoFieldNumber = 13;
  inline const ::std::string& prouserno() const;
  inline void set_prouserno(const ::std::string& value);
  inline void set_prouserno(const char* value);
  inline void set_prouserno(const char* value, size_t size);
  inline ::std::string* mutable_prouserno();
  inline ::std::string* release_prouserno();
  
  // optional string pictureStrart = 14;
  inline bool has_picturestrart() const;
  inline void clear_picturestrart();
  static const int kPictureStrartFieldNumber = 14;
  inline const ::std::string& picturestrart() const;
  inline void set_picturestrart(const ::std::string& value);
  inline void set_picturestrart(const char* value);
  inline void set_picturestrart(const char* value, size_t size);
  inline ::std::string* mutable_picturestrart();
  inline ::std::string* release_picturestrart();
  
  // optional string pictureEnd = 15;
  inline bool has_pictureend() const;
  inline void clear_pictureend();
  static const int kPictureEndFieldNumber = 15;
  inline const ::std::string& pictureend() const;
  inline void set_pictureend(const ::std::string& value);
  inline void set_pictureend(const char* value);
  inline void set_pictureend(const char* value, size_t size);
  inline ::std::string* mutable_pictureend();
  inline ::std::string* release_pictureend();
  
  // optional string businessTime = 16;
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 16;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RspPrintRecord)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_info();
  inline void clear_has_result_info();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_creditname();
  inline void clear_has_creditname();
  inline void set_has_creditcode();
  inline void clear_has_creditcode();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_strgrade();
  inline void clear_has_strgrade();
  inline void set_has_producttype();
  inline void clear_has_producttype();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_proname();
  inline void clear_has_proname();
  inline void set_has_prouserno();
  inline void clear_has_prouserno();
  inline void set_has_picturestrart();
  inline void clear_has_picturestrart();
  inline void set_has_pictureend();
  inline void clear_has_pictureend();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 result_;
  ::std::string* result_info_;
  ::std::string* name_;
  ::std::string* creditname_;
  ::std::string* creditcode_;
  ::std::string* nproid_;
  ::std::string* strgrade_;
  ::std::string* producttype_;
  ::std::string* productname_;
  ::std::string* proname_;
  ::std::string* prouserno_;
  ::std::string* picturestrart_;
  ::std::string* pictureend_;
  ::std::string* businesstime_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_AssignDesc_csclient_2fCsClientRecord_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fCsClientRecord_2eproto();
  
  void InitAsDefaultInstance();
  static RspPrintRecord* default_instance_;
};
// ===================================================================


// ===================================================================

// CSClientInput

// optional int32 id = 1;
inline bool CSClientInput::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSClientInput::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSClientInput::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSClientInput::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CSClientInput::id() const {
  return id_;
}
inline void CSClientInput::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 inputRegionId = 2;
inline bool CSClientInput::has_inputregionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSClientInput::set_has_inputregionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSClientInput::clear_has_inputregionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSClientInput::clear_inputregionid() {
  inputregionid_ = 0;
  clear_has_inputregionid();
}
inline ::google::protobuf::int32 CSClientInput::inputregionid() const {
  return inputregionid_;
}
inline void CSClientInput::set_inputregionid(::google::protobuf::int32 value) {
  set_has_inputregionid();
  inputregionid_ = value;
}

// optional int32 inputUser = 3;
inline bool CSClientInput::has_inputuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSClientInput::set_has_inputuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSClientInput::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSClientInput::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 CSClientInput::inputuser() const {
  return inputuser_;
}
inline void CSClientInput::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// optional string nproId = 4;
inline bool CSClientInput::has_nproid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSClientInput::set_has_nproid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSClientInput::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSClientInput::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& CSClientInput::nproid() const {
  return *nproid_;
}
inline void CSClientInput::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void CSClientInput::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void CSClientInput::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* CSClientInput::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string inputTime = 5;
inline bool CSClientInput::has_inputtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSClientInput::set_has_inputtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSClientInput::clear_has_inputtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSClientInput::clear_inputtime() {
  if (inputtime_ != &::google::protobuf::internal::kEmptyString) {
    inputtime_->clear();
  }
  clear_has_inputtime();
}
inline const ::std::string& CSClientInput::inputtime() const {
  return *inputtime_;
}
inline void CSClientInput::set_inputtime(const ::std::string& value) {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  inputtime_->assign(value);
}
inline void CSClientInput::set_inputtime(const char* value) {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  inputtime_->assign(value);
}
inline void CSClientInput::set_inputtime(const char* value, size_t size) {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  inputtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_inputtime() {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  return inputtime_;
}
inline ::std::string* CSClientInput::release_inputtime() {
  clear_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputtime_;
    inputtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string businessTime = 6;
inline bool CSClientInput::has_businesstime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSClientInput::set_has_businesstime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSClientInput::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSClientInput::clear_businesstime() {
  if (businesstime_ != &::google::protobuf::internal::kEmptyString) {
    businesstime_->clear();
  }
  clear_has_businesstime();
}
inline const ::std::string& CSClientInput::businesstime() const {
  return *businesstime_;
}
inline void CSClientInput::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void CSClientInput::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void CSClientInput::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  return businesstime_;
}
inline ::std::string* CSClientInput::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 7;
inline bool CSClientInput::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSClientInput::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSClientInput::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSClientInput::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSClientInput::name() const {
  return *name_;
}
inline void CSClientInput::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSClientInput::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSClientInput::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSClientInput::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditCode = 8;
inline bool CSClientInput::has_creditcode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSClientInput::set_has_creditcode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSClientInput::clear_has_creditcode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSClientInput::clear_creditcode() {
  if (creditcode_ != &::google::protobuf::internal::kEmptyString) {
    creditcode_->clear();
  }
  clear_has_creditcode();
}
inline const ::std::string& CSClientInput::creditcode() const {
  return *creditcode_;
}
inline void CSClientInput::set_creditcode(const ::std::string& value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void CSClientInput::set_creditcode(const char* value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void CSClientInput::set_creditcode(const char* value, size_t size) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_creditcode() {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  return creditcode_;
}
inline ::std::string* CSClientInput::release_creditcode() {
  clear_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditcode_;
    creditcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 creditId = 9;
inline bool CSClientInput::has_creditid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSClientInput::set_has_creditid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSClientInput::clear_has_creditid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSClientInput::clear_creditid() {
  creditid_ = 0;
  clear_has_creditid();
}
inline ::google::protobuf::int32 CSClientInput::creditid() const {
  return creditid_;
}
inline void CSClientInput::set_creditid(::google::protobuf::int32 value) {
  set_has_creditid();
  creditid_ = value;
}

// optional int32 productId = 10;
inline bool CSClientInput::has_productid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSClientInput::set_has_productid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSClientInput::clear_has_productid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSClientInput::clear_productid() {
  productid_ = 0;
  clear_has_productid();
}
inline ::google::protobuf::int32 CSClientInput::productid() const {
  return productid_;
}
inline void CSClientInput::set_productid(::google::protobuf::int32 value) {
  set_has_productid();
  productid_ = value;
}

// optional string strBankNo = 11;
inline bool CSClientInput::has_strbankno() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSClientInput::set_has_strbankno() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSClientInput::clear_has_strbankno() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSClientInput::clear_strbankno() {
  if (strbankno_ != &::google::protobuf::internal::kEmptyString) {
    strbankno_->clear();
  }
  clear_has_strbankno();
}
inline const ::std::string& CSClientInput::strbankno() const {
  return *strbankno_;
}
inline void CSClientInput::set_strbankno(const ::std::string& value) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(value);
}
inline void CSClientInput::set_strbankno(const char* value) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(value);
}
inline void CSClientInput::set_strbankno(const char* value, size_t size) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_strbankno() {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  return strbankno_;
}
inline ::std::string* CSClientInput::release_strbankno() {
  clear_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbankno_;
    strbankno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBuyMoney = 12;
inline bool CSClientInput::has_strbuymoney() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSClientInput::set_has_strbuymoney() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSClientInput::clear_has_strbuymoney() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSClientInput::clear_strbuymoney() {
  if (strbuymoney_ != &::google::protobuf::internal::kEmptyString) {
    strbuymoney_->clear();
  }
  clear_has_strbuymoney();
}
inline const ::std::string& CSClientInput::strbuymoney() const {
  return *strbuymoney_;
}
inline void CSClientInput::set_strbuymoney(const ::std::string& value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void CSClientInput::set_strbuymoney(const char* value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void CSClientInput::set_strbuymoney(const char* value, size_t size) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_strbuymoney() {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  return strbuymoney_;
}
inline ::std::string* CSClientInput::release_strbuymoney() {
  clear_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbuymoney_;
    strbuymoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCreditPhone = 13;
inline bool CSClientInput::has_strcreditphone() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSClientInput::set_has_strcreditphone() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSClientInput::clear_has_strcreditphone() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSClientInput::clear_strcreditphone() {
  if (strcreditphone_ != &::google::protobuf::internal::kEmptyString) {
    strcreditphone_->clear();
  }
  clear_has_strcreditphone();
}
inline const ::std::string& CSClientInput::strcreditphone() const {
  return *strcreditphone_;
}
inline void CSClientInput::set_strcreditphone(const ::std::string& value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void CSClientInput::set_strcreditphone(const char* value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void CSClientInput::set_strcreditphone(const char* value, size_t size) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSClientInput::mutable_strcreditphone() {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  return strcreditphone_;
}
inline ::std::string* CSClientInput::release_strcreditphone() {
  clear_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcreditphone_;
    strcreditphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CSRecords

// optional int32 id = 1;
inline bool CSRecords::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRecords::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRecords::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRecords::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CSRecords::id() const {
  return id_;
}
inline void CSRecords::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string strRecordName = 2;
inline bool CSRecords::has_strrecordname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRecords::set_has_strrecordname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRecords::clear_has_strrecordname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRecords::clear_strrecordname() {
  if (strrecordname_ != &::google::protobuf::internal::kEmptyString) {
    strrecordname_->clear();
  }
  clear_has_strrecordname();
}
inline const ::std::string& CSRecords::strrecordname() const {
  return *strrecordname_;
}
inline void CSRecords::set_strrecordname(const ::std::string& value) {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  strrecordname_->assign(value);
}
inline void CSRecords::set_strrecordname(const char* value) {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  strrecordname_->assign(value);
}
inline void CSRecords::set_strrecordname(const char* value, size_t size) {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  strrecordname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_strrecordname() {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  return strrecordname_;
}
inline ::std::string* CSRecords::release_strrecordname() {
  clear_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordname_;
    strrecordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 inputUser = 3;
inline bool CSRecords::has_inputuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRecords::set_has_inputuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRecords::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRecords::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 CSRecords::inputuser() const {
  return inputuser_;
}
inline void CSRecords::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// optional int32 inputRegionId = 4;
inline bool CSRecords::has_inputregionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSRecords::set_has_inputregionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSRecords::clear_has_inputregionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSRecords::clear_inputregionid() {
  inputregionid_ = 0;
  clear_has_inputregionid();
}
inline ::google::protobuf::int32 CSRecords::inputregionid() const {
  return inputregionid_;
}
inline void CSRecords::set_inputregionid(::google::protobuf::int32 value) {
  set_has_inputregionid();
  inputregionid_ = value;
}

// optional int32 nrecordFileType = 5;
inline bool CSRecords::has_nrecordfiletype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSRecords::set_has_nrecordfiletype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSRecords::clear_has_nrecordfiletype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSRecords::clear_nrecordfiletype() {
  nrecordfiletype_ = 0;
  clear_has_nrecordfiletype();
}
inline ::google::protobuf::int32 CSRecords::nrecordfiletype() const {
  return nrecordfiletype_;
}
inline void CSRecords::set_nrecordfiletype(::google::protobuf::int32 value) {
  set_has_nrecordfiletype();
  nrecordfiletype_ = value;
}

// optional string startTime = 6;
inline bool CSRecords::has_starttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSRecords::set_has_starttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSRecords::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSRecords::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& CSRecords::starttime() const {
  return *starttime_;
}
inline void CSRecords::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void CSRecords::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void CSRecords::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* CSRecords::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string endTime = 7;
inline bool CSRecords::has_endtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSRecords::set_has_endtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSRecords::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSRecords::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& CSRecords::endtime() const {
  return *endtime_;
}
inline void CSRecords::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CSRecords::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CSRecords::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* CSRecords::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strUrl = 8;
inline bool CSRecords::has_strurl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSRecords::set_has_strurl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSRecords::clear_has_strurl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSRecords::clear_strurl() {
  if (strurl_ != &::google::protobuf::internal::kEmptyString) {
    strurl_->clear();
  }
  clear_has_strurl();
}
inline const ::std::string& CSRecords::strurl() const {
  return *strurl_;
}
inline void CSRecords::set_strurl(const ::std::string& value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void CSRecords::set_strurl(const char* value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void CSRecords::set_strurl(const char* value, size_t size) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_strurl() {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  return strurl_;
}
inline ::std::string* CSRecords::release_strurl() {
  clear_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strurl_;
    strurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nupLoadPercent = 9;
inline bool CSRecords::has_nuploadpercent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSRecords::set_has_nuploadpercent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSRecords::clear_has_nuploadpercent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSRecords::clear_nuploadpercent() {
  nuploadpercent_ = 0;
  clear_has_nuploadpercent();
}
inline ::google::protobuf::int32 CSRecords::nuploadpercent() const {
  return nuploadpercent_;
}
inline void CSRecords::set_nuploadpercent(::google::protobuf::int32 value) {
  set_has_nuploadpercent();
  nuploadpercent_ = value;
}

// optional int32 nfileSize = 10;
inline bool CSRecords::has_nfilesize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSRecords::set_has_nfilesize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSRecords::clear_has_nfilesize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSRecords::clear_nfilesize() {
  nfilesize_ = 0;
  clear_has_nfilesize();
}
inline ::google::protobuf::int32 CSRecords::nfilesize() const {
  return nfilesize_;
}
inline void CSRecords::set_nfilesize(::google::protobuf::int32 value) {
  set_has_nfilesize();
  nfilesize_ = value;
}

// optional string screenshotSrc = 11;
inline bool CSRecords::has_screenshotsrc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSRecords::set_has_screenshotsrc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSRecords::clear_has_screenshotsrc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSRecords::clear_screenshotsrc() {
  if (screenshotsrc_ != &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_->clear();
  }
  clear_has_screenshotsrc();
}
inline const ::std::string& CSRecords::screenshotsrc() const {
  return *screenshotsrc_;
}
inline void CSRecords::set_screenshotsrc(const ::std::string& value) {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  screenshotsrc_->assign(value);
}
inline void CSRecords::set_screenshotsrc(const char* value) {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  screenshotsrc_->assign(value);
}
inline void CSRecords::set_screenshotsrc(const char* value, size_t size) {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  screenshotsrc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_screenshotsrc() {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  return screenshotsrc_;
}
inline ::std::string* CSRecords::release_screenshotsrc() {
  clear_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screenshotsrc_;
    screenshotsrc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCloudIp = 12;
inline bool CSRecords::has_strcloudip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSRecords::set_has_strcloudip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSRecords::clear_has_strcloudip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSRecords::clear_strcloudip() {
  if (strcloudip_ != &::google::protobuf::internal::kEmptyString) {
    strcloudip_->clear();
  }
  clear_has_strcloudip();
}
inline const ::std::string& CSRecords::strcloudip() const {
  return *strcloudip_;
}
inline void CSRecords::set_strcloudip(const ::std::string& value) {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  strcloudip_->assign(value);
}
inline void CSRecords::set_strcloudip(const char* value) {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  strcloudip_->assign(value);
}
inline void CSRecords::set_strcloudip(const char* value, size_t size) {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  strcloudip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_strcloudip() {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  return strcloudip_;
}
inline ::std::string* CSRecords::release_strcloudip() {
  clear_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcloudip_;
    strcloudip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 strCloudPort = 13;
inline bool CSRecords::has_strcloudport() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSRecords::set_has_strcloudport() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSRecords::clear_has_strcloudport() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSRecords::clear_strcloudport() {
  strcloudport_ = 0;
  clear_has_strcloudport();
}
inline ::google::protobuf::int32 CSRecords::strcloudport() const {
  return strcloudport_;
}
inline void CSRecords::set_strcloudport(::google::protobuf::int32 value) {
  set_has_strcloudport();
  strcloudport_ = value;
}

// optional string strAccessKey = 14;
inline bool CSRecords::has_straccesskey() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSRecords::set_has_straccesskey() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSRecords::clear_has_straccesskey() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSRecords::clear_straccesskey() {
  if (straccesskey_ != &::google::protobuf::internal::kEmptyString) {
    straccesskey_->clear();
  }
  clear_has_straccesskey();
}
inline const ::std::string& CSRecords::straccesskey() const {
  return *straccesskey_;
}
inline void CSRecords::set_straccesskey(const ::std::string& value) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(value);
}
inline void CSRecords::set_straccesskey(const char* value) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(value);
}
inline void CSRecords::set_straccesskey(const char* value, size_t size) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_straccesskey() {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  return straccesskey_;
}
inline ::std::string* CSRecords::release_straccesskey() {
  clear_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccesskey_;
    straccesskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strSecretKey = 15;
inline bool CSRecords::has_strsecretkey() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSRecords::set_has_strsecretkey() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSRecords::clear_has_strsecretkey() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSRecords::clear_strsecretkey() {
  if (strsecretkey_ != &::google::protobuf::internal::kEmptyString) {
    strsecretkey_->clear();
  }
  clear_has_strsecretkey();
}
inline const ::std::string& CSRecords::strsecretkey() const {
  return *strsecretkey_;
}
inline void CSRecords::set_strsecretkey(const ::std::string& value) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(value);
}
inline void CSRecords::set_strsecretkey(const char* value) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(value);
}
inline void CSRecords::set_strsecretkey(const char* value, size_t size) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_strsecretkey() {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  return strsecretkey_;
}
inline ::std::string* CSRecords::release_strsecretkey() {
  clear_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsecretkey_;
    strsecretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBucket = 16;
inline bool CSRecords::has_strbucket() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSRecords::set_has_strbucket() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSRecords::clear_has_strbucket() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSRecords::clear_strbucket() {
  if (strbucket_ != &::google::protobuf::internal::kEmptyString) {
    strbucket_->clear();
  }
  clear_has_strbucket();
}
inline const ::std::string& CSRecords::strbucket() const {
  return *strbucket_;
}
inline void CSRecords::set_strbucket(const ::std::string& value) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(value);
}
inline void CSRecords::set_strbucket(const char* value) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(value);
}
inline void CSRecords::set_strbucket(const char* value, size_t size) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRecords::mutable_strbucket() {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  return strbucket_;
}
inline ::std::string* CSRecords::release_strbucket() {
  clear_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbucket_;
    strbucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqCsClientRecord

// optional int32 cmd = 1;
inline bool ReqCsClientRecord::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCsClientRecord::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCsClientRecord::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCsClientRecord::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqCsClientRecord::cmd() const {
  return cmd_;
}
inline void ReqCsClientRecord::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .cms_8120.CSClientInput clientInput = 2;
inline bool ReqCsClientRecord::has_clientinput() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCsClientRecord::set_has_clientinput() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCsClientRecord::clear_has_clientinput() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCsClientRecord::clear_clientinput() {
  if (clientinput_ != NULL) clientinput_->::cms_8120::CSClientInput::Clear();
  clear_has_clientinput();
}
inline const ::cms_8120::CSClientInput& ReqCsClientRecord::clientinput() const {
  return clientinput_ != NULL ? *clientinput_ : *default_instance_->clientinput_;
}
inline ::cms_8120::CSClientInput* ReqCsClientRecord::mutable_clientinput() {
  set_has_clientinput();
  if (clientinput_ == NULL) clientinput_ = new ::cms_8120::CSClientInput;
  return clientinput_;
}
inline ::cms_8120::CSClientInput* ReqCsClientRecord::release_clientinput() {
  clear_has_clientinput();
  ::cms_8120::CSClientInput* temp = clientinput_;
  clientinput_ = NULL;
  return temp;
}

// repeated .cms_8120.CSRecords records = 3;
inline int ReqCsClientRecord::records_size() const {
  return records_.size();
}
inline void ReqCsClientRecord::clear_records() {
  records_.Clear();
}
inline const ::cms_8120::CSRecords& ReqCsClientRecord::records(int index) const {
  return records_.Get(index);
}
inline ::cms_8120::CSRecords* ReqCsClientRecord::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::cms_8120::CSRecords* ReqCsClientRecord::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::CSRecords >&
ReqCsClientRecord::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::CSRecords >*
ReqCsClientRecord::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// RspCsClientRecord

// optional int32 cmd = 1;
inline bool RspCsClientRecord::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspCsClientRecord::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspCsClientRecord::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspCsClientRecord::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 RspCsClientRecord::cmd() const {
  return cmd_;
}
inline void RspCsClientRecord::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 result = 2;
inline bool RspCsClientRecord::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspCsClientRecord::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspCsClientRecord::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspCsClientRecord::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RspCsClientRecord::result() const {
  return result_;
}
inline void RspCsClientRecord::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string result_info = 3;
inline bool RspCsClientRecord::has_result_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspCsClientRecord::set_has_result_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspCsClientRecord::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspCsClientRecord::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::kEmptyString) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& RspCsClientRecord::result_info() const {
  return *result_info_;
}
inline void RspCsClientRecord::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspCsClientRecord::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspCsClientRecord::set_result_info(const char* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspCsClientRecord::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  return result_info_;
}
inline ::std::string* RspCsClientRecord::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RecordsDetailInfo

// optional string fileName = 1;
inline bool RecordsDetailInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordsDetailInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordsDetailInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordsDetailInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& RecordsDetailInfo::filename() const {
  return *filename_;
}
inline void RecordsDetailInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void RecordsDetailInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void RecordsDetailInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsDetailInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* RecordsDetailInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 recordStatus = 2;
inline bool RecordsDetailInfo::has_recordstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordsDetailInfo::set_has_recordstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordsDetailInfo::clear_has_recordstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordsDetailInfo::clear_recordstatus() {
  recordstatus_ = 0;
  clear_has_recordstatus();
}
inline ::google::protobuf::int32 RecordsDetailInfo::recordstatus() const {
  return recordstatus_;
}
inline void RecordsDetailInfo::set_recordstatus(::google::protobuf::int32 value) {
  set_has_recordstatus();
  recordstatus_ = value;
}

// optional string strRecordStatus = 3;
inline bool RecordsDetailInfo::has_strrecordstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordsDetailInfo::set_has_strrecordstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordsDetailInfo::clear_has_strrecordstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordsDetailInfo::clear_strrecordstatus() {
  if (strrecordstatus_ != &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_->clear();
  }
  clear_has_strrecordstatus();
}
inline const ::std::string& RecordsDetailInfo::strrecordstatus() const {
  return *strrecordstatus_;
}
inline void RecordsDetailInfo::set_strrecordstatus(const ::std::string& value) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(value);
}
inline void RecordsDetailInfo::set_strrecordstatus(const char* value) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(value);
}
inline void RecordsDetailInfo::set_strrecordstatus(const char* value, size_t size) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsDetailInfo::mutable_strrecordstatus() {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  return strrecordstatus_;
}
inline ::std::string* RecordsDetailInfo::release_strrecordstatus() {
  clear_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordstatus_;
    strrecordstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string errorMsg = 4;
inline bool RecordsDetailInfo::has_errormsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordsDetailInfo::set_has_errormsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordsDetailInfo::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordsDetailInfo::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& RecordsDetailInfo::errormsg() const {
  return *errormsg_;
}
inline void RecordsDetailInfo::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void RecordsDetailInfo::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void RecordsDetailInfo::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsDetailInfo::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* RecordsDetailInfo::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strUrl = 5;
inline bool RecordsDetailInfo::has_strurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordsDetailInfo::set_has_strurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecordsDetailInfo::clear_has_strurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecordsDetailInfo::clear_strurl() {
  if (strurl_ != &::google::protobuf::internal::kEmptyString) {
    strurl_->clear();
  }
  clear_has_strurl();
}
inline const ::std::string& RecordsDetailInfo::strurl() const {
  return *strurl_;
}
inline void RecordsDetailInfo::set_strurl(const ::std::string& value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void RecordsDetailInfo::set_strurl(const char* value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void RecordsDetailInfo::set_strurl(const char* value, size_t size) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsDetailInfo::mutable_strurl() {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  return strurl_;
}
inline ::std::string* RecordsDetailInfo::release_strurl() {
  clear_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strurl_;
    strurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 videoId = 6;
inline bool RecordsDetailInfo::has_videoid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecordsDetailInfo::set_has_videoid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecordsDetailInfo::clear_has_videoid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecordsDetailInfo::clear_videoid() {
  videoid_ = 0;
  clear_has_videoid();
}
inline ::google::protobuf::int32 RecordsDetailInfo::videoid() const {
  return videoid_;
}
inline void RecordsDetailInfo::set_videoid(::google::protobuf::int32 value) {
  set_has_videoid();
  videoid_ = value;
}

// -------------------------------------------------------------------

// RecordsInfo

// optional int32 id = 1;
inline bool RecordsInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordsInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordsInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordsInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RecordsInfo::id() const {
  return id_;
}
inline void RecordsInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string nProId = 2;
inline bool RecordsInfo::has_nproid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordsInfo::set_has_nproid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordsInfo::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordsInfo::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& RecordsInfo::nproid() const {
  return *nproid_;
}
inline void RecordsInfo::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void RecordsInfo::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void RecordsInfo::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* RecordsInfo::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 inputRegionId = 3;
inline bool RecordsInfo::has_inputregionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordsInfo::set_has_inputregionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordsInfo::clear_has_inputregionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordsInfo::clear_inputregionid() {
  inputregionid_ = 0;
  clear_has_inputregionid();
}
inline ::google::protobuf::int32 RecordsInfo::inputregionid() const {
  return inputregionid_;
}
inline void RecordsInfo::set_inputregionid(::google::protobuf::int32 value) {
  set_has_inputregionid();
  inputregionid_ = value;
}

// optional string inputRegionCode = 4;
inline bool RecordsInfo::has_inputregioncode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordsInfo::set_has_inputregioncode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordsInfo::clear_has_inputregioncode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordsInfo::clear_inputregioncode() {
  if (inputregioncode_ != &::google::protobuf::internal::kEmptyString) {
    inputregioncode_->clear();
  }
  clear_has_inputregioncode();
}
inline const ::std::string& RecordsInfo::inputregioncode() const {
  return *inputregioncode_;
}
inline void RecordsInfo::set_inputregioncode(const ::std::string& value) {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  inputregioncode_->assign(value);
}
inline void RecordsInfo::set_inputregioncode(const char* value) {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  inputregioncode_->assign(value);
}
inline void RecordsInfo::set_inputregioncode(const char* value, size_t size) {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  inputregioncode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_inputregioncode() {
  set_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    inputregioncode_ = new ::std::string;
  }
  return inputregioncode_;
}
inline ::std::string* RecordsInfo::release_inputregioncode() {
  clear_has_inputregioncode();
  if (inputregioncode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputregioncode_;
    inputregioncode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string inputRegionName = 5;
inline bool RecordsInfo::has_inputregionname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordsInfo::set_has_inputregionname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecordsInfo::clear_has_inputregionname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecordsInfo::clear_inputregionname() {
  if (inputregionname_ != &::google::protobuf::internal::kEmptyString) {
    inputregionname_->clear();
  }
  clear_has_inputregionname();
}
inline const ::std::string& RecordsInfo::inputregionname() const {
  return *inputregionname_;
}
inline void RecordsInfo::set_inputregionname(const ::std::string& value) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(value);
}
inline void RecordsInfo::set_inputregionname(const char* value) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(value);
}
inline void RecordsInfo::set_inputregionname(const char* value, size_t size) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_inputregionname() {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  return inputregionname_;
}
inline ::std::string* RecordsInfo::release_inputregionname() {
  clear_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputregionname_;
    inputregionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string custName = 6;
inline bool RecordsInfo::has_custname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecordsInfo::set_has_custname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecordsInfo::clear_has_custname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecordsInfo::clear_custname() {
  if (custname_ != &::google::protobuf::internal::kEmptyString) {
    custname_->clear();
  }
  clear_has_custname();
}
inline const ::std::string& RecordsInfo::custname() const {
  return *custname_;
}
inline void RecordsInfo::set_custname(const ::std::string& value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void RecordsInfo::set_custname(const char* value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void RecordsInfo::set_custname(const char* value, size_t size) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_custname() {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  return custname_;
}
inline ::std::string* RecordsInfo::release_custname() {
  clear_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custname_;
    custname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCreditPhone = 7;
inline bool RecordsInfo::has_strcreditphone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecordsInfo::set_has_strcreditphone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RecordsInfo::clear_has_strcreditphone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RecordsInfo::clear_strcreditphone() {
  if (strcreditphone_ != &::google::protobuf::internal::kEmptyString) {
    strcreditphone_->clear();
  }
  clear_has_strcreditphone();
}
inline const ::std::string& RecordsInfo::strcreditphone() const {
  return *strcreditphone_;
}
inline void RecordsInfo::set_strcreditphone(const ::std::string& value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void RecordsInfo::set_strcreditphone(const char* value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void RecordsInfo::set_strcreditphone(const char* value, size_t size) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_strcreditphone() {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  return strcreditphone_;
}
inline ::std::string* RecordsInfo::release_strcreditphone() {
  clear_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcreditphone_;
    strcreditphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 creditId = 8;
inline bool RecordsInfo::has_creditid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecordsInfo::set_has_creditid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RecordsInfo::clear_has_creditid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RecordsInfo::clear_creditid() {
  creditid_ = 0;
  clear_has_creditid();
}
inline ::google::protobuf::int32 RecordsInfo::creditid() const {
  return creditid_;
}
inline void RecordsInfo::set_creditid(::google::protobuf::int32 value) {
  set_has_creditid();
  creditid_ = value;
}

// optional string creditName = 9;
inline bool RecordsInfo::has_creditname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RecordsInfo::set_has_creditname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RecordsInfo::clear_has_creditname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RecordsInfo::clear_creditname() {
  if (creditname_ != &::google::protobuf::internal::kEmptyString) {
    creditname_->clear();
  }
  clear_has_creditname();
}
inline const ::std::string& RecordsInfo::creditname() const {
  return *creditname_;
}
inline void RecordsInfo::set_creditname(const ::std::string& value) {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  creditname_->assign(value);
}
inline void RecordsInfo::set_creditname(const char* value) {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  creditname_->assign(value);
}
inline void RecordsInfo::set_creditname(const char* value, size_t size) {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  creditname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_creditname() {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  return creditname_;
}
inline ::std::string* RecordsInfo::release_creditname() {
  clear_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditname_;
    creditname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditCode = 10;
inline bool RecordsInfo::has_creditcode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RecordsInfo::set_has_creditcode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RecordsInfo::clear_has_creditcode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RecordsInfo::clear_creditcode() {
  if (creditcode_ != &::google::protobuf::internal::kEmptyString) {
    creditcode_->clear();
  }
  clear_has_creditcode();
}
inline const ::std::string& RecordsInfo::creditcode() const {
  return *creditcode_;
}
inline void RecordsInfo::set_creditcode(const ::std::string& value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void RecordsInfo::set_creditcode(const char* value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void RecordsInfo::set_creditcode(const char* value, size_t size) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_creditcode() {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  return creditcode_;
}
inline ::std::string* RecordsInfo::release_creditcode() {
  clear_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditcode_;
    creditcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productTypeId = 11;
inline bool RecordsInfo::has_producttypeid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RecordsInfo::set_has_producttypeid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RecordsInfo::clear_has_producttypeid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RecordsInfo::clear_producttypeid() {
  producttypeid_ = 0;
  clear_has_producttypeid();
}
inline ::google::protobuf::int32 RecordsInfo::producttypeid() const {
  return producttypeid_;
}
inline void RecordsInfo::set_producttypeid(::google::protobuf::int32 value) {
  set_has_producttypeid();
  producttypeid_ = value;
}

// optional string productTypeName = 12;
inline bool RecordsInfo::has_producttypename() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RecordsInfo::set_has_producttypename() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RecordsInfo::clear_has_producttypename() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RecordsInfo::clear_producttypename() {
  if (producttypename_ != &::google::protobuf::internal::kEmptyString) {
    producttypename_->clear();
  }
  clear_has_producttypename();
}
inline const ::std::string& RecordsInfo::producttypename() const {
  return *producttypename_;
}
inline void RecordsInfo::set_producttypename(const ::std::string& value) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(value);
}
inline void RecordsInfo::set_producttypename(const char* value) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(value);
}
inline void RecordsInfo::set_producttypename(const char* value, size_t size) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_producttypename() {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  return producttypename_;
}
inline ::std::string* RecordsInfo::release_producttypename() {
  clear_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = producttypename_;
    producttypename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productId = 13;
inline bool RecordsInfo::has_productid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RecordsInfo::set_has_productid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RecordsInfo::clear_has_productid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RecordsInfo::clear_productid() {
  productid_ = 0;
  clear_has_productid();
}
inline ::google::protobuf::int32 RecordsInfo::productid() const {
  return productid_;
}
inline void RecordsInfo::set_productid(::google::protobuf::int32 value) {
  set_has_productid();
  productid_ = value;
}

// optional string productCode = 14;
inline bool RecordsInfo::has_productcode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RecordsInfo::set_has_productcode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RecordsInfo::clear_has_productcode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RecordsInfo::clear_productcode() {
  if (productcode_ != &::google::protobuf::internal::kEmptyString) {
    productcode_->clear();
  }
  clear_has_productcode();
}
inline const ::std::string& RecordsInfo::productcode() const {
  return *productcode_;
}
inline void RecordsInfo::set_productcode(const ::std::string& value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void RecordsInfo::set_productcode(const char* value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void RecordsInfo::set_productcode(const char* value, size_t size) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_productcode() {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  return productcode_;
}
inline ::std::string* RecordsInfo::release_productcode() {
  clear_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productcode_;
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productName = 15;
inline bool RecordsInfo::has_productname() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RecordsInfo::set_has_productname() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RecordsInfo::clear_has_productname() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RecordsInfo::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& RecordsInfo::productname() const {
  return *productname_;
}
inline void RecordsInfo::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void RecordsInfo::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void RecordsInfo::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* RecordsInfo::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBuyMoney = 16;
inline bool RecordsInfo::has_strbuymoney() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RecordsInfo::set_has_strbuymoney() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RecordsInfo::clear_has_strbuymoney() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RecordsInfo::clear_strbuymoney() {
  if (strbuymoney_ != &::google::protobuf::internal::kEmptyString) {
    strbuymoney_->clear();
  }
  clear_has_strbuymoney();
}
inline const ::std::string& RecordsInfo::strbuymoney() const {
  return *strbuymoney_;
}
inline void RecordsInfo::set_strbuymoney(const ::std::string& value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void RecordsInfo::set_strbuymoney(const char* value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void RecordsInfo::set_strbuymoney(const char* value, size_t size) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_strbuymoney() {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  return strbuymoney_;
}
inline ::std::string* RecordsInfo::release_strbuymoney() {
  clear_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbuymoney_;
    strbuymoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strGrade = 17;
inline bool RecordsInfo::has_strgrade() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RecordsInfo::set_has_strgrade() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RecordsInfo::clear_has_strgrade() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RecordsInfo::clear_strgrade() {
  if (strgrade_ != &::google::protobuf::internal::kEmptyString) {
    strgrade_->clear();
  }
  clear_has_strgrade();
}
inline const ::std::string& RecordsInfo::strgrade() const {
  return *strgrade_;
}
inline void RecordsInfo::set_strgrade(const ::std::string& value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void RecordsInfo::set_strgrade(const char* value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void RecordsInfo::set_strgrade(const char* value, size_t size) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_strgrade() {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  return strgrade_;
}
inline ::std::string* RecordsInfo::release_strgrade() {
  clear_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgrade_;
    strgrade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 videoNum = 18;
inline bool RecordsInfo::has_videonum() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RecordsInfo::set_has_videonum() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RecordsInfo::clear_has_videonum() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RecordsInfo::clear_videonum() {
  videonum_ = 0;
  clear_has_videonum();
}
inline ::google::protobuf::int32 RecordsInfo::videonum() const {
  return videonum_;
}
inline void RecordsInfo::set_videonum(::google::protobuf::int32 value) {
  set_has_videonum();
  videonum_ = value;
}

// optional string businessTime = 19;
inline bool RecordsInfo::has_businesstime() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RecordsInfo::set_has_businesstime() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RecordsInfo::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RecordsInfo::clear_businesstime() {
  if (businesstime_ != &::google::protobuf::internal::kEmptyString) {
    businesstime_->clear();
  }
  clear_has_businesstime();
}
inline const ::std::string& RecordsInfo::businesstime() const {
  return *businesstime_;
}
inline void RecordsInfo::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void RecordsInfo::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void RecordsInfo::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  return businesstime_;
}
inline ::std::string* RecordsInfo::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 lockClient = 20;
inline bool RecordsInfo::has_lockclient() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RecordsInfo::set_has_lockclient() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RecordsInfo::clear_has_lockclient() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RecordsInfo::clear_lockclient() {
  lockclient_ = 0;
  clear_has_lockclient();
}
inline ::google::protobuf::int32 RecordsInfo::lockclient() const {
  return lockclient_;
}
inline void RecordsInfo::set_lockclient(::google::protobuf::int32 value) {
  set_has_lockclient();
  lockclient_ = value;
}

// optional string strlockClient = 21;
inline bool RecordsInfo::has_strlockclient() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RecordsInfo::set_has_strlockclient() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RecordsInfo::clear_has_strlockclient() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RecordsInfo::clear_strlockclient() {
  if (strlockclient_ != &::google::protobuf::internal::kEmptyString) {
    strlockclient_->clear();
  }
  clear_has_strlockclient();
}
inline const ::std::string& RecordsInfo::strlockclient() const {
  return *strlockclient_;
}
inline void RecordsInfo::set_strlockclient(const ::std::string& value) {
  set_has_strlockclient();
  if (strlockclient_ == &::google::protobuf::internal::kEmptyString) {
    strlockclient_ = new ::std::string;
  }
  strlockclient_->assign(value);
}
inline void RecordsInfo::set_strlockclient(const char* value) {
  set_has_strlockclient();
  if (strlockclient_ == &::google::protobuf::internal::kEmptyString) {
    strlockclient_ = new ::std::string;
  }
  strlockclient_->assign(value);
}
inline void RecordsInfo::set_strlockclient(const char* value, size_t size) {
  set_has_strlockclient();
  if (strlockclient_ == &::google::protobuf::internal::kEmptyString) {
    strlockclient_ = new ::std::string;
  }
  strlockclient_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_strlockclient() {
  set_has_strlockclient();
  if (strlockclient_ == &::google::protobuf::internal::kEmptyString) {
    strlockclient_ = new ::std::string;
  }
  return strlockclient_;
}
inline ::std::string* RecordsInfo::release_strlockclient() {
  clear_has_strlockclient();
  if (strlockclient_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlockclient_;
    strlockclient_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 recordStatus = 22;
inline bool RecordsInfo::has_recordstatus() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RecordsInfo::set_has_recordstatus() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RecordsInfo::clear_has_recordstatus() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RecordsInfo::clear_recordstatus() {
  recordstatus_ = 0;
  clear_has_recordstatus();
}
inline ::google::protobuf::int32 RecordsInfo::recordstatus() const {
  return recordstatus_;
}
inline void RecordsInfo::set_recordstatus(::google::protobuf::int32 value) {
  set_has_recordstatus();
  recordstatus_ = value;
}

// optional string strRecordStatus = 23;
inline bool RecordsInfo::has_strrecordstatus() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RecordsInfo::set_has_strrecordstatus() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RecordsInfo::clear_has_strrecordstatus() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RecordsInfo::clear_strrecordstatus() {
  if (strrecordstatus_ != &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_->clear();
  }
  clear_has_strrecordstatus();
}
inline const ::std::string& RecordsInfo::strrecordstatus() const {
  return *strrecordstatus_;
}
inline void RecordsInfo::set_strrecordstatus(const ::std::string& value) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(value);
}
inline void RecordsInfo::set_strrecordstatus(const char* value) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(value);
}
inline void RecordsInfo::set_strrecordstatus(const char* value, size_t size) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_strrecordstatus() {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  return strrecordstatus_;
}
inline ::std::string* RecordsInfo::release_strrecordstatus() {
  clear_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordstatus_;
    strrecordstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pictureStrart = 24;
inline bool RecordsInfo::has_picturestrart() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RecordsInfo::set_has_picturestrart() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RecordsInfo::clear_has_picturestrart() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RecordsInfo::clear_picturestrart() {
  if (picturestrart_ != &::google::protobuf::internal::kEmptyString) {
    picturestrart_->clear();
  }
  clear_has_picturestrart();
}
inline const ::std::string& RecordsInfo::picturestrart() const {
  return *picturestrart_;
}
inline void RecordsInfo::set_picturestrart(const ::std::string& value) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(value);
}
inline void RecordsInfo::set_picturestrart(const char* value) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(value);
}
inline void RecordsInfo::set_picturestrart(const char* value, size_t size) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_picturestrart() {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  return picturestrart_;
}
inline ::std::string* RecordsInfo::release_picturestrart() {
  clear_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picturestrart_;
    picturestrart_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pictureEnd = 25;
inline bool RecordsInfo::has_pictureend() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RecordsInfo::set_has_pictureend() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RecordsInfo::clear_has_pictureend() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RecordsInfo::clear_pictureend() {
  if (pictureend_ != &::google::protobuf::internal::kEmptyString) {
    pictureend_->clear();
  }
  clear_has_pictureend();
}
inline const ::std::string& RecordsInfo::pictureend() const {
  return *pictureend_;
}
inline void RecordsInfo::set_pictureend(const ::std::string& value) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(value);
}
inline void RecordsInfo::set_pictureend(const char* value) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(value);
}
inline void RecordsInfo::set_pictureend(const char* value, size_t size) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordsInfo::mutable_pictureend() {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  return pictureend_;
}
inline ::std::string* RecordsInfo::release_pictureend() {
  clear_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pictureend_;
    pictureend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cms_8120.RecordsDetailInfo recordsDetailInfo = 26;
inline int RecordsInfo::recordsdetailinfo_size() const {
  return recordsdetailinfo_.size();
}
inline void RecordsInfo::clear_recordsdetailinfo() {
  recordsdetailinfo_.Clear();
}
inline const ::cms_8120::RecordsDetailInfo& RecordsInfo::recordsdetailinfo(int index) const {
  return recordsdetailinfo_.Get(index);
}
inline ::cms_8120::RecordsDetailInfo* RecordsInfo::mutable_recordsdetailinfo(int index) {
  return recordsdetailinfo_.Mutable(index);
}
inline ::cms_8120::RecordsDetailInfo* RecordsInfo::add_recordsdetailinfo() {
  return recordsdetailinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsDetailInfo >&
RecordsInfo::recordsdetailinfo() const {
  return recordsdetailinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsDetailInfo >*
RecordsInfo::mutable_recordsdetailinfo() {
  return &recordsdetailinfo_;
}

// -------------------------------------------------------------------

// ReqRecordsInfo

// optional int32 cmd = 1;
inline bool ReqRecordsInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRecordsInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRecordsInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRecordsInfo::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqRecordsInfo::cmd() const {
  return cmd_;
}
inline void ReqRecordsInfo::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 recordTab = 2;
inline bool ReqRecordsInfo::has_recordtab() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqRecordsInfo::set_has_recordtab() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqRecordsInfo::clear_has_recordtab() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqRecordsInfo::clear_recordtab() {
  recordtab_ = 0;
  clear_has_recordtab();
}
inline ::google::protobuf::int32 ReqRecordsInfo::recordtab() const {
  return recordtab_;
}
inline void ReqRecordsInfo::set_recordtab(::google::protobuf::int32 value) {
  set_has_recordtab();
  recordtab_ = value;
}

// optional string startDate = 3;
inline bool ReqRecordsInfo::has_startdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqRecordsInfo::set_has_startdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqRecordsInfo::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqRecordsInfo::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& ReqRecordsInfo::startdate() const {
  return *startdate_;
}
inline void ReqRecordsInfo::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void ReqRecordsInfo::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void ReqRecordsInfo::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecordsInfo::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  return startdate_;
}
inline ::std::string* ReqRecordsInfo::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string endDate = 4;
inline bool ReqRecordsInfo::has_enddate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqRecordsInfo::set_has_enddate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqRecordsInfo::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqRecordsInfo::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& ReqRecordsInfo::enddate() const {
  return *enddate_;
}
inline void ReqRecordsInfo::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void ReqRecordsInfo::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void ReqRecordsInfo::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecordsInfo::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  return enddate_;
}
inline ::std::string* ReqRecordsInfo::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 pageNo = 5;
inline bool ReqRecordsInfo::has_pageno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqRecordsInfo::set_has_pageno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqRecordsInfo::clear_has_pageno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqRecordsInfo::clear_pageno() {
  pageno_ = 0;
  clear_has_pageno();
}
inline ::google::protobuf::int32 ReqRecordsInfo::pageno() const {
  return pageno_;
}
inline void ReqRecordsInfo::set_pageno(::google::protobuf::int32 value) {
  set_has_pageno();
  pageno_ = value;
}

// optional int32 pageSize = 6;
inline bool ReqRecordsInfo::has_pagesize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqRecordsInfo::set_has_pagesize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqRecordsInfo::clear_has_pagesize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqRecordsInfo::clear_pagesize() {
  pagesize_ = 0;
  clear_has_pagesize();
}
inline ::google::protobuf::int32 ReqRecordsInfo::pagesize() const {
  return pagesize_;
}
inline void ReqRecordsInfo::set_pagesize(::google::protobuf::int32 value) {
  set_has_pagesize();
  pagesize_ = value;
}

// optional int32 inputUser = 7;
inline bool ReqRecordsInfo::has_inputuser() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqRecordsInfo::set_has_inputuser() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqRecordsInfo::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqRecordsInfo::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 ReqRecordsInfo::inputuser() const {
  return inputuser_;
}
inline void ReqRecordsInfo::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// optional string productName = 8;
inline bool ReqRecordsInfo::has_productname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqRecordsInfo::set_has_productname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqRecordsInfo::clear_has_productname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqRecordsInfo::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& ReqRecordsInfo::productname() const {
  return *productname_;
}
inline void ReqRecordsInfo::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void ReqRecordsInfo::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void ReqRecordsInfo::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecordsInfo::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* ReqRecordsInfo::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string custName = 9;
inline bool ReqRecordsInfo::has_custname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqRecordsInfo::set_has_custname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqRecordsInfo::clear_has_custname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqRecordsInfo::clear_custname() {
  if (custname_ != &::google::protobuf::internal::kEmptyString) {
    custname_->clear();
  }
  clear_has_custname();
}
inline const ::std::string& ReqRecordsInfo::custname() const {
  return *custname_;
}
inline void ReqRecordsInfo::set_custname(const ::std::string& value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void ReqRecordsInfo::set_custname(const char* value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void ReqRecordsInfo::set_custname(const char* value, size_t size) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecordsInfo::mutable_custname() {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  return custname_;
}
inline ::std::string* ReqRecordsInfo::release_custname() {
  clear_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custname_;
    custname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RspCsClientRecordsInfo

// optional int32 cmd = 1;
inline bool RspCsClientRecordsInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspCsClientRecordsInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspCsClientRecordsInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspCsClientRecordsInfo::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 RspCsClientRecordsInfo::cmd() const {
  return cmd_;
}
inline void RspCsClientRecordsInfo::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 result = 2;
inline bool RspCsClientRecordsInfo::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspCsClientRecordsInfo::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspCsClientRecordsInfo::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspCsClientRecordsInfo::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RspCsClientRecordsInfo::result() const {
  return result_;
}
inline void RspCsClientRecordsInfo::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string result_info = 3;
inline bool RspCsClientRecordsInfo::has_result_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspCsClientRecordsInfo::set_has_result_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspCsClientRecordsInfo::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspCsClientRecordsInfo::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::kEmptyString) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& RspCsClientRecordsInfo::result_info() const {
  return *result_info_;
}
inline void RspCsClientRecordsInfo::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspCsClientRecordsInfo::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspCsClientRecordsInfo::set_result_info(const char* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspCsClientRecordsInfo::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  return result_info_;
}
inline ::std::string* RspCsClientRecordsInfo::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cms_8120.RecordsInfo recordsInfo = 4;
inline int RspCsClientRecordsInfo::recordsinfo_size() const {
  return recordsinfo_.size();
}
inline void RspCsClientRecordsInfo::clear_recordsinfo() {
  recordsinfo_.Clear();
}
inline const ::cms_8120::RecordsInfo& RspCsClientRecordsInfo::recordsinfo(int index) const {
  return recordsinfo_.Get(index);
}
inline ::cms_8120::RecordsInfo* RspCsClientRecordsInfo::mutable_recordsinfo(int index) {
  return recordsinfo_.Mutable(index);
}
inline ::cms_8120::RecordsInfo* RspCsClientRecordsInfo::add_recordsinfo() {
  return recordsinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsInfo >&
RspCsClientRecordsInfo::recordsinfo() const {
  return recordsinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::RecordsInfo >*
RspCsClientRecordsInfo::mutable_recordsinfo() {
  return &recordsinfo_;
}

// -------------------------------------------------------------------

// ErrRecordsInfo

// optional int32 id = 1;
inline bool ErrRecordsInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrRecordsInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrRecordsInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrRecordsInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ErrRecordsInfo::id() const {
  return id_;
}
inline void ErrRecordsInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string fileName = 2;
inline bool ErrRecordsInfo::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrRecordsInfo::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrRecordsInfo::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrRecordsInfo::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ErrRecordsInfo::filename() const {
  return *filename_;
}
inline void ErrRecordsInfo::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ErrRecordsInfo::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ErrRecordsInfo::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ErrRecordsInfo::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nProId = 3;
inline bool ErrRecordsInfo::has_nproid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ErrRecordsInfo::set_has_nproid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ErrRecordsInfo::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ErrRecordsInfo::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& ErrRecordsInfo::nproid() const {
  return *nproid_;
}
inline void ErrRecordsInfo::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void ErrRecordsInfo::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void ErrRecordsInfo::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* ErrRecordsInfo::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string custName = 4;
inline bool ErrRecordsInfo::has_custname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ErrRecordsInfo::set_has_custname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ErrRecordsInfo::clear_has_custname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ErrRecordsInfo::clear_custname() {
  if (custname_ != &::google::protobuf::internal::kEmptyString) {
    custname_->clear();
  }
  clear_has_custname();
}
inline const ::std::string& ErrRecordsInfo::custname() const {
  return *custname_;
}
inline void ErrRecordsInfo::set_custname(const ::std::string& value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void ErrRecordsInfo::set_custname(const char* value) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(value);
}
inline void ErrRecordsInfo::set_custname(const char* value, size_t size) {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  custname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_custname() {
  set_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    custname_ = new ::std::string;
  }
  return custname_;
}
inline ::std::string* ErrRecordsInfo::release_custname() {
  clear_has_custname();
  if (custname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custname_;
    custname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string businessTime = 5;
inline bool ErrRecordsInfo::has_businesstime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ErrRecordsInfo::set_has_businesstime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ErrRecordsInfo::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ErrRecordsInfo::clear_businesstime() {
  if (businesstime_ != &::google::protobuf::internal::kEmptyString) {
    businesstime_->clear();
  }
  clear_has_businesstime();
}
inline const ::std::string& ErrRecordsInfo::businesstime() const {
  return *businesstime_;
}
inline void ErrRecordsInfo::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void ErrRecordsInfo::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void ErrRecordsInfo::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  return businesstime_;
}
inline ::std::string* ErrRecordsInfo::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 recordStatus = 6;
inline bool ErrRecordsInfo::has_recordstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ErrRecordsInfo::set_has_recordstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ErrRecordsInfo::clear_has_recordstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ErrRecordsInfo::clear_recordstatus() {
  recordstatus_ = 0;
  clear_has_recordstatus();
}
inline ::google::protobuf::int32 ErrRecordsInfo::recordstatus() const {
  return recordstatus_;
}
inline void ErrRecordsInfo::set_recordstatus(::google::protobuf::int32 value) {
  set_has_recordstatus();
  recordstatus_ = value;
}

// optional string strRecordStatus = 7;
inline bool ErrRecordsInfo::has_strrecordstatus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ErrRecordsInfo::set_has_strrecordstatus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ErrRecordsInfo::clear_has_strrecordstatus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ErrRecordsInfo::clear_strrecordstatus() {
  if (strrecordstatus_ != &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_->clear();
  }
  clear_has_strrecordstatus();
}
inline const ::std::string& ErrRecordsInfo::strrecordstatus() const {
  return *strrecordstatus_;
}
inline void ErrRecordsInfo::set_strrecordstatus(const ::std::string& value) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(value);
}
inline void ErrRecordsInfo::set_strrecordstatus(const char* value) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(value);
}
inline void ErrRecordsInfo::set_strrecordstatus(const char* value, size_t size) {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  strrecordstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_strrecordstatus() {
  set_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    strrecordstatus_ = new ::std::string;
  }
  return strrecordstatus_;
}
inline ::std::string* ErrRecordsInfo::release_strrecordstatus() {
  clear_has_strrecordstatus();
  if (strrecordstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordstatus_;
    strrecordstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productTypeId = 8;
inline bool ErrRecordsInfo::has_producttypeid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ErrRecordsInfo::set_has_producttypeid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ErrRecordsInfo::clear_has_producttypeid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ErrRecordsInfo::clear_producttypeid() {
  producttypeid_ = 0;
  clear_has_producttypeid();
}
inline ::google::protobuf::int32 ErrRecordsInfo::producttypeid() const {
  return producttypeid_;
}
inline void ErrRecordsInfo::set_producttypeid(::google::protobuf::int32 value) {
  set_has_producttypeid();
  producttypeid_ = value;
}

// optional string productTypeName = 9;
inline bool ErrRecordsInfo::has_producttypename() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ErrRecordsInfo::set_has_producttypename() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ErrRecordsInfo::clear_has_producttypename() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ErrRecordsInfo::clear_producttypename() {
  if (producttypename_ != &::google::protobuf::internal::kEmptyString) {
    producttypename_->clear();
  }
  clear_has_producttypename();
}
inline const ::std::string& ErrRecordsInfo::producttypename() const {
  return *producttypename_;
}
inline void ErrRecordsInfo::set_producttypename(const ::std::string& value) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(value);
}
inline void ErrRecordsInfo::set_producttypename(const char* value) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(value);
}
inline void ErrRecordsInfo::set_producttypename(const char* value, size_t size) {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  producttypename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_producttypename() {
  set_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    producttypename_ = new ::std::string;
  }
  return producttypename_;
}
inline ::std::string* ErrRecordsInfo::release_producttypename() {
  clear_has_producttypename();
  if (producttypename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = producttypename_;
    producttypename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productId = 10;
inline bool ErrRecordsInfo::has_productid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ErrRecordsInfo::set_has_productid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ErrRecordsInfo::clear_has_productid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ErrRecordsInfo::clear_productid() {
  productid_ = 0;
  clear_has_productid();
}
inline ::google::protobuf::int32 ErrRecordsInfo::productid() const {
  return productid_;
}
inline void ErrRecordsInfo::set_productid(::google::protobuf::int32 value) {
  set_has_productid();
  productid_ = value;
}

// optional string productCode = 11;
inline bool ErrRecordsInfo::has_productcode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ErrRecordsInfo::set_has_productcode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ErrRecordsInfo::clear_has_productcode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ErrRecordsInfo::clear_productcode() {
  if (productcode_ != &::google::protobuf::internal::kEmptyString) {
    productcode_->clear();
  }
  clear_has_productcode();
}
inline const ::std::string& ErrRecordsInfo::productcode() const {
  return *productcode_;
}
inline void ErrRecordsInfo::set_productcode(const ::std::string& value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void ErrRecordsInfo::set_productcode(const char* value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void ErrRecordsInfo::set_productcode(const char* value, size_t size) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_productcode() {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  return productcode_;
}
inline ::std::string* ErrRecordsInfo::release_productcode() {
  clear_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productcode_;
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productName = 12;
inline bool ErrRecordsInfo::has_productname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ErrRecordsInfo::set_has_productname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ErrRecordsInfo::clear_has_productname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ErrRecordsInfo::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& ErrRecordsInfo::productname() const {
  return *productname_;
}
inline void ErrRecordsInfo::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void ErrRecordsInfo::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void ErrRecordsInfo::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* ErrRecordsInfo::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBuyMoney = 13;
inline bool ErrRecordsInfo::has_strbuymoney() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ErrRecordsInfo::set_has_strbuymoney() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ErrRecordsInfo::clear_has_strbuymoney() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ErrRecordsInfo::clear_strbuymoney() {
  if (strbuymoney_ != &::google::protobuf::internal::kEmptyString) {
    strbuymoney_->clear();
  }
  clear_has_strbuymoney();
}
inline const ::std::string& ErrRecordsInfo::strbuymoney() const {
  return *strbuymoney_;
}
inline void ErrRecordsInfo::set_strbuymoney(const ::std::string& value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void ErrRecordsInfo::set_strbuymoney(const char* value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void ErrRecordsInfo::set_strbuymoney(const char* value, size_t size) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_strbuymoney() {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  return strbuymoney_;
}
inline ::std::string* ErrRecordsInfo::release_strbuymoney() {
  clear_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbuymoney_;
    strbuymoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 recordCheck = 14;
inline bool ErrRecordsInfo::has_recordcheck() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ErrRecordsInfo::set_has_recordcheck() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ErrRecordsInfo::clear_has_recordcheck() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ErrRecordsInfo::clear_recordcheck() {
  recordcheck_ = 0;
  clear_has_recordcheck();
}
inline ::google::protobuf::int32 ErrRecordsInfo::recordcheck() const {
  return recordcheck_;
}
inline void ErrRecordsInfo::set_recordcheck(::google::protobuf::int32 value) {
  set_has_recordcheck();
  recordcheck_ = value;
}

// optional string strRecordCheck = 15;
inline bool ErrRecordsInfo::has_strrecordcheck() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ErrRecordsInfo::set_has_strrecordcheck() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ErrRecordsInfo::clear_has_strrecordcheck() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ErrRecordsInfo::clear_strrecordcheck() {
  if (strrecordcheck_ != &::google::protobuf::internal::kEmptyString) {
    strrecordcheck_->clear();
  }
  clear_has_strrecordcheck();
}
inline const ::std::string& ErrRecordsInfo::strrecordcheck() const {
  return *strrecordcheck_;
}
inline void ErrRecordsInfo::set_strrecordcheck(const ::std::string& value) {
  set_has_strrecordcheck();
  if (strrecordcheck_ == &::google::protobuf::internal::kEmptyString) {
    strrecordcheck_ = new ::std::string;
  }
  strrecordcheck_->assign(value);
}
inline void ErrRecordsInfo::set_strrecordcheck(const char* value) {
  set_has_strrecordcheck();
  if (strrecordcheck_ == &::google::protobuf::internal::kEmptyString) {
    strrecordcheck_ = new ::std::string;
  }
  strrecordcheck_->assign(value);
}
inline void ErrRecordsInfo::set_strrecordcheck(const char* value, size_t size) {
  set_has_strrecordcheck();
  if (strrecordcheck_ == &::google::protobuf::internal::kEmptyString) {
    strrecordcheck_ = new ::std::string;
  }
  strrecordcheck_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_strrecordcheck() {
  set_has_strrecordcheck();
  if (strrecordcheck_ == &::google::protobuf::internal::kEmptyString) {
    strrecordcheck_ = new ::std::string;
  }
  return strrecordcheck_;
}
inline ::std::string* ErrRecordsInfo::release_strrecordcheck() {
  clear_has_strrecordcheck();
  if (strrecordcheck_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordcheck_;
    strrecordcheck_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strUrl = 16;
inline bool ErrRecordsInfo::has_strurl() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ErrRecordsInfo::set_has_strurl() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ErrRecordsInfo::clear_has_strurl() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ErrRecordsInfo::clear_strurl() {
  if (strurl_ != &::google::protobuf::internal::kEmptyString) {
    strurl_->clear();
  }
  clear_has_strurl();
}
inline const ::std::string& ErrRecordsInfo::strurl() const {
  return *strurl_;
}
inline void ErrRecordsInfo::set_strurl(const ::std::string& value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void ErrRecordsInfo::set_strurl(const char* value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void ErrRecordsInfo::set_strurl(const char* value, size_t size) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrRecordsInfo::mutable_strurl() {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  return strurl_;
}
inline ::std::string* ErrRecordsInfo::release_strurl() {
  clear_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strurl_;
    strurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RspErrRecordsInfo

// optional int32 cmd = 1;
inline bool RspErrRecordsInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspErrRecordsInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspErrRecordsInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspErrRecordsInfo::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 RspErrRecordsInfo::cmd() const {
  return cmd_;
}
inline void RspErrRecordsInfo::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 result = 2;
inline bool RspErrRecordsInfo::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspErrRecordsInfo::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspErrRecordsInfo::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspErrRecordsInfo::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RspErrRecordsInfo::result() const {
  return result_;
}
inline void RspErrRecordsInfo::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string result_info = 3;
inline bool RspErrRecordsInfo::has_result_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspErrRecordsInfo::set_has_result_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspErrRecordsInfo::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspErrRecordsInfo::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::kEmptyString) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& RspErrRecordsInfo::result_info() const {
  return *result_info_;
}
inline void RspErrRecordsInfo::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspErrRecordsInfo::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspErrRecordsInfo::set_result_info(const char* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspErrRecordsInfo::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  return result_info_;
}
inline ::std::string* RspErrRecordsInfo::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cms_8120.ErrRecordsInfo errRecordsInfo = 4;
inline int RspErrRecordsInfo::errrecordsinfo_size() const {
  return errrecordsinfo_.size();
}
inline void RspErrRecordsInfo::clear_errrecordsinfo() {
  errrecordsinfo_.Clear();
}
inline const ::cms_8120::ErrRecordsInfo& RspErrRecordsInfo::errrecordsinfo(int index) const {
  return errrecordsinfo_.Get(index);
}
inline ::cms_8120::ErrRecordsInfo* RspErrRecordsInfo::mutable_errrecordsinfo(int index) {
  return errrecordsinfo_.Mutable(index);
}
inline ::cms_8120::ErrRecordsInfo* RspErrRecordsInfo::add_errrecordsinfo() {
  return errrecordsinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::ErrRecordsInfo >&
RspErrRecordsInfo::errrecordsinfo() const {
  return errrecordsinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::ErrRecordsInfo >*
RspErrRecordsInfo::mutable_errrecordsinfo() {
  return &errrecordsinfo_;
}

// -------------------------------------------------------------------

// ReqErrorRecord

// optional int32 cmd = 1;
inline bool ReqErrorRecord::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqErrorRecord::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqErrorRecord::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqErrorRecord::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqErrorRecord::cmd() const {
  return cmd_;
}
inline void ReqErrorRecord::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// repeated int32 id = 2;
inline int ReqErrorRecord::id_size() const {
  return id_.size();
}
inline void ReqErrorRecord::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 ReqErrorRecord::id(int index) const {
  return id_.Get(index);
}
inline void ReqErrorRecord::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void ReqErrorRecord::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ReqErrorRecord::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ReqErrorRecord::mutable_id() {
  return &id_;
}

// optional int32 inputUser = 3;
inline bool ReqErrorRecord::has_inputuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqErrorRecord::set_has_inputuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqErrorRecord::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqErrorRecord::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 ReqErrorRecord::inputuser() const {
  return inputuser_;
}
inline void ReqErrorRecord::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// -------------------------------------------------------------------

// ReqPrintRecord

// optional int32 cmd = 1;
inline bool ReqPrintRecord::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPrintRecord::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPrintRecord::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPrintRecord::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqPrintRecord::cmd() const {
  return cmd_;
}
inline void ReqPrintRecord::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 id = 2;
inline bool ReqPrintRecord::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqPrintRecord::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqPrintRecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqPrintRecord::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqPrintRecord::id() const {
  return id_;
}
inline void ReqPrintRecord::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 inputUser = 3;
inline bool ReqPrintRecord::has_inputuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqPrintRecord::set_has_inputuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqPrintRecord::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqPrintRecord::clear_inputuser() {
  inputuser_ = 0;
  clear_has_inputuser();
}
inline ::google::protobuf::int32 ReqPrintRecord::inputuser() const {
  return inputuser_;
}
inline void ReqPrintRecord::set_inputuser(::google::protobuf::int32 value) {
  set_has_inputuser();
  inputuser_ = value;
}

// -------------------------------------------------------------------

// RspPrintRecord

// optional int32 cmd = 1;
inline bool RspPrintRecord::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspPrintRecord::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspPrintRecord::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspPrintRecord::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 RspPrintRecord::cmd() const {
  return cmd_;
}
inline void RspPrintRecord::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 result = 2;
inline bool RspPrintRecord::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspPrintRecord::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspPrintRecord::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspPrintRecord::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RspPrintRecord::result() const {
  return result_;
}
inline void RspPrintRecord::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string result_info = 3;
inline bool RspPrintRecord::has_result_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspPrintRecord::set_has_result_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspPrintRecord::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspPrintRecord::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::kEmptyString) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& RspPrintRecord::result_info() const {
  return *result_info_;
}
inline void RspPrintRecord::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspPrintRecord::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void RspPrintRecord::set_result_info(const char* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  return result_info_;
}
inline ::std::string* RspPrintRecord::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 id = 4;
inline bool RspPrintRecord::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RspPrintRecord::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RspPrintRecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RspPrintRecord::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RspPrintRecord::id() const {
  return id_;
}
inline void RspPrintRecord::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 5;
inline bool RspPrintRecord::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RspPrintRecord::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RspPrintRecord::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RspPrintRecord::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RspPrintRecord::name() const {
  return *name_;
}
inline void RspPrintRecord::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RspPrintRecord::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RspPrintRecord::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RspPrintRecord::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditName = 6;
inline bool RspPrintRecord::has_creditname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RspPrintRecord::set_has_creditname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RspPrintRecord::clear_has_creditname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RspPrintRecord::clear_creditname() {
  if (creditname_ != &::google::protobuf::internal::kEmptyString) {
    creditname_->clear();
  }
  clear_has_creditname();
}
inline const ::std::string& RspPrintRecord::creditname() const {
  return *creditname_;
}
inline void RspPrintRecord::set_creditname(const ::std::string& value) {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  creditname_->assign(value);
}
inline void RspPrintRecord::set_creditname(const char* value) {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  creditname_->assign(value);
}
inline void RspPrintRecord::set_creditname(const char* value, size_t size) {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  creditname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_creditname() {
  set_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    creditname_ = new ::std::string;
  }
  return creditname_;
}
inline ::std::string* RspPrintRecord::release_creditname() {
  clear_has_creditname();
  if (creditname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditname_;
    creditname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditCode = 7;
inline bool RspPrintRecord::has_creditcode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RspPrintRecord::set_has_creditcode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RspPrintRecord::clear_has_creditcode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RspPrintRecord::clear_creditcode() {
  if (creditcode_ != &::google::protobuf::internal::kEmptyString) {
    creditcode_->clear();
  }
  clear_has_creditcode();
}
inline const ::std::string& RspPrintRecord::creditcode() const {
  return *creditcode_;
}
inline void RspPrintRecord::set_creditcode(const ::std::string& value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void RspPrintRecord::set_creditcode(const char* value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void RspPrintRecord::set_creditcode(const char* value, size_t size) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_creditcode() {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  return creditcode_;
}
inline ::std::string* RspPrintRecord::release_creditcode() {
  clear_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditcode_;
    creditcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nproId = 8;
inline bool RspPrintRecord::has_nproid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RspPrintRecord::set_has_nproid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RspPrintRecord::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RspPrintRecord::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& RspPrintRecord::nproid() const {
  return *nproid_;
}
inline void RspPrintRecord::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void RspPrintRecord::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void RspPrintRecord::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* RspPrintRecord::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strGrade = 9;
inline bool RspPrintRecord::has_strgrade() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RspPrintRecord::set_has_strgrade() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RspPrintRecord::clear_has_strgrade() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RspPrintRecord::clear_strgrade() {
  if (strgrade_ != &::google::protobuf::internal::kEmptyString) {
    strgrade_->clear();
  }
  clear_has_strgrade();
}
inline const ::std::string& RspPrintRecord::strgrade() const {
  return *strgrade_;
}
inline void RspPrintRecord::set_strgrade(const ::std::string& value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void RspPrintRecord::set_strgrade(const char* value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void RspPrintRecord::set_strgrade(const char* value, size_t size) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_strgrade() {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  return strgrade_;
}
inline ::std::string* RspPrintRecord::release_strgrade() {
  clear_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgrade_;
    strgrade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productType = 10;
inline bool RspPrintRecord::has_producttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RspPrintRecord::set_has_producttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RspPrintRecord::clear_has_producttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RspPrintRecord::clear_producttype() {
  if (producttype_ != &::google::protobuf::internal::kEmptyString) {
    producttype_->clear();
  }
  clear_has_producttype();
}
inline const ::std::string& RspPrintRecord::producttype() const {
  return *producttype_;
}
inline void RspPrintRecord::set_producttype(const ::std::string& value) {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  producttype_->assign(value);
}
inline void RspPrintRecord::set_producttype(const char* value) {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  producttype_->assign(value);
}
inline void RspPrintRecord::set_producttype(const char* value, size_t size) {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  producttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_producttype() {
  set_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    producttype_ = new ::std::string;
  }
  return producttype_;
}
inline ::std::string* RspPrintRecord::release_producttype() {
  clear_has_producttype();
  if (producttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = producttype_;
    producttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productName = 11;
inline bool RspPrintRecord::has_productname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RspPrintRecord::set_has_productname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RspPrintRecord::clear_has_productname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RspPrintRecord::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& RspPrintRecord::productname() const {
  return *productname_;
}
inline void RspPrintRecord::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void RspPrintRecord::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void RspPrintRecord::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* RspPrintRecord::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proName = 12;
inline bool RspPrintRecord::has_proname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RspPrintRecord::set_has_proname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RspPrintRecord::clear_has_proname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RspPrintRecord::clear_proname() {
  if (proname_ != &::google::protobuf::internal::kEmptyString) {
    proname_->clear();
  }
  clear_has_proname();
}
inline const ::std::string& RspPrintRecord::proname() const {
  return *proname_;
}
inline void RspPrintRecord::set_proname(const ::std::string& value) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(value);
}
inline void RspPrintRecord::set_proname(const char* value) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(value);
}
inline void RspPrintRecord::set_proname(const char* value, size_t size) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_proname() {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  return proname_;
}
inline ::std::string* RspPrintRecord::release_proname() {
  clear_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proname_;
    proname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proUserNo = 13;
inline bool RspPrintRecord::has_prouserno() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RspPrintRecord::set_has_prouserno() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RspPrintRecord::clear_has_prouserno() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RspPrintRecord::clear_prouserno() {
  if (prouserno_ != &::google::protobuf::internal::kEmptyString) {
    prouserno_->clear();
  }
  clear_has_prouserno();
}
inline const ::std::string& RspPrintRecord::prouserno() const {
  return *prouserno_;
}
inline void RspPrintRecord::set_prouserno(const ::std::string& value) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(value);
}
inline void RspPrintRecord::set_prouserno(const char* value) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(value);
}
inline void RspPrintRecord::set_prouserno(const char* value, size_t size) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_prouserno() {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  return prouserno_;
}
inline ::std::string* RspPrintRecord::release_prouserno() {
  clear_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prouserno_;
    prouserno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pictureStrart = 14;
inline bool RspPrintRecord::has_picturestrart() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RspPrintRecord::set_has_picturestrart() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RspPrintRecord::clear_has_picturestrart() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RspPrintRecord::clear_picturestrart() {
  if (picturestrart_ != &::google::protobuf::internal::kEmptyString) {
    picturestrart_->clear();
  }
  clear_has_picturestrart();
}
inline const ::std::string& RspPrintRecord::picturestrart() const {
  return *picturestrart_;
}
inline void RspPrintRecord::set_picturestrart(const ::std::string& value) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(value);
}
inline void RspPrintRecord::set_picturestrart(const char* value) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(value);
}
inline void RspPrintRecord::set_picturestrart(const char* value, size_t size) {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  picturestrart_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_picturestrart() {
  set_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    picturestrart_ = new ::std::string;
  }
  return picturestrart_;
}
inline ::std::string* RspPrintRecord::release_picturestrart() {
  clear_has_picturestrart();
  if (picturestrart_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picturestrart_;
    picturestrart_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pictureEnd = 15;
inline bool RspPrintRecord::has_pictureend() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RspPrintRecord::set_has_pictureend() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RspPrintRecord::clear_has_pictureend() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RspPrintRecord::clear_pictureend() {
  if (pictureend_ != &::google::protobuf::internal::kEmptyString) {
    pictureend_->clear();
  }
  clear_has_pictureend();
}
inline const ::std::string& RspPrintRecord::pictureend() const {
  return *pictureend_;
}
inline void RspPrintRecord::set_pictureend(const ::std::string& value) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(value);
}
inline void RspPrintRecord::set_pictureend(const char* value) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(value);
}
inline void RspPrintRecord::set_pictureend(const char* value, size_t size) {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  pictureend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_pictureend() {
  set_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    pictureend_ = new ::std::string;
  }
  return pictureend_;
}
inline ::std::string* RspPrintRecord::release_pictureend() {
  clear_has_pictureend();
  if (pictureend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pictureend_;
    pictureend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string businessTime = 16;
inline bool RspPrintRecord::has_businesstime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RspPrintRecord::set_has_businesstime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RspPrintRecord::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RspPrintRecord::clear_businesstime() {
  if (businesstime_ != &::google::protobuf::internal::kEmptyString) {
    businesstime_->clear();
  }
  clear_has_businesstime();
}
inline const ::std::string& RspPrintRecord::businesstime() const {
  return *businesstime_;
}
inline void RspPrintRecord::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void RspPrintRecord::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void RspPrintRecord::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPrintRecord::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  return businesstime_;
}
inline ::std::string* RspPrintRecord::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_csclient_2fCsClientRecord_2eproto__INCLUDED
