// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csclient/ProductType.proto

#ifndef PROTOBUF_csclient_2fProductType_2eproto__INCLUDED
#define PROTOBUF_csclient_2fProductType_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_csclient_2fProductType_2eproto();
void protobuf_AssignDesc_csclient_2fProductType_2eproto();
void protobuf_ShutdownFile_csclient_2fProductType_2eproto();

class ProductType;
class ReqProductType;
class ProductTypeList;

// ===================================================================

class ProductType : public ::google::protobuf::Message {
 public:
  ProductType();
  virtual ~ProductType();
  
  ProductType(const ProductType& from);
  
  inline ProductType& operator=(const ProductType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductType& default_instance();
  
  void Swap(ProductType* other);
  
  // implements Message ----------------------------------------------
  
  ProductType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductType& from);
  void MergeFrom(const ProductType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);
  
  // optional string strName = 3;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 3;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  
  // optional string strInterAreaCode = 4;
  inline bool has_strinterareacode() const;
  inline void clear_strinterareacode();
  static const int kStrInterAreaCodeFieldNumber = 4;
  inline const ::std::string& strinterareacode() const;
  inline void set_strinterareacode(const ::std::string& value);
  inline void set_strinterareacode(const char* value);
  inline void set_strinterareacode(const char* value, size_t size);
  inline ::std::string* mutable_strinterareacode();
  inline ::std::string* release_strinterareacode();
  
  // optional string strPath = 5;
  inline bool has_strpath() const;
  inline void clear_strpath();
  static const int kStrPathFieldNumber = 5;
  inline const ::std::string& strpath() const;
  inline void set_strpath(const ::std::string& value);
  inline void set_strpath(const char* value);
  inline void set_strpath(const char* value, size_t size);
  inline ::std::string* mutable_strpath();
  inline ::std::string* release_strpath();
  
  // optional int32 nsortId = 6;
  inline bool has_nsortid() const;
  inline void clear_nsortid();
  static const int kNsortIdFieldNumber = 6;
  inline ::google::protobuf::int32 nsortid() const;
  inline void set_nsortid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.ProductType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_strinterareacode();
  inline void clear_has_strinterareacode();
  inline void set_has_strpath();
  inline void clear_has_strpath();
  inline void set_has_nsortid();
  inline void clear_has_nsortid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 pid_;
  ::std::string* strname_;
  ::std::string* strinterareacode_;
  ::std::string* strpath_;
  ::google::protobuf::int32 nsortid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fProductType_2eproto();
  friend void protobuf_AssignDesc_csclient_2fProductType_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fProductType_2eproto();
  
  void InitAsDefaultInstance();
  static ProductType* default_instance_;
};
// -------------------------------------------------------------------

class ReqProductType : public ::google::protobuf::Message {
 public:
  ReqProductType();
  virtual ~ReqProductType();
  
  ReqProductType(const ReqProductType& from);
  
  inline ReqProductType& operator=(const ReqProductType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqProductType& default_instance();
  
  void Swap(ReqProductType* other);
  
  // implements Message ----------------------------------------------
  
  ReqProductType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqProductType& from);
  void MergeFrom(const ReqProductType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);
  
  // optional string strName = 4;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 4;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  
  // optional string strInterAreaCode = 5;
  inline bool has_strinterareacode() const;
  inline void clear_strinterareacode();
  static const int kStrInterAreaCodeFieldNumber = 5;
  inline const ::std::string& strinterareacode() const;
  inline void set_strinterareacode(const ::std::string& value);
  inline void set_strinterareacode(const char* value);
  inline void set_strinterareacode(const char* value, size_t size);
  inline ::std::string* mutable_strinterareacode();
  inline ::std::string* release_strinterareacode();
  
  // optional string strPath = 6;
  inline bool has_strpath() const;
  inline void clear_strpath();
  static const int kStrPathFieldNumber = 6;
  inline const ::std::string& strpath() const;
  inline void set_strpath(const ::std::string& value);
  inline void set_strpath(const char* value);
  inline void set_strpath(const char* value, size_t size);
  inline ::std::string* mutable_strpath();
  inline ::std::string* release_strpath();
  
  // optional int32 nsortId = 7;
  inline bool has_nsortid() const;
  inline void clear_nsortid();
  static const int kNsortIdFieldNumber = 7;
  inline ::google::protobuf::int32 nsortid() const;
  inline void set_nsortid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqProductType)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_strinterareacode();
  inline void clear_has_strinterareacode();
  inline void set_has_strpath();
  inline void clear_has_strpath();
  inline void set_has_nsortid();
  inline void clear_has_nsortid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 id_;
  ::std::string* strname_;
  ::std::string* strinterareacode_;
  ::google::protobuf::int32 pid_;
  ::google::protobuf::int32 nsortid_;
  ::std::string* strpath_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fProductType_2eproto();
  friend void protobuf_AssignDesc_csclient_2fProductType_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fProductType_2eproto();
  
  void InitAsDefaultInstance();
  static ReqProductType* default_instance_;
};
// -------------------------------------------------------------------

class ProductTypeList : public ::google::protobuf::Message {
 public:
  ProductTypeList();
  virtual ~ProductTypeList();
  
  ProductTypeList(const ProductTypeList& from);
  
  inline ProductTypeList& operator=(const ProductTypeList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductTypeList& default_instance();
  
  void Swap(ProductTypeList* other);
  
  // implements Message ----------------------------------------------
  
  ProductTypeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductTypeList& from);
  void MergeFrom(const ProductTypeList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string result_info = 3;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 3;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const char* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  
  // repeated .cms_8120.ProductType productType = 4;
  inline int producttype_size() const;
  inline void clear_producttype();
  static const int kProductTypeFieldNumber = 4;
  inline const ::cms_8120::ProductType& producttype(int index) const;
  inline ::cms_8120::ProductType* mutable_producttype(int index);
  inline ::cms_8120::ProductType* add_producttype();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::ProductType >&
      producttype() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::ProductType >*
      mutable_producttype();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ProductTypeList)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_result_info();
  inline void clear_has_result_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 result_;
  ::std::string* result_info_;
  ::google::protobuf::RepeatedPtrField< ::cms_8120::ProductType > producttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_csclient_2fProductType_2eproto();
  friend void protobuf_AssignDesc_csclient_2fProductType_2eproto();
  friend void protobuf_ShutdownFile_csclient_2fProductType_2eproto();
  
  void InitAsDefaultInstance();
  static ProductTypeList* default_instance_;
};
// ===================================================================


// ===================================================================

// ProductType

// optional int32 id = 1;
inline bool ProductType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductType::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ProductType::id() const {
  return id_;
}
inline void ProductType::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 pid = 2;
inline bool ProductType::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductType::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductType::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductType::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ProductType::pid() const {
  return pid_;
}
inline void ProductType::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional string strName = 3;
inline bool ProductType::has_strname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductType::set_has_strname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductType::clear_has_strname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductType::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& ProductType::strname() const {
  return *strname_;
}
inline void ProductType::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ProductType::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ProductType::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductType::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* ProductType::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strInterAreaCode = 4;
inline bool ProductType::has_strinterareacode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductType::set_has_strinterareacode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductType::clear_has_strinterareacode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductType::clear_strinterareacode() {
  if (strinterareacode_ != &::google::protobuf::internal::kEmptyString) {
    strinterareacode_->clear();
  }
  clear_has_strinterareacode();
}
inline const ::std::string& ProductType::strinterareacode() const {
  return *strinterareacode_;
}
inline void ProductType::set_strinterareacode(const ::std::string& value) {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  strinterareacode_->assign(value);
}
inline void ProductType::set_strinterareacode(const char* value) {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  strinterareacode_->assign(value);
}
inline void ProductType::set_strinterareacode(const char* value, size_t size) {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  strinterareacode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductType::mutable_strinterareacode() {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  return strinterareacode_;
}
inline ::std::string* ProductType::release_strinterareacode() {
  clear_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strinterareacode_;
    strinterareacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strPath = 5;
inline bool ProductType::has_strpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProductType::set_has_strpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProductType::clear_has_strpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProductType::clear_strpath() {
  if (strpath_ != &::google::protobuf::internal::kEmptyString) {
    strpath_->clear();
  }
  clear_has_strpath();
}
inline const ::std::string& ProductType::strpath() const {
  return *strpath_;
}
inline void ProductType::set_strpath(const ::std::string& value) {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  strpath_->assign(value);
}
inline void ProductType::set_strpath(const char* value) {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  strpath_->assign(value);
}
inline void ProductType::set_strpath(const char* value, size_t size) {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  strpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductType::mutable_strpath() {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  return strpath_;
}
inline ::std::string* ProductType::release_strpath() {
  clear_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpath_;
    strpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nsortId = 6;
inline bool ProductType::has_nsortid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProductType::set_has_nsortid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProductType::clear_has_nsortid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProductType::clear_nsortid() {
  nsortid_ = 0;
  clear_has_nsortid();
}
inline ::google::protobuf::int32 ProductType::nsortid() const {
  return nsortid_;
}
inline void ProductType::set_nsortid(::google::protobuf::int32 value) {
  set_has_nsortid();
  nsortid_ = value;
}

// -------------------------------------------------------------------

// ReqProductType

// optional int32 cmd = 1;
inline bool ReqProductType::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqProductType::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqProductType::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqProductType::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqProductType::cmd() const {
  return cmd_;
}
inline void ReqProductType::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 id = 2;
inline bool ReqProductType::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqProductType::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqProductType::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqProductType::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqProductType::id() const {
  return id_;
}
inline void ReqProductType::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 pid = 3;
inline bool ReqProductType::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqProductType::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqProductType::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqProductType::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ReqProductType::pid() const {
  return pid_;
}
inline void ReqProductType::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// optional string strName = 4;
inline bool ReqProductType::has_strname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqProductType::set_has_strname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqProductType::clear_has_strname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqProductType::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& ReqProductType::strname() const {
  return *strname_;
}
inline void ReqProductType::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ReqProductType::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void ReqProductType::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqProductType::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* ReqProductType::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strInterAreaCode = 5;
inline bool ReqProductType::has_strinterareacode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqProductType::set_has_strinterareacode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqProductType::clear_has_strinterareacode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqProductType::clear_strinterareacode() {
  if (strinterareacode_ != &::google::protobuf::internal::kEmptyString) {
    strinterareacode_->clear();
  }
  clear_has_strinterareacode();
}
inline const ::std::string& ReqProductType::strinterareacode() const {
  return *strinterareacode_;
}
inline void ReqProductType::set_strinterareacode(const ::std::string& value) {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  strinterareacode_->assign(value);
}
inline void ReqProductType::set_strinterareacode(const char* value) {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  strinterareacode_->assign(value);
}
inline void ReqProductType::set_strinterareacode(const char* value, size_t size) {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  strinterareacode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqProductType::mutable_strinterareacode() {
  set_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    strinterareacode_ = new ::std::string;
  }
  return strinterareacode_;
}
inline ::std::string* ReqProductType::release_strinterareacode() {
  clear_has_strinterareacode();
  if (strinterareacode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strinterareacode_;
    strinterareacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strPath = 6;
inline bool ReqProductType::has_strpath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqProductType::set_has_strpath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqProductType::clear_has_strpath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqProductType::clear_strpath() {
  if (strpath_ != &::google::protobuf::internal::kEmptyString) {
    strpath_->clear();
  }
  clear_has_strpath();
}
inline const ::std::string& ReqProductType::strpath() const {
  return *strpath_;
}
inline void ReqProductType::set_strpath(const ::std::string& value) {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  strpath_->assign(value);
}
inline void ReqProductType::set_strpath(const char* value) {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  strpath_->assign(value);
}
inline void ReqProductType::set_strpath(const char* value, size_t size) {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  strpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqProductType::mutable_strpath() {
  set_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    strpath_ = new ::std::string;
  }
  return strpath_;
}
inline ::std::string* ReqProductType::release_strpath() {
  clear_has_strpath();
  if (strpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpath_;
    strpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nsortId = 7;
inline bool ReqProductType::has_nsortid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqProductType::set_has_nsortid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqProductType::clear_has_nsortid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqProductType::clear_nsortid() {
  nsortid_ = 0;
  clear_has_nsortid();
}
inline ::google::protobuf::int32 ReqProductType::nsortid() const {
  return nsortid_;
}
inline void ReqProductType::set_nsortid(::google::protobuf::int32 value) {
  set_has_nsortid();
  nsortid_ = value;
}

// -------------------------------------------------------------------

// ProductTypeList

// optional int32 cmd = 1;
inline bool ProductTypeList::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductTypeList::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductTypeList::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductTypeList::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ProductTypeList::cmd() const {
  return cmd_;
}
inline void ProductTypeList::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 result = 2;
inline bool ProductTypeList::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductTypeList::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductTypeList::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductTypeList::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ProductTypeList::result() const {
  return result_;
}
inline void ProductTypeList::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string result_info = 3;
inline bool ProductTypeList::has_result_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductTypeList::set_has_result_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductTypeList::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductTypeList::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::kEmptyString) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& ProductTypeList::result_info() const {
  return *result_info_;
}
inline void ProductTypeList::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void ProductTypeList::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
}
inline void ProductTypeList::set_result_info(const char* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductTypeList::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    result_info_ = new ::std::string;
  }
  return result_info_;
}
inline ::std::string* ProductTypeList::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .cms_8120.ProductType productType = 4;
inline int ProductTypeList::producttype_size() const {
  return producttype_.size();
}
inline void ProductTypeList::clear_producttype() {
  producttype_.Clear();
}
inline const ::cms_8120::ProductType& ProductTypeList::producttype(int index) const {
  return producttype_.Get(index);
}
inline ::cms_8120::ProductType* ProductTypeList::mutable_producttype(int index) {
  return producttype_.Mutable(index);
}
inline ::cms_8120::ProductType* ProductTypeList::add_producttype() {
  return producttype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::ProductType >&
ProductTypeList::producttype() const {
  return producttype_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::ProductType >*
ProductTypeList::mutable_producttype() {
  return &producttype_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_csclient_2fProductType_2eproto__INCLUDED
