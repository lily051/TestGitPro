// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: center/Alarmlog.proto

#ifndef PROTOBUF_center_2fAlarmlog_2eproto__INCLUDED
#define PROTOBUF_center_2fAlarmlog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "server/RspServerData.pb.h"
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_center_2fAlarmlog_2eproto();
void protobuf_AssignDesc_center_2fAlarmlog_2eproto();
void protobuf_ShutdownFile_center_2fAlarmlog_2eproto();

class Alarmlog;
class AlarmlogInfo;

// ===================================================================

class Alarmlog : public ::google::protobuf::Message {
 public:
  Alarmlog();
  virtual ~Alarmlog();
  
  Alarmlog(const Alarmlog& from);
  
  inline Alarmlog& operator=(const Alarmlog& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Alarmlog& default_instance();
  
  void Swap(Alarmlog* other);
  
  // implements Message ----------------------------------------------
  
  Alarmlog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alarmlog& from);
  void MergeFrom(const Alarmlog& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 checkType = 2;
  inline bool has_checktype() const;
  inline void clear_checktype();
  static const int kCheckTypeFieldNumber = 2;
  inline ::google::protobuf::int32 checktype() const;
  inline void set_checktype(::google::protobuf::int32 value);
  
  // optional int32 checkObjId = 3;
  inline bool has_checkobjid() const;
  inline void clear_checkobjid();
  static const int kCheckObjIdFieldNumber = 3;
  inline ::google::protobuf::int32 checkobjid() const;
  inline void set_checkobjid(::google::protobuf::int32 value);
  
  // optional int32 checkChan = 4;
  inline bool has_checkchan() const;
  inline void clear_checkchan();
  static const int kCheckChanFieldNumber = 4;
  inline ::google::protobuf::int32 checkchan() const;
  inline void set_checkchan(::google::protobuf::int32 value);
  
  // optional int32 contactObjId = 5;
  inline bool has_contactobjid() const;
  inline void clear_contactobjid();
  static const int kContactObjIdFieldNumber = 5;
  inline ::google::protobuf::int32 contactobjid() const;
  inline void set_contactobjid(::google::protobuf::int32 value);
  
  // optional int32 alarmType = 6;
  inline bool has_alarmtype() const;
  inline void clear_alarmtype();
  static const int kAlarmTypeFieldNumber = 6;
  inline ::google::protobuf::int32 alarmtype() const;
  inline void set_alarmtype(::google::protobuf::int32 value);
  
  // optional string alarmTime = 7;
  inline bool has_alarmtime() const;
  inline void clear_alarmtime();
  static const int kAlarmTimeFieldNumber = 7;
  inline const ::std::string& alarmtime() const;
  inline void set_alarmtime(const ::std::string& value);
  inline void set_alarmtime(const char* value);
  inline void set_alarmtime(const char* value, size_t size);
  inline ::std::string* mutable_alarmtime();
  inline ::std::string* release_alarmtime();
  
  // optional string alarmbeginTime = 8;
  inline bool has_alarmbegintime() const;
  inline void clear_alarmbegintime();
  static const int kAlarmbeginTimeFieldNumber = 8;
  inline const ::std::string& alarmbegintime() const;
  inline void set_alarmbegintime(const ::std::string& value);
  inline void set_alarmbegintime(const char* value);
  inline void set_alarmbegintime(const char* value, size_t size);
  inline ::std::string* mutable_alarmbegintime();
  inline ::std::string* release_alarmbegintime();
  
  // optional int32 alarmRegionId = 9;
  inline bool has_alarmregionid() const;
  inline void clear_alarmregionid();
  static const int kAlarmRegionIdFieldNumber = 9;
  inline ::google::protobuf::int32 alarmregionid() const;
  inline void set_alarmregionid(::google::protobuf::int32 value);
  
  // optional string comments = 10;
  inline bool has_comments() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 10;
  inline const ::std::string& comments() const;
  inline void set_comments(const ::std::string& value);
  inline void set_comments(const char* value);
  inline void set_comments(const char* value, size_t size);
  inline ::std::string* mutable_comments();
  inline ::std::string* release_comments();
  
  // optional string strHost = 11;
  inline bool has_strhost() const;
  inline void clear_strhost();
  static const int kStrHostFieldNumber = 11;
  inline const ::std::string& strhost() const;
  inline void set_strhost(const ::std::string& value);
  inline void set_strhost(const char* value);
  inline void set_strhost(const char* value, size_t size);
  inline ::std::string* mutable_strhost();
  inline ::std::string* release_strhost();
  
  // optional int32 status = 12;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 12;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional string checker = 13;
  inline bool has_checker() const;
  inline void clear_checker();
  static const int kCheckerFieldNumber = 13;
  inline const ::std::string& checker() const;
  inline void set_checker(const ::std::string& value);
  inline void set_checker(const char* value);
  inline void set_checker(const char* value, size_t size);
  inline ::std::string* mutable_checker();
  inline ::std::string* release_checker();
  
  // optional string userNo = 14;
  inline bool has_userno() const;
  inline void clear_userno();
  static const int kUserNoFieldNumber = 14;
  inline const ::std::string& userno() const;
  inline void set_userno(const ::std::string& value);
  inline void set_userno(const char* value);
  inline void set_userno(const char* value, size_t size);
  inline ::std::string* mutable_userno();
  inline ::std::string* release_userno();
  
  // optional string dealTime = 15;
  inline bool has_dealtime() const;
  inline void clear_dealtime();
  static const int kDealTimeFieldNumber = 15;
  inline const ::std::string& dealtime() const;
  inline void set_dealtime(const ::std::string& value);
  inline void set_dealtime(const char* value);
  inline void set_dealtime(const char* value, size_t size);
  inline ::std::string* mutable_dealtime();
  inline ::std::string* release_dealtime();
  
  // optional string dealcomment = 16;
  inline bool has_dealcomment() const;
  inline void clear_dealcomment();
  static const int kDealcommentFieldNumber = 16;
  inline const ::std::string& dealcomment() const;
  inline void set_dealcomment(const ::std::string& value);
  inline void set_dealcomment(const char* value);
  inline void set_dealcomment(const char* value, size_t size);
  inline ::std::string* mutable_dealcomment();
  inline ::std::string* release_dealcomment();
  
  // optional int32 alarmlevel = 17;
  inline bool has_alarmlevel() const;
  inline void clear_alarmlevel();
  static const int kAlarmlevelFieldNumber = 17;
  inline ::google::protobuf::int32 alarmlevel() const;
  inline void set_alarmlevel(::google::protobuf::int32 value);
  
  // optional string strGuid = 18;
  inline bool has_strguid() const;
  inline void clear_strguid();
  static const int kStrGuidFieldNumber = 18;
  inline const ::std::string& strguid() const;
  inline void set_strguid(const ::std::string& value);
  inline void set_strguid(const char* value);
  inline void set_strguid(const char* value, size_t size);
  inline ::std::string* mutable_strguid();
  inline ::std::string* release_strguid();
  
  // @@protoc_insertion_point(class_scope:cms_8120.Alarmlog)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_checktype();
  inline void clear_has_checktype();
  inline void set_has_checkobjid();
  inline void clear_has_checkobjid();
  inline void set_has_checkchan();
  inline void clear_has_checkchan();
  inline void set_has_contactobjid();
  inline void clear_has_contactobjid();
  inline void set_has_alarmtype();
  inline void clear_has_alarmtype();
  inline void set_has_alarmtime();
  inline void clear_has_alarmtime();
  inline void set_has_alarmbegintime();
  inline void clear_has_alarmbegintime();
  inline void set_has_alarmregionid();
  inline void clear_has_alarmregionid();
  inline void set_has_comments();
  inline void clear_has_comments();
  inline void set_has_strhost();
  inline void clear_has_strhost();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_checker();
  inline void clear_has_checker();
  inline void set_has_userno();
  inline void clear_has_userno();
  inline void set_has_dealtime();
  inline void clear_has_dealtime();
  inline void set_has_dealcomment();
  inline void clear_has_dealcomment();
  inline void set_has_alarmlevel();
  inline void clear_has_alarmlevel();
  inline void set_has_strguid();
  inline void clear_has_strguid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 checktype_;
  ::google::protobuf::int32 checkobjid_;
  ::google::protobuf::int32 checkchan_;
  ::google::protobuf::int32 contactobjid_;
  ::google::protobuf::int32 alarmtype_;
  ::std::string* alarmtime_;
  ::std::string* alarmbegintime_;
  ::std::string* comments_;
  ::google::protobuf::int32 alarmregionid_;
  ::google::protobuf::int32 status_;
  ::std::string* strhost_;
  ::std::string* checker_;
  ::std::string* userno_;
  ::std::string* dealtime_;
  ::std::string* dealcomment_;
  ::std::string* strguid_;
  ::google::protobuf::int32 alarmlevel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fAlarmlog_2eproto();
  friend void protobuf_AssignDesc_center_2fAlarmlog_2eproto();
  friend void protobuf_ShutdownFile_center_2fAlarmlog_2eproto();
  
  void InitAsDefaultInstance();
  static Alarmlog* default_instance_;
};
// -------------------------------------------------------------------

class AlarmlogInfo : public ::google::protobuf::Message {
 public:
  AlarmlogInfo();
  virtual ~AlarmlogInfo();
  
  AlarmlogInfo(const AlarmlogInfo& from);
  
  inline AlarmlogInfo& operator=(const AlarmlogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmlogInfo& default_instance();
  
  void Swap(AlarmlogInfo* other);
  
  // implements Message ----------------------------------------------
  
  AlarmlogInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlarmlogInfo& from);
  void MergeFrom(const AlarmlogInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional .cms_8120.Alarmlog alarmlog = 2;
  inline bool has_alarmlog() const;
  inline void clear_alarmlog();
  static const int kAlarmlogFieldNumber = 2;
  inline const ::cms_8120::Alarmlog& alarmlog() const;
  inline ::cms_8120::Alarmlog* mutable_alarmlog();
  inline ::cms_8120::Alarmlog* release_alarmlog();
  
  // @@protoc_insertion_point(class_scope:cms_8120.AlarmlogInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_alarmlog();
  inline void clear_has_alarmlog();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cms_8120::Alarmlog* alarmlog_;
  ::google::protobuf::int32 cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fAlarmlog_2eproto();
  friend void protobuf_AssignDesc_center_2fAlarmlog_2eproto();
  friend void protobuf_ShutdownFile_center_2fAlarmlog_2eproto();
  
  void InitAsDefaultInstance();
  static AlarmlogInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// Alarmlog

// optional int32 id = 1;
inline bool Alarmlog::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Alarmlog::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Alarmlog::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Alarmlog::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Alarmlog::id() const {
  return id_;
}
inline void Alarmlog::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 checkType = 2;
inline bool Alarmlog::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Alarmlog::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Alarmlog::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Alarmlog::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 Alarmlog::checktype() const {
  return checktype_;
}
inline void Alarmlog::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional int32 checkObjId = 3;
inline bool Alarmlog::has_checkobjid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alarmlog::set_has_checkobjid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alarmlog::clear_has_checkobjid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alarmlog::clear_checkobjid() {
  checkobjid_ = 0;
  clear_has_checkobjid();
}
inline ::google::protobuf::int32 Alarmlog::checkobjid() const {
  return checkobjid_;
}
inline void Alarmlog::set_checkobjid(::google::protobuf::int32 value) {
  set_has_checkobjid();
  checkobjid_ = value;
}

// optional int32 checkChan = 4;
inline bool Alarmlog::has_checkchan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Alarmlog::set_has_checkchan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Alarmlog::clear_has_checkchan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Alarmlog::clear_checkchan() {
  checkchan_ = 0;
  clear_has_checkchan();
}
inline ::google::protobuf::int32 Alarmlog::checkchan() const {
  return checkchan_;
}
inline void Alarmlog::set_checkchan(::google::protobuf::int32 value) {
  set_has_checkchan();
  checkchan_ = value;
}

// optional int32 contactObjId = 5;
inline bool Alarmlog::has_contactobjid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Alarmlog::set_has_contactobjid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Alarmlog::clear_has_contactobjid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Alarmlog::clear_contactobjid() {
  contactobjid_ = 0;
  clear_has_contactobjid();
}
inline ::google::protobuf::int32 Alarmlog::contactobjid() const {
  return contactobjid_;
}
inline void Alarmlog::set_contactobjid(::google::protobuf::int32 value) {
  set_has_contactobjid();
  contactobjid_ = value;
}

// optional int32 alarmType = 6;
inline bool Alarmlog::has_alarmtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Alarmlog::set_has_alarmtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Alarmlog::clear_has_alarmtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Alarmlog::clear_alarmtype() {
  alarmtype_ = 0;
  clear_has_alarmtype();
}
inline ::google::protobuf::int32 Alarmlog::alarmtype() const {
  return alarmtype_;
}
inline void Alarmlog::set_alarmtype(::google::protobuf::int32 value) {
  set_has_alarmtype();
  alarmtype_ = value;
}

// optional string alarmTime = 7;
inline bool Alarmlog::has_alarmtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Alarmlog::set_has_alarmtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Alarmlog::clear_has_alarmtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Alarmlog::clear_alarmtime() {
  if (alarmtime_ != &::google::protobuf::internal::kEmptyString) {
    alarmtime_->clear();
  }
  clear_has_alarmtime();
}
inline const ::std::string& Alarmlog::alarmtime() const {
  return *alarmtime_;
}
inline void Alarmlog::set_alarmtime(const ::std::string& value) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(value);
}
inline void Alarmlog::set_alarmtime(const char* value) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(value);
}
inline void Alarmlog::set_alarmtime(const char* value, size_t size) {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  alarmtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_alarmtime() {
  set_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    alarmtime_ = new ::std::string;
  }
  return alarmtime_;
}
inline ::std::string* Alarmlog::release_alarmtime() {
  clear_has_alarmtime();
  if (alarmtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarmtime_;
    alarmtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string alarmbeginTime = 8;
inline bool Alarmlog::has_alarmbegintime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Alarmlog::set_has_alarmbegintime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Alarmlog::clear_has_alarmbegintime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Alarmlog::clear_alarmbegintime() {
  if (alarmbegintime_ != &::google::protobuf::internal::kEmptyString) {
    alarmbegintime_->clear();
  }
  clear_has_alarmbegintime();
}
inline const ::std::string& Alarmlog::alarmbegintime() const {
  return *alarmbegintime_;
}
inline void Alarmlog::set_alarmbegintime(const ::std::string& value) {
  set_has_alarmbegintime();
  if (alarmbegintime_ == &::google::protobuf::internal::kEmptyString) {
    alarmbegintime_ = new ::std::string;
  }
  alarmbegintime_->assign(value);
}
inline void Alarmlog::set_alarmbegintime(const char* value) {
  set_has_alarmbegintime();
  if (alarmbegintime_ == &::google::protobuf::internal::kEmptyString) {
    alarmbegintime_ = new ::std::string;
  }
  alarmbegintime_->assign(value);
}
inline void Alarmlog::set_alarmbegintime(const char* value, size_t size) {
  set_has_alarmbegintime();
  if (alarmbegintime_ == &::google::protobuf::internal::kEmptyString) {
    alarmbegintime_ = new ::std::string;
  }
  alarmbegintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_alarmbegintime() {
  set_has_alarmbegintime();
  if (alarmbegintime_ == &::google::protobuf::internal::kEmptyString) {
    alarmbegintime_ = new ::std::string;
  }
  return alarmbegintime_;
}
inline ::std::string* Alarmlog::release_alarmbegintime() {
  clear_has_alarmbegintime();
  if (alarmbegintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarmbegintime_;
    alarmbegintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 alarmRegionId = 9;
inline bool Alarmlog::has_alarmregionid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Alarmlog::set_has_alarmregionid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Alarmlog::clear_has_alarmregionid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Alarmlog::clear_alarmregionid() {
  alarmregionid_ = 0;
  clear_has_alarmregionid();
}
inline ::google::protobuf::int32 Alarmlog::alarmregionid() const {
  return alarmregionid_;
}
inline void Alarmlog::set_alarmregionid(::google::protobuf::int32 value) {
  set_has_alarmregionid();
  alarmregionid_ = value;
}

// optional string comments = 10;
inline bool Alarmlog::has_comments() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Alarmlog::set_has_comments() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Alarmlog::clear_has_comments() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Alarmlog::clear_comments() {
  if (comments_ != &::google::protobuf::internal::kEmptyString) {
    comments_->clear();
  }
  clear_has_comments();
}
inline const ::std::string& Alarmlog::comments() const {
  return *comments_;
}
inline void Alarmlog::set_comments(const ::std::string& value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
}
inline void Alarmlog::set_comments(const char* value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
}
inline void Alarmlog::set_comments(const char* value, size_t size) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_comments() {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  return comments_;
}
inline ::std::string* Alarmlog::release_comments() {
  clear_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comments_;
    comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strHost = 11;
inline bool Alarmlog::has_strhost() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Alarmlog::set_has_strhost() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Alarmlog::clear_has_strhost() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Alarmlog::clear_strhost() {
  if (strhost_ != &::google::protobuf::internal::kEmptyString) {
    strhost_->clear();
  }
  clear_has_strhost();
}
inline const ::std::string& Alarmlog::strhost() const {
  return *strhost_;
}
inline void Alarmlog::set_strhost(const ::std::string& value) {
  set_has_strhost();
  if (strhost_ == &::google::protobuf::internal::kEmptyString) {
    strhost_ = new ::std::string;
  }
  strhost_->assign(value);
}
inline void Alarmlog::set_strhost(const char* value) {
  set_has_strhost();
  if (strhost_ == &::google::protobuf::internal::kEmptyString) {
    strhost_ = new ::std::string;
  }
  strhost_->assign(value);
}
inline void Alarmlog::set_strhost(const char* value, size_t size) {
  set_has_strhost();
  if (strhost_ == &::google::protobuf::internal::kEmptyString) {
    strhost_ = new ::std::string;
  }
  strhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_strhost() {
  set_has_strhost();
  if (strhost_ == &::google::protobuf::internal::kEmptyString) {
    strhost_ = new ::std::string;
  }
  return strhost_;
}
inline ::std::string* Alarmlog::release_strhost() {
  clear_has_strhost();
  if (strhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strhost_;
    strhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 12;
inline bool Alarmlog::has_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Alarmlog::set_has_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Alarmlog::clear_has_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Alarmlog::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Alarmlog::status() const {
  return status_;
}
inline void Alarmlog::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string checker = 13;
inline bool Alarmlog::has_checker() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Alarmlog::set_has_checker() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Alarmlog::clear_has_checker() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Alarmlog::clear_checker() {
  if (checker_ != &::google::protobuf::internal::kEmptyString) {
    checker_->clear();
  }
  clear_has_checker();
}
inline const ::std::string& Alarmlog::checker() const {
  return *checker_;
}
inline void Alarmlog::set_checker(const ::std::string& value) {
  set_has_checker();
  if (checker_ == &::google::protobuf::internal::kEmptyString) {
    checker_ = new ::std::string;
  }
  checker_->assign(value);
}
inline void Alarmlog::set_checker(const char* value) {
  set_has_checker();
  if (checker_ == &::google::protobuf::internal::kEmptyString) {
    checker_ = new ::std::string;
  }
  checker_->assign(value);
}
inline void Alarmlog::set_checker(const char* value, size_t size) {
  set_has_checker();
  if (checker_ == &::google::protobuf::internal::kEmptyString) {
    checker_ = new ::std::string;
  }
  checker_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_checker() {
  set_has_checker();
  if (checker_ == &::google::protobuf::internal::kEmptyString) {
    checker_ = new ::std::string;
  }
  return checker_;
}
inline ::std::string* Alarmlog::release_checker() {
  clear_has_checker();
  if (checker_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checker_;
    checker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string userNo = 14;
inline bool Alarmlog::has_userno() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Alarmlog::set_has_userno() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Alarmlog::clear_has_userno() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Alarmlog::clear_userno() {
  if (userno_ != &::google::protobuf::internal::kEmptyString) {
    userno_->clear();
  }
  clear_has_userno();
}
inline const ::std::string& Alarmlog::userno() const {
  return *userno_;
}
inline void Alarmlog::set_userno(const ::std::string& value) {
  set_has_userno();
  if (userno_ == &::google::protobuf::internal::kEmptyString) {
    userno_ = new ::std::string;
  }
  userno_->assign(value);
}
inline void Alarmlog::set_userno(const char* value) {
  set_has_userno();
  if (userno_ == &::google::protobuf::internal::kEmptyString) {
    userno_ = new ::std::string;
  }
  userno_->assign(value);
}
inline void Alarmlog::set_userno(const char* value, size_t size) {
  set_has_userno();
  if (userno_ == &::google::protobuf::internal::kEmptyString) {
    userno_ = new ::std::string;
  }
  userno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_userno() {
  set_has_userno();
  if (userno_ == &::google::protobuf::internal::kEmptyString) {
    userno_ = new ::std::string;
  }
  return userno_;
}
inline ::std::string* Alarmlog::release_userno() {
  clear_has_userno();
  if (userno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userno_;
    userno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dealTime = 15;
inline bool Alarmlog::has_dealtime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Alarmlog::set_has_dealtime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Alarmlog::clear_has_dealtime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Alarmlog::clear_dealtime() {
  if (dealtime_ != &::google::protobuf::internal::kEmptyString) {
    dealtime_->clear();
  }
  clear_has_dealtime();
}
inline const ::std::string& Alarmlog::dealtime() const {
  return *dealtime_;
}
inline void Alarmlog::set_dealtime(const ::std::string& value) {
  set_has_dealtime();
  if (dealtime_ == &::google::protobuf::internal::kEmptyString) {
    dealtime_ = new ::std::string;
  }
  dealtime_->assign(value);
}
inline void Alarmlog::set_dealtime(const char* value) {
  set_has_dealtime();
  if (dealtime_ == &::google::protobuf::internal::kEmptyString) {
    dealtime_ = new ::std::string;
  }
  dealtime_->assign(value);
}
inline void Alarmlog::set_dealtime(const char* value, size_t size) {
  set_has_dealtime();
  if (dealtime_ == &::google::protobuf::internal::kEmptyString) {
    dealtime_ = new ::std::string;
  }
  dealtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_dealtime() {
  set_has_dealtime();
  if (dealtime_ == &::google::protobuf::internal::kEmptyString) {
    dealtime_ = new ::std::string;
  }
  return dealtime_;
}
inline ::std::string* Alarmlog::release_dealtime() {
  clear_has_dealtime();
  if (dealtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealtime_;
    dealtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dealcomment = 16;
inline bool Alarmlog::has_dealcomment() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Alarmlog::set_has_dealcomment() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Alarmlog::clear_has_dealcomment() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Alarmlog::clear_dealcomment() {
  if (dealcomment_ != &::google::protobuf::internal::kEmptyString) {
    dealcomment_->clear();
  }
  clear_has_dealcomment();
}
inline const ::std::string& Alarmlog::dealcomment() const {
  return *dealcomment_;
}
inline void Alarmlog::set_dealcomment(const ::std::string& value) {
  set_has_dealcomment();
  if (dealcomment_ == &::google::protobuf::internal::kEmptyString) {
    dealcomment_ = new ::std::string;
  }
  dealcomment_->assign(value);
}
inline void Alarmlog::set_dealcomment(const char* value) {
  set_has_dealcomment();
  if (dealcomment_ == &::google::protobuf::internal::kEmptyString) {
    dealcomment_ = new ::std::string;
  }
  dealcomment_->assign(value);
}
inline void Alarmlog::set_dealcomment(const char* value, size_t size) {
  set_has_dealcomment();
  if (dealcomment_ == &::google::protobuf::internal::kEmptyString) {
    dealcomment_ = new ::std::string;
  }
  dealcomment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_dealcomment() {
  set_has_dealcomment();
  if (dealcomment_ == &::google::protobuf::internal::kEmptyString) {
    dealcomment_ = new ::std::string;
  }
  return dealcomment_;
}
inline ::std::string* Alarmlog::release_dealcomment() {
  clear_has_dealcomment();
  if (dealcomment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dealcomment_;
    dealcomment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 alarmlevel = 17;
inline bool Alarmlog::has_alarmlevel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Alarmlog::set_has_alarmlevel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Alarmlog::clear_has_alarmlevel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Alarmlog::clear_alarmlevel() {
  alarmlevel_ = 0;
  clear_has_alarmlevel();
}
inline ::google::protobuf::int32 Alarmlog::alarmlevel() const {
  return alarmlevel_;
}
inline void Alarmlog::set_alarmlevel(::google::protobuf::int32 value) {
  set_has_alarmlevel();
  alarmlevel_ = value;
}

// optional string strGuid = 18;
inline bool Alarmlog::has_strguid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Alarmlog::set_has_strguid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Alarmlog::clear_has_strguid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Alarmlog::clear_strguid() {
  if (strguid_ != &::google::protobuf::internal::kEmptyString) {
    strguid_->clear();
  }
  clear_has_strguid();
}
inline const ::std::string& Alarmlog::strguid() const {
  return *strguid_;
}
inline void Alarmlog::set_strguid(const ::std::string& value) {
  set_has_strguid();
  if (strguid_ == &::google::protobuf::internal::kEmptyString) {
    strguid_ = new ::std::string;
  }
  strguid_->assign(value);
}
inline void Alarmlog::set_strguid(const char* value) {
  set_has_strguid();
  if (strguid_ == &::google::protobuf::internal::kEmptyString) {
    strguid_ = new ::std::string;
  }
  strguid_->assign(value);
}
inline void Alarmlog::set_strguid(const char* value, size_t size) {
  set_has_strguid();
  if (strguid_ == &::google::protobuf::internal::kEmptyString) {
    strguid_ = new ::std::string;
  }
  strguid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alarmlog::mutable_strguid() {
  set_has_strguid();
  if (strguid_ == &::google::protobuf::internal::kEmptyString) {
    strguid_ = new ::std::string;
  }
  return strguid_;
}
inline ::std::string* Alarmlog::release_strguid() {
  clear_has_strguid();
  if (strguid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strguid_;
    strguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AlarmlogInfo

// optional int32 cmd = 1;
inline bool AlarmlogInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlarmlogInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlarmlogInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlarmlogInfo::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 AlarmlogInfo::cmd() const {
  return cmd_;
}
inline void AlarmlogInfo::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .cms_8120.Alarmlog alarmlog = 2;
inline bool AlarmlogInfo::has_alarmlog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlarmlogInfo::set_has_alarmlog() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlarmlogInfo::clear_has_alarmlog() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlarmlogInfo::clear_alarmlog() {
  if (alarmlog_ != NULL) alarmlog_->::cms_8120::Alarmlog::Clear();
  clear_has_alarmlog();
}
inline const ::cms_8120::Alarmlog& AlarmlogInfo::alarmlog() const {
  return alarmlog_ != NULL ? *alarmlog_ : *default_instance_->alarmlog_;
}
inline ::cms_8120::Alarmlog* AlarmlogInfo::mutable_alarmlog() {
  set_has_alarmlog();
  if (alarmlog_ == NULL) alarmlog_ = new ::cms_8120::Alarmlog;
  return alarmlog_;
}
inline ::cms_8120::Alarmlog* AlarmlogInfo::release_alarmlog() {
  clear_has_alarmlog();
  ::cms_8120::Alarmlog* temp = alarmlog_;
  alarmlog_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_center_2fAlarmlog_2eproto__INCLUDED
