// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: center/Clientinput.proto

#ifndef PROTOBUF_center_2fClientinput_2eproto__INCLUDED
#define PROTOBUF_center_2fClientinput_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_center_2fClientinput_2eproto();
void protobuf_AssignDesc_center_2fClientinput_2eproto();
void protobuf_ShutdownFile_center_2fClientinput_2eproto();

class Clientinput;

// ===================================================================

class Clientinput : public ::google::protobuf::Message {
 public:
  Clientinput();
  virtual ~Clientinput();
  
  Clientinput(const Clientinput& from);
  
  inline Clientinput& operator=(const Clientinput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Clientinput& default_instance();
  
  void Swap(Clientinput* other);
  
  // implements Message ----------------------------------------------
  
  Clientinput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clientinput& from);
  void MergeFrom(const Clientinput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string nProId = 2;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNProIdFieldNumber = 2;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string creditId = 4;
  inline bool has_creditid() const;
  inline void clear_creditid();
  static const int kCreditIdFieldNumber = 4;
  inline const ::std::string& creditid() const;
  inline void set_creditid(const ::std::string& value);
  inline void set_creditid(const char* value);
  inline void set_creditid(const char* value, size_t size);
  inline ::std::string* mutable_creditid();
  inline ::std::string* release_creditid();
  
  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional int32 productType = 6;
  inline bool has_producttype() const;
  inline void clear_producttype();
  static const int kProductTypeFieldNumber = 6;
  inline ::google::protobuf::int32 producttype() const;
  inline void set_producttype(::google::protobuf::int32 value);
  
  // optional string inputTime = 7;
  inline bool has_inputtime() const;
  inline void clear_inputtime();
  static const int kInputTimeFieldNumber = 7;
  inline const ::std::string& inputtime() const;
  inline void set_inputtime(const ::std::string& value);
  inline void set_inputtime(const char* value);
  inline void set_inputtime(const char* value, size_t size);
  inline ::std::string* mutable_inputtime();
  inline ::std::string* release_inputtime();
  
  // optional string inputUser = 8;
  inline bool has_inputuser() const;
  inline void clear_inputuser();
  static const int kInputUserFieldNumber = 8;
  inline const ::std::string& inputuser() const;
  inline void set_inputuser(const ::std::string& value);
  inline void set_inputuser(const char* value);
  inline void set_inputuser(const char* value, size_t size);
  inline ::std::string* mutable_inputuser();
  inline ::std::string* release_inputuser();
  
  // optional int32 inputRegionId = 9;
  inline bool has_inputregionid() const;
  inline void clear_inputregionid();
  static const int kInputRegionIdFieldNumber = 9;
  inline ::google::protobuf::int32 inputregionid() const;
  inline void set_inputregionid(::google::protobuf::int32 value);
  
  // optional string inputRegionName = 10;
  inline bool has_inputregionname() const;
  inline void clear_inputregionname();
  static const int kInputRegionNameFieldNumber = 10;
  inline const ::std::string& inputregionname() const;
  inline void set_inputregionname(const ::std::string& value);
  inline void set_inputregionname(const char* value);
  inline void set_inputregionname(const char* value, size_t size);
  inline ::std::string* mutable_inputregionname();
  inline ::std::string* release_inputregionname();
  
  // optional string proName = 11;
  inline bool has_proname() const;
  inline void clear_proname();
  static const int kProNameFieldNumber = 11;
  inline const ::std::string& proname() const;
  inline void set_proname(const ::std::string& value);
  inline void set_proname(const char* value);
  inline void set_proname(const char* value, size_t size);
  inline ::std::string* mutable_proname();
  inline ::std::string* release_proname();
  
  // optional string proUserNo = 12;
  inline bool has_prouserno() const;
  inline void clear_prouserno();
  static const int kProUserNoFieldNumber = 12;
  inline const ::std::string& prouserno() const;
  inline void set_prouserno(const ::std::string& value);
  inline void set_prouserno(const char* value);
  inline void set_prouserno(const char* value, size_t size);
  inline ::std::string* mutable_prouserno();
  inline ::std::string* release_prouserno();
  
  // optional string businessTime = 13 [default = "1970-01-01 00:00:00"];
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 13;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // optional string productName = 14;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 14;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string productCode = 15;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 15;
  inline const ::std::string& productcode() const;
  inline void set_productcode(const ::std::string& value);
  inline void set_productcode(const char* value);
  inline void set_productcode(const char* value, size_t size);
  inline ::std::string* mutable_productcode();
  inline ::std::string* release_productcode();
  
  // optional int32 productSaveMonth = 16;
  inline bool has_productsavemonth() const;
  inline void clear_productsavemonth();
  static const int kProductSaveMonthFieldNumber = 16;
  inline ::google::protobuf::int32 productsavemonth() const;
  inline void set_productsavemonth(::google::protobuf::int32 value);
  
  // optional string strEndDate = 17;
  inline bool has_strenddate() const;
  inline void clear_strenddate();
  static const int kStrEndDateFieldNumber = 17;
  inline const ::std::string& strenddate() const;
  inline void set_strenddate(const ::std::string& value);
  inline void set_strenddate(const char* value);
  inline void set_strenddate(const char* value, size_t size);
  inline ::std::string* mutable_strenddate();
  inline ::std::string* release_strenddate();
  
  // optional int32 guaranteeYears = 18;
  inline bool has_guaranteeyears() const;
  inline void clear_guaranteeyears();
  static const int kGuaranteeYearsFieldNumber = 18;
  inline ::google::protobuf::int32 guaranteeyears() const;
  inline void set_guaranteeyears(::google::protobuf::int32 value);
  
  // optional string strVideoEndDate = 19;
  inline bool has_strvideoenddate() const;
  inline void clear_strvideoenddate();
  static const int kStrVideoEndDateFieldNumber = 19;
  inline const ::std::string& strvideoenddate() const;
  inline void set_strvideoenddate(const ::std::string& value);
  inline void set_strvideoenddate(const char* value);
  inline void set_strvideoenddate(const char* value, size_t size);
  inline ::std::string* mutable_strvideoenddate();
  inline ::std::string* release_strvideoenddate();
  
  // optional int32 delaydays = 20;
  inline bool has_delaydays() const;
  inline void clear_delaydays();
  static const int kDelaydaysFieldNumber = 20;
  inline ::google::protobuf::int32 delaydays() const;
  inline void set_delaydays(::google::protobuf::int32 value);
  
  // optional int32 saveflag = 21;
  inline bool has_saveflag() const;
  inline void clear_saveflag();
  static const int kSaveflagFieldNumber = 21;
  inline ::google::protobuf::int32 saveflag() const;
  inline void set_saveflag(::google::protobuf::int32 value);
  
  // optional int32 tipflag = 22;
  inline bool has_tipflag() const;
  inline void clear_tipflag();
  static const int kTipflagFieldNumber = 22;
  inline ::google::protobuf::int32 tipflag() const;
  inline void set_tipflag(::google::protobuf::int32 value);
  
  // optional string markDate = 23;
  inline bool has_markdate() const;
  inline void clear_markdate();
  static const int kMarkDateFieldNumber = 23;
  inline const ::std::string& markdate() const;
  inline void set_markdate(const ::std::string& value);
  inline void set_markdate(const char* value);
  inline void set_markdate(const char* value, size_t size);
  inline ::std::string* mutable_markdate();
  inline ::std::string* release_markdate();
  
  // optional string creditCode = 24;
  inline bool has_creditcode() const;
  inline void clear_creditcode();
  static const int kCreditCodeFieldNumber = 24;
  inline const ::std::string& creditcode() const;
  inline void set_creditcode(const ::std::string& value);
  inline void set_creditcode(const char* value);
  inline void set_creditcode(const char* value, size_t size);
  inline ::std::string* mutable_creditcode();
  inline ::std::string* release_creditcode();
  
  // optional string strGrade = 25;
  inline bool has_strgrade() const;
  inline void clear_strgrade();
  static const int kStrGradeFieldNumber = 25;
  inline const ::std::string& strgrade() const;
  inline void set_strgrade(const ::std::string& value);
  inline void set_strgrade(const char* value);
  inline void set_strgrade(const char* value, size_t size);
  inline ::std::string* mutable_strgrade();
  inline ::std::string* release_strgrade();
  
  // optional string strRisklevel = 26;
  inline bool has_strrisklevel() const;
  inline void clear_strrisklevel();
  static const int kStrRisklevelFieldNumber = 26;
  inline const ::std::string& strrisklevel() const;
  inline void set_strrisklevel(const ::std::string& value);
  inline void set_strrisklevel(const char* value);
  inline void set_strrisklevel(const char* value, size_t size);
  inline ::std::string* mutable_strrisklevel();
  inline ::std::string* release_strrisklevel();
  
  // optional string strBankNo = 27;
  inline bool has_strbankno() const;
  inline void clear_strbankno();
  static const int kStrBankNoFieldNumber = 27;
  inline const ::std::string& strbankno() const;
  inline void set_strbankno(const ::std::string& value);
  inline void set_strbankno(const char* value);
  inline void set_strbankno(const char* value, size_t size);
  inline ::std::string* mutable_strbankno();
  inline ::std::string* release_strbankno();
  
  // optional string strBuyMoney = 28;
  inline bool has_strbuymoney() const;
  inline void clear_strbuymoney();
  static const int kStrBuyMoneyFieldNumber = 28;
  inline const ::std::string& strbuymoney() const;
  inline void set_strbuymoney(const ::std::string& value);
  inline void set_strbuymoney(const char* value);
  inline void set_strbuymoney(const char* value, size_t size);
  inline ::std::string* mutable_strbuymoney();
  inline ::std::string* release_strbuymoney();
  
  // optional string strRemarks = 29;
  inline bool has_strremarks() const;
  inline void clear_strremarks();
  static const int kStrRemarksFieldNumber = 29;
  inline const ::std::string& strremarks() const;
  inline void set_strremarks(const ::std::string& value);
  inline void set_strremarks(const char* value);
  inline void set_strremarks(const char* value, size_t size);
  inline ::std::string* mutable_strremarks();
  inline ::std::string* release_strremarks();
  
  // optional int32 nisUpload = 30;
  inline bool has_nisupload() const;
  inline void clear_nisupload();
  static const int kNisUploadFieldNumber = 30;
  inline ::google::protobuf::int32 nisupload() const;
  inline void set_nisupload(::google::protobuf::int32 value);
  
  // optional int32 nisPay = 31;
  inline bool has_nispay() const;
  inline void clear_nispay();
  static const int kNisPayFieldNumber = 31;
  inline ::google::protobuf::int32 nispay() const;
  inline void set_nispay(::google::protobuf::int32 value);
  
  // optional string strCreditPhone = 32;
  inline bool has_strcreditphone() const;
  inline void clear_strcreditphone();
  static const int kStrCreditPhoneFieldNumber = 32;
  inline const ::std::string& strcreditphone() const;
  inline void set_strcreditphone(const ::std::string& value);
  inline void set_strcreditphone(const char* value);
  inline void set_strcreditphone(const char* value, size_t size);
  inline ::std::string* mutable_strcreditphone();
  inline ::std::string* release_strcreditphone();
  
  // @@protoc_insertion_point(class_scope:cms_8120.Clientinput)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_creditid();
  inline void clear_has_creditid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_producttype();
  inline void clear_has_producttype();
  inline void set_has_inputtime();
  inline void clear_has_inputtime();
  inline void set_has_inputuser();
  inline void clear_has_inputuser();
  inline void set_has_inputregionid();
  inline void clear_has_inputregionid();
  inline void set_has_inputregionname();
  inline void clear_has_inputregionname();
  inline void set_has_proname();
  inline void clear_has_proname();
  inline void set_has_prouserno();
  inline void clear_has_prouserno();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_productsavemonth();
  inline void clear_has_productsavemonth();
  inline void set_has_strenddate();
  inline void clear_has_strenddate();
  inline void set_has_guaranteeyears();
  inline void clear_has_guaranteeyears();
  inline void set_has_strvideoenddate();
  inline void clear_has_strvideoenddate();
  inline void set_has_delaydays();
  inline void clear_has_delaydays();
  inline void set_has_saveflag();
  inline void clear_has_saveflag();
  inline void set_has_tipflag();
  inline void clear_has_tipflag();
  inline void set_has_markdate();
  inline void clear_has_markdate();
  inline void set_has_creditcode();
  inline void clear_has_creditcode();
  inline void set_has_strgrade();
  inline void clear_has_strgrade();
  inline void set_has_strrisklevel();
  inline void clear_has_strrisklevel();
  inline void set_has_strbankno();
  inline void clear_has_strbankno();
  inline void set_has_strbuymoney();
  inline void clear_has_strbuymoney();
  inline void set_has_strremarks();
  inline void clear_has_strremarks();
  inline void set_has_nisupload();
  inline void clear_has_nisupload();
  inline void set_has_nispay();
  inline void clear_has_nispay();
  inline void set_has_strcreditphone();
  inline void clear_has_strcreditphone();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nproid_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 status_;
  ::std::string* creditid_;
  ::std::string* inputtime_;
  ::google::protobuf::int32 producttype_;
  ::google::protobuf::int32 inputregionid_;
  ::std::string* inputuser_;
  ::std::string* inputregionname_;
  ::std::string* proname_;
  ::std::string* prouserno_;
  ::std::string* businesstime_;
  static const ::std::string _default_businesstime_;
  ::std::string* productname_;
  ::std::string* productcode_;
  ::std::string* strenddate_;
  ::google::protobuf::int32 productsavemonth_;
  ::google::protobuf::int32 guaranteeyears_;
  ::std::string* strvideoenddate_;
  ::google::protobuf::int32 delaydays_;
  ::google::protobuf::int32 saveflag_;
  ::std::string* markdate_;
  ::std::string* creditcode_;
  ::std::string* strgrade_;
  ::std::string* strrisklevel_;
  ::google::protobuf::int32 tipflag_;
  ::google::protobuf::int32 nisupload_;
  ::std::string* strbankno_;
  ::std::string* strbuymoney_;
  ::std::string* strremarks_;
  ::std::string* strcreditphone_;
  ::google::protobuf::int32 nispay_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fClientinput_2eproto();
  friend void protobuf_AssignDesc_center_2fClientinput_2eproto();
  friend void protobuf_ShutdownFile_center_2fClientinput_2eproto();
  
  void InitAsDefaultInstance();
  static Clientinput* default_instance_;
};
// ===================================================================


// ===================================================================

// Clientinput

// optional int32 id = 1;
inline bool Clientinput::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clientinput::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clientinput::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clientinput::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Clientinput::id() const {
  return id_;
}
inline void Clientinput::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string nProId = 2;
inline bool Clientinput::has_nproid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clientinput::set_has_nproid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clientinput::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clientinput::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& Clientinput::nproid() const {
  return *nproid_;
}
inline void Clientinput::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void Clientinput::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void Clientinput::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* Clientinput::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 3;
inline bool Clientinput::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Clientinput::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Clientinput::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Clientinput::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Clientinput::name() const {
  return *name_;
}
inline void Clientinput::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Clientinput::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Clientinput::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Clientinput::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditId = 4;
inline bool Clientinput::has_creditid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Clientinput::set_has_creditid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Clientinput::clear_has_creditid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Clientinput::clear_creditid() {
  if (creditid_ != &::google::protobuf::internal::kEmptyString) {
    creditid_->clear();
  }
  clear_has_creditid();
}
inline const ::std::string& Clientinput::creditid() const {
  return *creditid_;
}
inline void Clientinput::set_creditid(const ::std::string& value) {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  creditid_->assign(value);
}
inline void Clientinput::set_creditid(const char* value) {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  creditid_->assign(value);
}
inline void Clientinput::set_creditid(const char* value, size_t size) {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  creditid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_creditid() {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  return creditid_;
}
inline ::std::string* Clientinput::release_creditid() {
  clear_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditid_;
    creditid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 5;
inline bool Clientinput::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Clientinput::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Clientinput::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Clientinput::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Clientinput::status() const {
  return status_;
}
inline void Clientinput::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 productType = 6;
inline bool Clientinput::has_producttype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Clientinput::set_has_producttype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Clientinput::clear_has_producttype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Clientinput::clear_producttype() {
  producttype_ = 0;
  clear_has_producttype();
}
inline ::google::protobuf::int32 Clientinput::producttype() const {
  return producttype_;
}
inline void Clientinput::set_producttype(::google::protobuf::int32 value) {
  set_has_producttype();
  producttype_ = value;
}

// optional string inputTime = 7;
inline bool Clientinput::has_inputtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Clientinput::set_has_inputtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Clientinput::clear_has_inputtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Clientinput::clear_inputtime() {
  if (inputtime_ != &::google::protobuf::internal::kEmptyString) {
    inputtime_->clear();
  }
  clear_has_inputtime();
}
inline const ::std::string& Clientinput::inputtime() const {
  return *inputtime_;
}
inline void Clientinput::set_inputtime(const ::std::string& value) {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  inputtime_->assign(value);
}
inline void Clientinput::set_inputtime(const char* value) {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  inputtime_->assign(value);
}
inline void Clientinput::set_inputtime(const char* value, size_t size) {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  inputtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_inputtime() {
  set_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    inputtime_ = new ::std::string;
  }
  return inputtime_;
}
inline ::std::string* Clientinput::release_inputtime() {
  clear_has_inputtime();
  if (inputtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputtime_;
    inputtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string inputUser = 8;
inline bool Clientinput::has_inputuser() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Clientinput::set_has_inputuser() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Clientinput::clear_has_inputuser() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Clientinput::clear_inputuser() {
  if (inputuser_ != &::google::protobuf::internal::kEmptyString) {
    inputuser_->clear();
  }
  clear_has_inputuser();
}
inline const ::std::string& Clientinput::inputuser() const {
  return *inputuser_;
}
inline void Clientinput::set_inputuser(const ::std::string& value) {
  set_has_inputuser();
  if (inputuser_ == &::google::protobuf::internal::kEmptyString) {
    inputuser_ = new ::std::string;
  }
  inputuser_->assign(value);
}
inline void Clientinput::set_inputuser(const char* value) {
  set_has_inputuser();
  if (inputuser_ == &::google::protobuf::internal::kEmptyString) {
    inputuser_ = new ::std::string;
  }
  inputuser_->assign(value);
}
inline void Clientinput::set_inputuser(const char* value, size_t size) {
  set_has_inputuser();
  if (inputuser_ == &::google::protobuf::internal::kEmptyString) {
    inputuser_ = new ::std::string;
  }
  inputuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_inputuser() {
  set_has_inputuser();
  if (inputuser_ == &::google::protobuf::internal::kEmptyString) {
    inputuser_ = new ::std::string;
  }
  return inputuser_;
}
inline ::std::string* Clientinput::release_inputuser() {
  clear_has_inputuser();
  if (inputuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputuser_;
    inputuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 inputRegionId = 9;
inline bool Clientinput::has_inputregionid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Clientinput::set_has_inputregionid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Clientinput::clear_has_inputregionid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Clientinput::clear_inputregionid() {
  inputregionid_ = 0;
  clear_has_inputregionid();
}
inline ::google::protobuf::int32 Clientinput::inputregionid() const {
  return inputregionid_;
}
inline void Clientinput::set_inputregionid(::google::protobuf::int32 value) {
  set_has_inputregionid();
  inputregionid_ = value;
}

// optional string inputRegionName = 10;
inline bool Clientinput::has_inputregionname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Clientinput::set_has_inputregionname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Clientinput::clear_has_inputregionname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Clientinput::clear_inputregionname() {
  if (inputregionname_ != &::google::protobuf::internal::kEmptyString) {
    inputregionname_->clear();
  }
  clear_has_inputregionname();
}
inline const ::std::string& Clientinput::inputregionname() const {
  return *inputregionname_;
}
inline void Clientinput::set_inputregionname(const ::std::string& value) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(value);
}
inline void Clientinput::set_inputregionname(const char* value) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(value);
}
inline void Clientinput::set_inputregionname(const char* value, size_t size) {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  inputregionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_inputregionname() {
  set_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    inputregionname_ = new ::std::string;
  }
  return inputregionname_;
}
inline ::std::string* Clientinput::release_inputregionname() {
  clear_has_inputregionname();
  if (inputregionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inputregionname_;
    inputregionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proName = 11;
inline bool Clientinput::has_proname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Clientinput::set_has_proname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Clientinput::clear_has_proname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Clientinput::clear_proname() {
  if (proname_ != &::google::protobuf::internal::kEmptyString) {
    proname_->clear();
  }
  clear_has_proname();
}
inline const ::std::string& Clientinput::proname() const {
  return *proname_;
}
inline void Clientinput::set_proname(const ::std::string& value) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(value);
}
inline void Clientinput::set_proname(const char* value) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(value);
}
inline void Clientinput::set_proname(const char* value, size_t size) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_proname() {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  return proname_;
}
inline ::std::string* Clientinput::release_proname() {
  clear_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proname_;
    proname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proUserNo = 12;
inline bool Clientinput::has_prouserno() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Clientinput::set_has_prouserno() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Clientinput::clear_has_prouserno() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Clientinput::clear_prouserno() {
  if (prouserno_ != &::google::protobuf::internal::kEmptyString) {
    prouserno_->clear();
  }
  clear_has_prouserno();
}
inline const ::std::string& Clientinput::prouserno() const {
  return *prouserno_;
}
inline void Clientinput::set_prouserno(const ::std::string& value) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(value);
}
inline void Clientinput::set_prouserno(const char* value) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(value);
}
inline void Clientinput::set_prouserno(const char* value, size_t size) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_prouserno() {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  return prouserno_;
}
inline ::std::string* Clientinput::release_prouserno() {
  clear_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prouserno_;
    prouserno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string businessTime = 13 [default = "1970-01-01 00:00:00"];
inline bool Clientinput::has_businesstime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Clientinput::set_has_businesstime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Clientinput::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Clientinput::clear_businesstime() {
  if (businesstime_ != &_default_businesstime_) {
    businesstime_->assign(_default_businesstime_);
  }
  clear_has_businesstime();
}
inline const ::std::string& Clientinput::businesstime() const {
  return *businesstime_;
}
inline void Clientinput::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &_default_businesstime_) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void Clientinput::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &_default_businesstime_) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void Clientinput::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &_default_businesstime_) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &_default_businesstime_) {
    businesstime_ = new ::std::string(_default_businesstime_);
  }
  return businesstime_;
}
inline ::std::string* Clientinput::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &_default_businesstime_) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&_default_businesstime_);
    return temp;
  }
}

// optional string productName = 14;
inline bool Clientinput::has_productname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Clientinput::set_has_productname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Clientinput::clear_has_productname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Clientinput::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& Clientinput::productname() const {
  return *productname_;
}
inline void Clientinput::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void Clientinput::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void Clientinput::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* Clientinput::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productCode = 15;
inline bool Clientinput::has_productcode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Clientinput::set_has_productcode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Clientinput::clear_has_productcode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Clientinput::clear_productcode() {
  if (productcode_ != &::google::protobuf::internal::kEmptyString) {
    productcode_->clear();
  }
  clear_has_productcode();
}
inline const ::std::string& Clientinput::productcode() const {
  return *productcode_;
}
inline void Clientinput::set_productcode(const ::std::string& value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void Clientinput::set_productcode(const char* value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void Clientinput::set_productcode(const char* value, size_t size) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_productcode() {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  return productcode_;
}
inline ::std::string* Clientinput::release_productcode() {
  clear_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productcode_;
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productSaveMonth = 16;
inline bool Clientinput::has_productsavemonth() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Clientinput::set_has_productsavemonth() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Clientinput::clear_has_productsavemonth() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Clientinput::clear_productsavemonth() {
  productsavemonth_ = 0;
  clear_has_productsavemonth();
}
inline ::google::protobuf::int32 Clientinput::productsavemonth() const {
  return productsavemonth_;
}
inline void Clientinput::set_productsavemonth(::google::protobuf::int32 value) {
  set_has_productsavemonth();
  productsavemonth_ = value;
}

// optional string strEndDate = 17;
inline bool Clientinput::has_strenddate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Clientinput::set_has_strenddate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Clientinput::clear_has_strenddate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Clientinput::clear_strenddate() {
  if (strenddate_ != &::google::protobuf::internal::kEmptyString) {
    strenddate_->clear();
  }
  clear_has_strenddate();
}
inline const ::std::string& Clientinput::strenddate() const {
  return *strenddate_;
}
inline void Clientinput::set_strenddate(const ::std::string& value) {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  strenddate_->assign(value);
}
inline void Clientinput::set_strenddate(const char* value) {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  strenddate_->assign(value);
}
inline void Clientinput::set_strenddate(const char* value, size_t size) {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  strenddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strenddate() {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  return strenddate_;
}
inline ::std::string* Clientinput::release_strenddate() {
  clear_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strenddate_;
    strenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 guaranteeYears = 18;
inline bool Clientinput::has_guaranteeyears() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Clientinput::set_has_guaranteeyears() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Clientinput::clear_has_guaranteeyears() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Clientinput::clear_guaranteeyears() {
  guaranteeyears_ = 0;
  clear_has_guaranteeyears();
}
inline ::google::protobuf::int32 Clientinput::guaranteeyears() const {
  return guaranteeyears_;
}
inline void Clientinput::set_guaranteeyears(::google::protobuf::int32 value) {
  set_has_guaranteeyears();
  guaranteeyears_ = value;
}

// optional string strVideoEndDate = 19;
inline bool Clientinput::has_strvideoenddate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Clientinput::set_has_strvideoenddate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Clientinput::clear_has_strvideoenddate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Clientinput::clear_strvideoenddate() {
  if (strvideoenddate_ != &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_->clear();
  }
  clear_has_strvideoenddate();
}
inline const ::std::string& Clientinput::strvideoenddate() const {
  return *strvideoenddate_;
}
inline void Clientinput::set_strvideoenddate(const ::std::string& value) {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  strvideoenddate_->assign(value);
}
inline void Clientinput::set_strvideoenddate(const char* value) {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  strvideoenddate_->assign(value);
}
inline void Clientinput::set_strvideoenddate(const char* value, size_t size) {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  strvideoenddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strvideoenddate() {
  set_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    strvideoenddate_ = new ::std::string;
  }
  return strvideoenddate_;
}
inline ::std::string* Clientinput::release_strvideoenddate() {
  clear_has_strvideoenddate();
  if (strvideoenddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strvideoenddate_;
    strvideoenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 delaydays = 20;
inline bool Clientinput::has_delaydays() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Clientinput::set_has_delaydays() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Clientinput::clear_has_delaydays() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Clientinput::clear_delaydays() {
  delaydays_ = 0;
  clear_has_delaydays();
}
inline ::google::protobuf::int32 Clientinput::delaydays() const {
  return delaydays_;
}
inline void Clientinput::set_delaydays(::google::protobuf::int32 value) {
  set_has_delaydays();
  delaydays_ = value;
}

// optional int32 saveflag = 21;
inline bool Clientinput::has_saveflag() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Clientinput::set_has_saveflag() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Clientinput::clear_has_saveflag() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Clientinput::clear_saveflag() {
  saveflag_ = 0;
  clear_has_saveflag();
}
inline ::google::protobuf::int32 Clientinput::saveflag() const {
  return saveflag_;
}
inline void Clientinput::set_saveflag(::google::protobuf::int32 value) {
  set_has_saveflag();
  saveflag_ = value;
}

// optional int32 tipflag = 22;
inline bool Clientinput::has_tipflag() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Clientinput::set_has_tipflag() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Clientinput::clear_has_tipflag() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Clientinput::clear_tipflag() {
  tipflag_ = 0;
  clear_has_tipflag();
}
inline ::google::protobuf::int32 Clientinput::tipflag() const {
  return tipflag_;
}
inline void Clientinput::set_tipflag(::google::protobuf::int32 value) {
  set_has_tipflag();
  tipflag_ = value;
}

// optional string markDate = 23;
inline bool Clientinput::has_markdate() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Clientinput::set_has_markdate() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Clientinput::clear_has_markdate() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Clientinput::clear_markdate() {
  if (markdate_ != &::google::protobuf::internal::kEmptyString) {
    markdate_->clear();
  }
  clear_has_markdate();
}
inline const ::std::string& Clientinput::markdate() const {
  return *markdate_;
}
inline void Clientinput::set_markdate(const ::std::string& value) {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  markdate_->assign(value);
}
inline void Clientinput::set_markdate(const char* value) {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  markdate_->assign(value);
}
inline void Clientinput::set_markdate(const char* value, size_t size) {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  markdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_markdate() {
  set_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    markdate_ = new ::std::string;
  }
  return markdate_;
}
inline ::std::string* Clientinput::release_markdate() {
  clear_has_markdate();
  if (markdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = markdate_;
    markdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditCode = 24;
inline bool Clientinput::has_creditcode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Clientinput::set_has_creditcode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Clientinput::clear_has_creditcode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Clientinput::clear_creditcode() {
  if (creditcode_ != &::google::protobuf::internal::kEmptyString) {
    creditcode_->clear();
  }
  clear_has_creditcode();
}
inline const ::std::string& Clientinput::creditcode() const {
  return *creditcode_;
}
inline void Clientinput::set_creditcode(const ::std::string& value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void Clientinput::set_creditcode(const char* value) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(value);
}
inline void Clientinput::set_creditcode(const char* value, size_t size) {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  creditcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_creditcode() {
  set_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    creditcode_ = new ::std::string;
  }
  return creditcode_;
}
inline ::std::string* Clientinput::release_creditcode() {
  clear_has_creditcode();
  if (creditcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditcode_;
    creditcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strGrade = 25;
inline bool Clientinput::has_strgrade() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Clientinput::set_has_strgrade() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Clientinput::clear_has_strgrade() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Clientinput::clear_strgrade() {
  if (strgrade_ != &::google::protobuf::internal::kEmptyString) {
    strgrade_->clear();
  }
  clear_has_strgrade();
}
inline const ::std::string& Clientinput::strgrade() const {
  return *strgrade_;
}
inline void Clientinput::set_strgrade(const ::std::string& value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void Clientinput::set_strgrade(const char* value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void Clientinput::set_strgrade(const char* value, size_t size) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strgrade() {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  return strgrade_;
}
inline ::std::string* Clientinput::release_strgrade() {
  clear_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgrade_;
    strgrade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strRisklevel = 26;
inline bool Clientinput::has_strrisklevel() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Clientinput::set_has_strrisklevel() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Clientinput::clear_has_strrisklevel() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Clientinput::clear_strrisklevel() {
  if (strrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    strrisklevel_->clear();
  }
  clear_has_strrisklevel();
}
inline const ::std::string& Clientinput::strrisklevel() const {
  return *strrisklevel_;
}
inline void Clientinput::set_strrisklevel(const ::std::string& value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void Clientinput::set_strrisklevel(const char* value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void Clientinput::set_strrisklevel(const char* value, size_t size) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strrisklevel() {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  return strrisklevel_;
}
inline ::std::string* Clientinput::release_strrisklevel() {
  clear_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrisklevel_;
    strrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBankNo = 27;
inline bool Clientinput::has_strbankno() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Clientinput::set_has_strbankno() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Clientinput::clear_has_strbankno() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Clientinput::clear_strbankno() {
  if (strbankno_ != &::google::protobuf::internal::kEmptyString) {
    strbankno_->clear();
  }
  clear_has_strbankno();
}
inline const ::std::string& Clientinput::strbankno() const {
  return *strbankno_;
}
inline void Clientinput::set_strbankno(const ::std::string& value) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(value);
}
inline void Clientinput::set_strbankno(const char* value) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(value);
}
inline void Clientinput::set_strbankno(const char* value, size_t size) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strbankno() {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  return strbankno_;
}
inline ::std::string* Clientinput::release_strbankno() {
  clear_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbankno_;
    strbankno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBuyMoney = 28;
inline bool Clientinput::has_strbuymoney() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Clientinput::set_has_strbuymoney() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Clientinput::clear_has_strbuymoney() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Clientinput::clear_strbuymoney() {
  if (strbuymoney_ != &::google::protobuf::internal::kEmptyString) {
    strbuymoney_->clear();
  }
  clear_has_strbuymoney();
}
inline const ::std::string& Clientinput::strbuymoney() const {
  return *strbuymoney_;
}
inline void Clientinput::set_strbuymoney(const ::std::string& value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void Clientinput::set_strbuymoney(const char* value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void Clientinput::set_strbuymoney(const char* value, size_t size) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strbuymoney() {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  return strbuymoney_;
}
inline ::std::string* Clientinput::release_strbuymoney() {
  clear_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbuymoney_;
    strbuymoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strRemarks = 29;
inline bool Clientinput::has_strremarks() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Clientinput::set_has_strremarks() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Clientinput::clear_has_strremarks() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Clientinput::clear_strremarks() {
  if (strremarks_ != &::google::protobuf::internal::kEmptyString) {
    strremarks_->clear();
  }
  clear_has_strremarks();
}
inline const ::std::string& Clientinput::strremarks() const {
  return *strremarks_;
}
inline void Clientinput::set_strremarks(const ::std::string& value) {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  strremarks_->assign(value);
}
inline void Clientinput::set_strremarks(const char* value) {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  strremarks_->assign(value);
}
inline void Clientinput::set_strremarks(const char* value, size_t size) {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  strremarks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strremarks() {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  return strremarks_;
}
inline ::std::string* Clientinput::release_strremarks() {
  clear_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strremarks_;
    strremarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nisUpload = 30;
inline bool Clientinput::has_nisupload() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Clientinput::set_has_nisupload() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Clientinput::clear_has_nisupload() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Clientinput::clear_nisupload() {
  nisupload_ = 0;
  clear_has_nisupload();
}
inline ::google::protobuf::int32 Clientinput::nisupload() const {
  return nisupload_;
}
inline void Clientinput::set_nisupload(::google::protobuf::int32 value) {
  set_has_nisupload();
  nisupload_ = value;
}

// optional int32 nisPay = 31;
inline bool Clientinput::has_nispay() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Clientinput::set_has_nispay() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Clientinput::clear_has_nispay() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Clientinput::clear_nispay() {
  nispay_ = 0;
  clear_has_nispay();
}
inline ::google::protobuf::int32 Clientinput::nispay() const {
  return nispay_;
}
inline void Clientinput::set_nispay(::google::protobuf::int32 value) {
  set_has_nispay();
  nispay_ = value;
}

// optional string strCreditPhone = 32;
inline bool Clientinput::has_strcreditphone() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Clientinput::set_has_strcreditphone() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Clientinput::clear_has_strcreditphone() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Clientinput::clear_strcreditphone() {
  if (strcreditphone_ != &::google::protobuf::internal::kEmptyString) {
    strcreditphone_->clear();
  }
  clear_has_strcreditphone();
}
inline const ::std::string& Clientinput::strcreditphone() const {
  return *strcreditphone_;
}
inline void Clientinput::set_strcreditphone(const ::std::string& value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void Clientinput::set_strcreditphone(const char* value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void Clientinput::set_strcreditphone(const char* value, size_t size) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clientinput::mutable_strcreditphone() {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  return strcreditphone_;
}
inline ::std::string* Clientinput::release_strcreditphone() {
  clear_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcreditphone_;
    strcreditphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_center_2fClientinput_2eproto__INCLUDED
