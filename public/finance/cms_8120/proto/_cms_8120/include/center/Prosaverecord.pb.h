// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: center/Prosaverecord.proto

#ifndef PROTOBUF_center_2fProsaverecord_2eproto__INCLUDED
#define PROTOBUF_center_2fProsaverecord_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "server/RspServerData.pb.h"
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_center_2fProsaverecord_2eproto();
void protobuf_AssignDesc_center_2fProsaverecord_2eproto();
void protobuf_ShutdownFile_center_2fProsaverecord_2eproto();

class Prosaverecord;
class ReqProsaverecord;
class ProsaverecordList;

// ===================================================================

class Prosaverecord : public ::google::protobuf::Message {
 public:
  Prosaverecord();
  virtual ~Prosaverecord();
  
  Prosaverecord(const Prosaverecord& from);
  
  inline Prosaverecord& operator=(const Prosaverecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Prosaverecord& default_instance();
  
  void Swap(Prosaverecord* other);
  
  // implements Message ----------------------------------------------
  
  Prosaverecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Prosaverecord& from);
  void MergeFrom(const Prosaverecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 clientId = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 2;
  inline ::google::protobuf::int32 clientid() const;
  inline void set_clientid(::google::protobuf::int32 value);
  
  // optional string recordId = 3;
  inline bool has_recordid() const;
  inline void clear_recordid();
  static const int kRecordIdFieldNumber = 3;
  inline const ::std::string& recordid() const;
  inline void set_recordid(const ::std::string& value);
  inline void set_recordid(const char* value);
  inline void set_recordid(const char* value, size_t size);
  inline ::std::string* mutable_recordid();
  inline ::std::string* release_recordid();
  
  // optional int32 regionId = 4;
  inline bool has_regionid() const;
  inline void clear_regionid();
  static const int kRegionIdFieldNumber = 4;
  inline ::google::protobuf::int32 regionid() const;
  inline void set_regionid(::google::protobuf::int32 value);
  
  // optional int32 cvr = 5;
  inline bool has_cvr() const;
  inline void clear_cvr();
  static const int kCvrFieldNumber = 5;
  inline ::google::protobuf::int32 cvr() const;
  inline void set_cvr(::google::protobuf::int32 value);
  
  // optional string streamNo = 6;
  inline bool has_streamno() const;
  inline void clear_streamno();
  static const int kStreamNoFieldNumber = 6;
  inline const ::std::string& streamno() const;
  inline void set_streamno(const ::std::string& value);
  inline void set_streamno(const char* value);
  inline void set_streamno(const char* value, size_t size);
  inline ::std::string* mutable_streamno();
  inline ::std::string* release_streamno();
  
  // optional int32 nType = 7;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 7;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);
  
  // optional int32 mediaType = 8;
  inline bool has_mediatype() const;
  inline void clear_mediatype();
  static const int kMediaTypeFieldNumber = 8;
  inline ::google::protobuf::int32 mediatype() const;
  inline void set_mediatype(::google::protobuf::int32 value);
  
  // optional int32 calltype = 9;
  inline bool has_calltype() const;
  inline void clear_calltype();
  static const int kCalltypeFieldNumber = 9;
  inline ::google::protobuf::int32 calltype() const;
  inline void set_calltype(::google::protobuf::int32 value);
  
  // optional string callNo = 10;
  inline bool has_callno() const;
  inline void clear_callno();
  static const int kCallNoFieldNumber = 10;
  inline const ::std::string& callno() const;
  inline void set_callno(const ::std::string& value);
  inline void set_callno(const char* value);
  inline void set_callno(const char* value, size_t size);
  inline ::std::string* mutable_callno();
  inline ::std::string* release_callno();
  
  // optional string recordUserNo = 11;
  inline bool has_recorduserno() const;
  inline void clear_recorduserno();
  static const int kRecordUserNoFieldNumber = 11;
  inline const ::std::string& recorduserno() const;
  inline void set_recorduserno(const ::std::string& value);
  inline void set_recorduserno(const char* value);
  inline void set_recorduserno(const char* value, size_t size);
  inline ::std::string* mutable_recorduserno();
  inline ::std::string* release_recorduserno();
  
  // optional int32 stateType = 12;
  inline bool has_statetype() const;
  inline void clear_statetype();
  static const int kStateTypeFieldNumber = 12;
  inline ::google::protobuf::int32 statetype() const;
  inline void set_statetype(::google::protobuf::int32 value);
  
  // optional string startTime = 13 [default = "1970-01-01 00:00:00"];
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 13;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  
  // optional string endTime = 14 [default = "1970-01-01 00:00:00"];
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 14;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  
  // optional string fileName = 15;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 15;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional string devIp = 16;
  inline bool has_devip() const;
  inline void clear_devip();
  static const int kDevIpFieldNumber = 16;
  inline const ::std::string& devip() const;
  inline void set_devip(const ::std::string& value);
  inline void set_devip(const char* value);
  inline void set_devip(const char* value, size_t size);
  inline ::std::string* mutable_devip();
  inline ::std::string* release_devip();
  
  // optional int32 devId = 17;
  inline bool has_devid() const;
  inline void clear_devid();
  static const int kDevIdFieldNumber = 17;
  inline ::google::protobuf::int32 devid() const;
  inline void set_devid(::google::protobuf::int32 value);
  
  // optional int32 devChannel = 18;
  inline bool has_devchannel() const;
  inline void clear_devchannel();
  static const int kDevChannelFieldNumber = 18;
  inline ::google::protobuf::int32 devchannel() const;
  inline void set_devchannel(::google::protobuf::int32 value);
  
  // optional int32 locked = 19;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 19;
  inline ::google::protobuf::int32 locked() const;
  inline void set_locked(::google::protobuf::int32 value);
  
  // optional int32 upload = 20;
  inline bool has_upload() const;
  inline void clear_upload();
  static const int kUploadFieldNumber = 20;
  inline ::google::protobuf::int32 upload() const;
  inline void set_upload(::google::protobuf::int32 value);
  
  // optional string strBucket = 21;
  inline bool has_strbucket() const;
  inline void clear_strbucket();
  static const int kStrBucketFieldNumber = 21;
  inline const ::std::string& strbucket() const;
  inline void set_strbucket(const ::std::string& value);
  inline void set_strbucket(const char* value);
  inline void set_strbucket(const char* value, size_t size);
  inline ::std::string* mutable_strbucket();
  inline ::std::string* release_strbucket();
  
  // @@protoc_insertion_point(class_scope:cms_8120.Prosaverecord)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_recordid();
  inline void clear_has_recordid();
  inline void set_has_regionid();
  inline void clear_has_regionid();
  inline void set_has_cvr();
  inline void clear_has_cvr();
  inline void set_has_streamno();
  inline void clear_has_streamno();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_mediatype();
  inline void clear_has_mediatype();
  inline void set_has_calltype();
  inline void clear_has_calltype();
  inline void set_has_callno();
  inline void clear_has_callno();
  inline void set_has_recorduserno();
  inline void clear_has_recorduserno();
  inline void set_has_statetype();
  inline void clear_has_statetype();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_devip();
  inline void clear_has_devip();
  inline void set_has_devid();
  inline void clear_has_devid();
  inline void set_has_devchannel();
  inline void clear_has_devchannel();
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_upload();
  inline void clear_has_upload();
  inline void set_has_strbucket();
  inline void clear_has_strbucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 clientid_;
  ::std::string* recordid_;
  ::google::protobuf::int32 regionid_;
  ::google::protobuf::int32 cvr_;
  ::std::string* streamno_;
  ::google::protobuf::int32 ntype_;
  ::google::protobuf::int32 mediatype_;
  ::std::string* callno_;
  ::google::protobuf::int32 calltype_;
  ::google::protobuf::int32 statetype_;
  ::std::string* recorduserno_;
  ::std::string* starttime_;
  static const ::std::string _default_starttime_;
  ::std::string* endtime_;
  static const ::std::string _default_endtime_;
  ::std::string* filename_;
  ::std::string* devip_;
  ::google::protobuf::int32 devid_;
  ::google::protobuf::int32 devchannel_;
  ::google::protobuf::int32 locked_;
  ::google::protobuf::int32 upload_;
  ::std::string* strbucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fProsaverecord_2eproto();
  friend void protobuf_AssignDesc_center_2fProsaverecord_2eproto();
  friend void protobuf_ShutdownFile_center_2fProsaverecord_2eproto();
  
  void InitAsDefaultInstance();
  static Prosaverecord* default_instance_;
};
// -------------------------------------------------------------------

class ReqProsaverecord : public ::google::protobuf::Message {
 public:
  ReqProsaverecord();
  virtual ~ReqProsaverecord();
  
  ReqProsaverecord(const ReqProsaverecord& from);
  
  inline ReqProsaverecord& operator=(const ReqProsaverecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqProsaverecord& default_instance();
  
  void Swap(ReqProsaverecord* other);
  
  // implements Message ----------------------------------------------
  
  ReqProsaverecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqProsaverecord& from);
  void MergeFrom(const ReqProsaverecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 clientId = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 3;
  inline ::google::protobuf::int32 clientid() const;
  inline void set_clientid(::google::protobuf::int32 value);
  
  // optional string strIds = 4;
  inline bool has_strids() const;
  inline void clear_strids();
  static const int kStrIdsFieldNumber = 4;
  inline const ::std::string& strids() const;
  inline void set_strids(const ::std::string& value);
  inline void set_strids(const char* value);
  inline void set_strids(const char* value, size_t size);
  inline ::std::string* mutable_strids();
  inline ::std::string* release_strids();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqProsaverecord)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_strids();
  inline void clear_has_strids();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 id_;
  ::std::string* strids_;
  ::google::protobuf::int32 clientid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fProsaverecord_2eproto();
  friend void protobuf_AssignDesc_center_2fProsaverecord_2eproto();
  friend void protobuf_ShutdownFile_center_2fProsaverecord_2eproto();
  
  void InitAsDefaultInstance();
  static ReqProsaverecord* default_instance_;
};
// -------------------------------------------------------------------

class ProsaverecordList : public ::google::protobuf::Message {
 public:
  ProsaverecordList();
  virtual ~ProsaverecordList();
  
  ProsaverecordList(const ProsaverecordList& from);
  
  inline ProsaverecordList& operator=(const ProsaverecordList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProsaverecordList& default_instance();
  
  void Swap(ProsaverecordList* other);
  
  // implements Message ----------------------------------------------
  
  ProsaverecordList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProsaverecordList& from);
  void MergeFrom(const ProsaverecordList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // repeated .cms_8120.Prosaverecord prosaverecord = 2;
  inline int prosaverecord_size() const;
  inline void clear_prosaverecord();
  static const int kProsaverecordFieldNumber = 2;
  inline const ::cms_8120::Prosaverecord& prosaverecord(int index) const;
  inline ::cms_8120::Prosaverecord* mutable_prosaverecord(int index);
  inline ::cms_8120::Prosaverecord* add_prosaverecord();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::Prosaverecord >&
      prosaverecord() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::Prosaverecord >*
      mutable_prosaverecord();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ProsaverecordList)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::cms_8120::Prosaverecord > prosaverecord_;
  ::google::protobuf::int32 cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fProsaverecord_2eproto();
  friend void protobuf_AssignDesc_center_2fProsaverecord_2eproto();
  friend void protobuf_ShutdownFile_center_2fProsaverecord_2eproto();
  
  void InitAsDefaultInstance();
  static ProsaverecordList* default_instance_;
};
// ===================================================================


// ===================================================================

// Prosaverecord

// optional int32 id = 1;
inline bool Prosaverecord::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prosaverecord::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prosaverecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prosaverecord::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Prosaverecord::id() const {
  return id_;
}
inline void Prosaverecord::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 clientId = 2;
inline bool Prosaverecord::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prosaverecord::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prosaverecord::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prosaverecord::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 Prosaverecord::clientid() const {
  return clientid_;
}
inline void Prosaverecord::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string recordId = 3;
inline bool Prosaverecord::has_recordid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Prosaverecord::set_has_recordid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Prosaverecord::clear_has_recordid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Prosaverecord::clear_recordid() {
  if (recordid_ != &::google::protobuf::internal::kEmptyString) {
    recordid_->clear();
  }
  clear_has_recordid();
}
inline const ::std::string& Prosaverecord::recordid() const {
  return *recordid_;
}
inline void Prosaverecord::set_recordid(const ::std::string& value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void Prosaverecord::set_recordid(const char* value) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(value);
}
inline void Prosaverecord::set_recordid(const char* value, size_t size) {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  recordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_recordid() {
  set_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    recordid_ = new ::std::string;
  }
  return recordid_;
}
inline ::std::string* Prosaverecord::release_recordid() {
  clear_has_recordid();
  if (recordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recordid_;
    recordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 regionId = 4;
inline bool Prosaverecord::has_regionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Prosaverecord::set_has_regionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Prosaverecord::clear_has_regionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Prosaverecord::clear_regionid() {
  regionid_ = 0;
  clear_has_regionid();
}
inline ::google::protobuf::int32 Prosaverecord::regionid() const {
  return regionid_;
}
inline void Prosaverecord::set_regionid(::google::protobuf::int32 value) {
  set_has_regionid();
  regionid_ = value;
}

// optional int32 cvr = 5;
inline bool Prosaverecord::has_cvr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Prosaverecord::set_has_cvr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Prosaverecord::clear_has_cvr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Prosaverecord::clear_cvr() {
  cvr_ = 0;
  clear_has_cvr();
}
inline ::google::protobuf::int32 Prosaverecord::cvr() const {
  return cvr_;
}
inline void Prosaverecord::set_cvr(::google::protobuf::int32 value) {
  set_has_cvr();
  cvr_ = value;
}

// optional string streamNo = 6;
inline bool Prosaverecord::has_streamno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Prosaverecord::set_has_streamno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Prosaverecord::clear_has_streamno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Prosaverecord::clear_streamno() {
  if (streamno_ != &::google::protobuf::internal::kEmptyString) {
    streamno_->clear();
  }
  clear_has_streamno();
}
inline const ::std::string& Prosaverecord::streamno() const {
  return *streamno_;
}
inline void Prosaverecord::set_streamno(const ::std::string& value) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(value);
}
inline void Prosaverecord::set_streamno(const char* value) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(value);
}
inline void Prosaverecord::set_streamno(const char* value, size_t size) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_streamno() {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  return streamno_;
}
inline ::std::string* Prosaverecord::release_streamno() {
  clear_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamno_;
    streamno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nType = 7;
inline bool Prosaverecord::has_ntype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Prosaverecord::set_has_ntype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Prosaverecord::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Prosaverecord::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 Prosaverecord::ntype() const {
  return ntype_;
}
inline void Prosaverecord::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// optional int32 mediaType = 8;
inline bool Prosaverecord::has_mediatype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Prosaverecord::set_has_mediatype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Prosaverecord::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Prosaverecord::clear_mediatype() {
  mediatype_ = 0;
  clear_has_mediatype();
}
inline ::google::protobuf::int32 Prosaverecord::mediatype() const {
  return mediatype_;
}
inline void Prosaverecord::set_mediatype(::google::protobuf::int32 value) {
  set_has_mediatype();
  mediatype_ = value;
}

// optional int32 calltype = 9;
inline bool Prosaverecord::has_calltype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Prosaverecord::set_has_calltype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Prosaverecord::clear_has_calltype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Prosaverecord::clear_calltype() {
  calltype_ = 0;
  clear_has_calltype();
}
inline ::google::protobuf::int32 Prosaverecord::calltype() const {
  return calltype_;
}
inline void Prosaverecord::set_calltype(::google::protobuf::int32 value) {
  set_has_calltype();
  calltype_ = value;
}

// optional string callNo = 10;
inline bool Prosaverecord::has_callno() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Prosaverecord::set_has_callno() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Prosaverecord::clear_has_callno() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Prosaverecord::clear_callno() {
  if (callno_ != &::google::protobuf::internal::kEmptyString) {
    callno_->clear();
  }
  clear_has_callno();
}
inline const ::std::string& Prosaverecord::callno() const {
  return *callno_;
}
inline void Prosaverecord::set_callno(const ::std::string& value) {
  set_has_callno();
  if (callno_ == &::google::protobuf::internal::kEmptyString) {
    callno_ = new ::std::string;
  }
  callno_->assign(value);
}
inline void Prosaverecord::set_callno(const char* value) {
  set_has_callno();
  if (callno_ == &::google::protobuf::internal::kEmptyString) {
    callno_ = new ::std::string;
  }
  callno_->assign(value);
}
inline void Prosaverecord::set_callno(const char* value, size_t size) {
  set_has_callno();
  if (callno_ == &::google::protobuf::internal::kEmptyString) {
    callno_ = new ::std::string;
  }
  callno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_callno() {
  set_has_callno();
  if (callno_ == &::google::protobuf::internal::kEmptyString) {
    callno_ = new ::std::string;
  }
  return callno_;
}
inline ::std::string* Prosaverecord::release_callno() {
  clear_has_callno();
  if (callno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callno_;
    callno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string recordUserNo = 11;
inline bool Prosaverecord::has_recorduserno() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Prosaverecord::set_has_recorduserno() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Prosaverecord::clear_has_recorduserno() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Prosaverecord::clear_recorduserno() {
  if (recorduserno_ != &::google::protobuf::internal::kEmptyString) {
    recorduserno_->clear();
  }
  clear_has_recorduserno();
}
inline const ::std::string& Prosaverecord::recorduserno() const {
  return *recorduserno_;
}
inline void Prosaverecord::set_recorduserno(const ::std::string& value) {
  set_has_recorduserno();
  if (recorduserno_ == &::google::protobuf::internal::kEmptyString) {
    recorduserno_ = new ::std::string;
  }
  recorduserno_->assign(value);
}
inline void Prosaverecord::set_recorduserno(const char* value) {
  set_has_recorduserno();
  if (recorduserno_ == &::google::protobuf::internal::kEmptyString) {
    recorduserno_ = new ::std::string;
  }
  recorduserno_->assign(value);
}
inline void Prosaverecord::set_recorduserno(const char* value, size_t size) {
  set_has_recorduserno();
  if (recorduserno_ == &::google::protobuf::internal::kEmptyString) {
    recorduserno_ = new ::std::string;
  }
  recorduserno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_recorduserno() {
  set_has_recorduserno();
  if (recorduserno_ == &::google::protobuf::internal::kEmptyString) {
    recorduserno_ = new ::std::string;
  }
  return recorduserno_;
}
inline ::std::string* Prosaverecord::release_recorduserno() {
  clear_has_recorduserno();
  if (recorduserno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recorduserno_;
    recorduserno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 stateType = 12;
inline bool Prosaverecord::has_statetype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Prosaverecord::set_has_statetype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Prosaverecord::clear_has_statetype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Prosaverecord::clear_statetype() {
  statetype_ = 0;
  clear_has_statetype();
}
inline ::google::protobuf::int32 Prosaverecord::statetype() const {
  return statetype_;
}
inline void Prosaverecord::set_statetype(::google::protobuf::int32 value) {
  set_has_statetype();
  statetype_ = value;
}

// optional string startTime = 13 [default = "1970-01-01 00:00:00"];
inline bool Prosaverecord::has_starttime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Prosaverecord::set_has_starttime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Prosaverecord::clear_has_starttime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Prosaverecord::clear_starttime() {
  if (starttime_ != &_default_starttime_) {
    starttime_->assign(_default_starttime_);
  }
  clear_has_starttime();
}
inline const ::std::string& Prosaverecord::starttime() const {
  return *starttime_;
}
inline void Prosaverecord::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void Prosaverecord::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void Prosaverecord::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string(_default_starttime_);
  }
  return starttime_;
}
inline ::std::string* Prosaverecord::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &_default_starttime_) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&_default_starttime_);
    return temp;
  }
}

// optional string endTime = 14 [default = "1970-01-01 00:00:00"];
inline bool Prosaverecord::has_endtime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Prosaverecord::set_has_endtime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Prosaverecord::clear_has_endtime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Prosaverecord::clear_endtime() {
  if (endtime_ != &_default_endtime_) {
    endtime_->assign(_default_endtime_);
  }
  clear_has_endtime();
}
inline const ::std::string& Prosaverecord::endtime() const {
  return *endtime_;
}
inline void Prosaverecord::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void Prosaverecord::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void Prosaverecord::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string(_default_endtime_);
  }
  return endtime_;
}
inline ::std::string* Prosaverecord::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &_default_endtime_) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&_default_endtime_);
    return temp;
  }
}

// optional string fileName = 15;
inline bool Prosaverecord::has_filename() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Prosaverecord::set_has_filename() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Prosaverecord::clear_has_filename() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Prosaverecord::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Prosaverecord::filename() const {
  return *filename_;
}
inline void Prosaverecord::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Prosaverecord::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Prosaverecord::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Prosaverecord::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string devIp = 16;
inline bool Prosaverecord::has_devip() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Prosaverecord::set_has_devip() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Prosaverecord::clear_has_devip() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Prosaverecord::clear_devip() {
  if (devip_ != &::google::protobuf::internal::kEmptyString) {
    devip_->clear();
  }
  clear_has_devip();
}
inline const ::std::string& Prosaverecord::devip() const {
  return *devip_;
}
inline void Prosaverecord::set_devip(const ::std::string& value) {
  set_has_devip();
  if (devip_ == &::google::protobuf::internal::kEmptyString) {
    devip_ = new ::std::string;
  }
  devip_->assign(value);
}
inline void Prosaverecord::set_devip(const char* value) {
  set_has_devip();
  if (devip_ == &::google::protobuf::internal::kEmptyString) {
    devip_ = new ::std::string;
  }
  devip_->assign(value);
}
inline void Prosaverecord::set_devip(const char* value, size_t size) {
  set_has_devip();
  if (devip_ == &::google::protobuf::internal::kEmptyString) {
    devip_ = new ::std::string;
  }
  devip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_devip() {
  set_has_devip();
  if (devip_ == &::google::protobuf::internal::kEmptyString) {
    devip_ = new ::std::string;
  }
  return devip_;
}
inline ::std::string* Prosaverecord::release_devip() {
  clear_has_devip();
  if (devip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devip_;
    devip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 devId = 17;
inline bool Prosaverecord::has_devid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Prosaverecord::set_has_devid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Prosaverecord::clear_has_devid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Prosaverecord::clear_devid() {
  devid_ = 0;
  clear_has_devid();
}
inline ::google::protobuf::int32 Prosaverecord::devid() const {
  return devid_;
}
inline void Prosaverecord::set_devid(::google::protobuf::int32 value) {
  set_has_devid();
  devid_ = value;
}

// optional int32 devChannel = 18;
inline bool Prosaverecord::has_devchannel() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Prosaverecord::set_has_devchannel() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Prosaverecord::clear_has_devchannel() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Prosaverecord::clear_devchannel() {
  devchannel_ = 0;
  clear_has_devchannel();
}
inline ::google::protobuf::int32 Prosaverecord::devchannel() const {
  return devchannel_;
}
inline void Prosaverecord::set_devchannel(::google::protobuf::int32 value) {
  set_has_devchannel();
  devchannel_ = value;
}

// optional int32 locked = 19;
inline bool Prosaverecord::has_locked() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Prosaverecord::set_has_locked() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Prosaverecord::clear_has_locked() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Prosaverecord::clear_locked() {
  locked_ = 0;
  clear_has_locked();
}
inline ::google::protobuf::int32 Prosaverecord::locked() const {
  return locked_;
}
inline void Prosaverecord::set_locked(::google::protobuf::int32 value) {
  set_has_locked();
  locked_ = value;
}

// optional int32 upload = 20;
inline bool Prosaverecord::has_upload() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Prosaverecord::set_has_upload() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Prosaverecord::clear_has_upload() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Prosaverecord::clear_upload() {
  upload_ = 0;
  clear_has_upload();
}
inline ::google::protobuf::int32 Prosaverecord::upload() const {
  return upload_;
}
inline void Prosaverecord::set_upload(::google::protobuf::int32 value) {
  set_has_upload();
  upload_ = value;
}

// optional string strBucket = 21;
inline bool Prosaverecord::has_strbucket() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Prosaverecord::set_has_strbucket() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Prosaverecord::clear_has_strbucket() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Prosaverecord::clear_strbucket() {
  if (strbucket_ != &::google::protobuf::internal::kEmptyString) {
    strbucket_->clear();
  }
  clear_has_strbucket();
}
inline const ::std::string& Prosaverecord::strbucket() const {
  return *strbucket_;
}
inline void Prosaverecord::set_strbucket(const ::std::string& value) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(value);
}
inline void Prosaverecord::set_strbucket(const char* value) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(value);
}
inline void Prosaverecord::set_strbucket(const char* value, size_t size) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prosaverecord::mutable_strbucket() {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  return strbucket_;
}
inline ::std::string* Prosaverecord::release_strbucket() {
  clear_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbucket_;
    strbucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqProsaverecord

// optional int32 cmd = 1;
inline bool ReqProsaverecord::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqProsaverecord::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqProsaverecord::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqProsaverecord::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqProsaverecord::cmd() const {
  return cmd_;
}
inline void ReqProsaverecord::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 id = 2;
inline bool ReqProsaverecord::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqProsaverecord::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqProsaverecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqProsaverecord::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqProsaverecord::id() const {
  return id_;
}
inline void ReqProsaverecord::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 clientId = 3;
inline bool ReqProsaverecord::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqProsaverecord::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqProsaverecord::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqProsaverecord::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 ReqProsaverecord::clientid() const {
  return clientid_;
}
inline void ReqProsaverecord::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string strIds = 4;
inline bool ReqProsaverecord::has_strids() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqProsaverecord::set_has_strids() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqProsaverecord::clear_has_strids() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqProsaverecord::clear_strids() {
  if (strids_ != &::google::protobuf::internal::kEmptyString) {
    strids_->clear();
  }
  clear_has_strids();
}
inline const ::std::string& ReqProsaverecord::strids() const {
  return *strids_;
}
inline void ReqProsaverecord::set_strids(const ::std::string& value) {
  set_has_strids();
  if (strids_ == &::google::protobuf::internal::kEmptyString) {
    strids_ = new ::std::string;
  }
  strids_->assign(value);
}
inline void ReqProsaverecord::set_strids(const char* value) {
  set_has_strids();
  if (strids_ == &::google::protobuf::internal::kEmptyString) {
    strids_ = new ::std::string;
  }
  strids_->assign(value);
}
inline void ReqProsaverecord::set_strids(const char* value, size_t size) {
  set_has_strids();
  if (strids_ == &::google::protobuf::internal::kEmptyString) {
    strids_ = new ::std::string;
  }
  strids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqProsaverecord::mutable_strids() {
  set_has_strids();
  if (strids_ == &::google::protobuf::internal::kEmptyString) {
    strids_ = new ::std::string;
  }
  return strids_;
}
inline ::std::string* ReqProsaverecord::release_strids() {
  clear_has_strids();
  if (strids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strids_;
    strids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ProsaverecordList

// optional int32 cmd = 1;
inline bool ProsaverecordList::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProsaverecordList::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProsaverecordList::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProsaverecordList::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ProsaverecordList::cmd() const {
  return cmd_;
}
inline void ProsaverecordList::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// repeated .cms_8120.Prosaverecord prosaverecord = 2;
inline int ProsaverecordList::prosaverecord_size() const {
  return prosaverecord_.size();
}
inline void ProsaverecordList::clear_prosaverecord() {
  prosaverecord_.Clear();
}
inline const ::cms_8120::Prosaverecord& ProsaverecordList::prosaverecord(int index) const {
  return prosaverecord_.Get(index);
}
inline ::cms_8120::Prosaverecord* ProsaverecordList::mutable_prosaverecord(int index) {
  return prosaverecord_.Mutable(index);
}
inline ::cms_8120::Prosaverecord* ProsaverecordList::add_prosaverecord() {
  return prosaverecord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::Prosaverecord >&
ProsaverecordList::prosaverecord() const {
  return prosaverecord_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::Prosaverecord >*
ProsaverecordList::mutable_prosaverecord() {
  return &prosaverecord_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_center_2fProsaverecord_2eproto__INCLUDED
