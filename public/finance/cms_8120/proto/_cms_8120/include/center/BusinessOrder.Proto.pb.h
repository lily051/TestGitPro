// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: center/BusinessOrder.Proto

#ifndef PROTOBUF_center_2fBusinessOrder_2eProto__INCLUDED
#define PROTOBUF_center_2fBusinessOrder_2eProto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_center_2fBusinessOrder_2eProto();
void protobuf_AssignDesc_center_2fBusinessOrder_2eProto();
void protobuf_ShutdownFile_center_2fBusinessOrder_2eProto();

class BusinessOrder;
class BusinessOrderInfo;

// ===================================================================

class BusinessOrder : public ::google::protobuf::Message {
 public:
  BusinessOrder();
  virtual ~BusinessOrder();
  
  BusinessOrder(const BusinessOrder& from);
  
  inline BusinessOrder& operator=(const BusinessOrder& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessOrder& default_instance();
  
  void Swap(BusinessOrder* other);
  
  // implements Message ----------------------------------------------
  
  BusinessOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessOrder& from);
  void MergeFrom(const BusinessOrder& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 inputRegionId = 2;
  inline bool has_inputregionid() const;
  inline void clear_inputregionid();
  static const int kInputRegionIdFieldNumber = 2;
  inline ::google::protobuf::int32 inputregionid() const;
  inline void set_inputregionid(::google::protobuf::int32 value);
  
  // optional int32 nUserId = 3;
  inline bool has_nuserid() const;
  inline void clear_nuserid();
  static const int kNUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 nuserid() const;
  inline void set_nuserid(::google::protobuf::int32 value);
  
  // optional int32 clientId = 4;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 4;
  inline ::google::protobuf::int32 clientid() const;
  inline void set_clientid(::google::protobuf::int32 value);
  
  // optional int32 productTypeId = 5;
  inline bool has_producttypeid() const;
  inline void clear_producttypeid();
  static const int kProductTypeIdFieldNumber = 5;
  inline ::google::protobuf::int32 producttypeid() const;
  inline void set_producttypeid(::google::protobuf::int32 value);
  
  // optional int32 productId = 6;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 6;
  inline ::google::protobuf::int32 productid() const;
  inline void set_productid(::google::protobuf::int32 value);
  
  // optional int32 creditCode = 7;
  inline bool has_creditcode() const;
  inline void clear_creditcode();
  static const int kCreditCodeFieldNumber = 7;
  inline ::google::protobuf::int32 creditcode() const;
  inline void set_creditcode(::google::protobuf::int32 value);
  
  // optional int32 status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional string nProId = 9;
  inline bool has_nproid() const;
  inline void clear_nproid();
  static const int kNProIdFieldNumber = 9;
  inline const ::std::string& nproid() const;
  inline void set_nproid(const ::std::string& value);
  inline void set_nproid(const char* value);
  inline void set_nproid(const char* value, size_t size);
  inline ::std::string* mutable_nproid();
  inline ::std::string* release_nproid();
  
  // optional string businessTime = 10;
  inline bool has_businesstime() const;
  inline void clear_businesstime();
  static const int kBusinessTimeFieldNumber = 10;
  inline const ::std::string& businesstime() const;
  inline void set_businesstime(const ::std::string& value);
  inline void set_businesstime(const char* value);
  inline void set_businesstime(const char* value, size_t size);
  inline ::std::string* mutable_businesstime();
  inline ::std::string* release_businesstime();
  
  // optional string customerName = 11;
  inline bool has_customername() const;
  inline void clear_customername();
  static const int kCustomerNameFieldNumber = 11;
  inline const ::std::string& customername() const;
  inline void set_customername(const ::std::string& value);
  inline void set_customername(const char* value);
  inline void set_customername(const char* value, size_t size);
  inline ::std::string* mutable_customername();
  inline ::std::string* release_customername();
  
  // optional string creditId = 12;
  inline bool has_creditid() const;
  inline void clear_creditid();
  static const int kCreditIdFieldNumber = 12;
  inline const ::std::string& creditid() const;
  inline void set_creditid(const ::std::string& value);
  inline void set_creditid(const char* value);
  inline void set_creditid(const char* value, size_t size);
  inline ::std::string* mutable_creditid();
  inline ::std::string* release_creditid();
  
  // optional int32 productTypeName = 13;
  inline bool has_producttypename() const;
  inline void clear_producttypename();
  static const int kProductTypeNameFieldNumber = 13;
  inline ::google::protobuf::int32 producttypename() const;
  inline void set_producttypename(::google::protobuf::int32 value);
  
  // optional string productName = 14;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 14;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  
  // optional string productCode = 15;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 15;
  inline const ::std::string& productcode() const;
  inline void set_productcode(const ::std::string& value);
  inline void set_productcode(const char* value);
  inline void set_productcode(const char* value, size_t size);
  inline ::std::string* mutable_productcode();
  inline ::std::string* release_productcode();
  
  // optional string strEndDate = 16;
  inline bool has_strenddate() const;
  inline void clear_strenddate();
  static const int kStrEndDateFieldNumber = 16;
  inline const ::std::string& strenddate() const;
  inline void set_strenddate(const ::std::string& value);
  inline void set_strenddate(const char* value);
  inline void set_strenddate(const char* value, size_t size);
  inline ::std::string* mutable_strenddate();
  inline ::std::string* release_strenddate();
  
  // optional int32 guaranteeYears = 17;
  inline bool has_guaranteeyears() const;
  inline void clear_guaranteeyears();
  static const int kGuaranteeYearsFieldNumber = 17;
  inline ::google::protobuf::int32 guaranteeyears() const;
  inline void set_guaranteeyears(::google::protobuf::int32 value);
  
  // optional int32 productSaveMonth = 18;
  inline bool has_productsavemonth() const;
  inline void clear_productsavemonth();
  static const int kProductSaveMonthFieldNumber = 18;
  inline ::google::protobuf::int32 productsavemonth() const;
  inline void set_productsavemonth(::google::protobuf::int32 value);
  
  // optional string strGrade = 19;
  inline bool has_strgrade() const;
  inline void clear_strgrade();
  static const int kStrGradeFieldNumber = 19;
  inline const ::std::string& strgrade() const;
  inline void set_strgrade(const ::std::string& value);
  inline void set_strgrade(const char* value);
  inline void set_strgrade(const char* value, size_t size);
  inline ::std::string* mutable_strgrade();
  inline ::std::string* release_strgrade();
  
  // optional string strRisklevel = 20;
  inline bool has_strrisklevel() const;
  inline void clear_strrisklevel();
  static const int kStrRisklevelFieldNumber = 20;
  inline const ::std::string& strrisklevel() const;
  inline void set_strrisklevel(const ::std::string& value);
  inline void set_strrisklevel(const char* value);
  inline void set_strrisklevel(const char* value, size_t size);
  inline ::std::string* mutable_strrisklevel();
  inline ::std::string* release_strrisklevel();
  
  // optional string strBankNo = 21;
  inline bool has_strbankno() const;
  inline void clear_strbankno();
  static const int kStrBankNoFieldNumber = 21;
  inline const ::std::string& strbankno() const;
  inline void set_strbankno(const ::std::string& value);
  inline void set_strbankno(const char* value);
  inline void set_strbankno(const char* value, size_t size);
  inline ::std::string* mutable_strbankno();
  inline ::std::string* release_strbankno();
  
  // optional string strBuyMoney = 22;
  inline bool has_strbuymoney() const;
  inline void clear_strbuymoney();
  static const int kStrBuyMoneyFieldNumber = 22;
  inline const ::std::string& strbuymoney() const;
  inline void set_strbuymoney(const ::std::string& value);
  inline void set_strbuymoney(const char* value);
  inline void set_strbuymoney(const char* value, size_t size);
  inline ::std::string* mutable_strbuymoney();
  inline ::std::string* release_strbuymoney();
  
  // optional string strCreditPhone = 23;
  inline bool has_strcreditphone() const;
  inline void clear_strcreditphone();
  static const int kStrCreditPhoneFieldNumber = 23;
  inline const ::std::string& strcreditphone() const;
  inline void set_strcreditphone(const ::std::string& value);
  inline void set_strcreditphone(const char* value);
  inline void set_strcreditphone(const char* value, size_t size);
  inline ::std::string* mutable_strcreditphone();
  inline ::std::string* release_strcreditphone();
  
  // optional string strRemarks = 33;
  inline bool has_strremarks() const;
  inline void clear_strremarks();
  static const int kStrRemarksFieldNumber = 33;
  inline const ::std::string& strremarks() const;
  inline void set_strremarks(const ::std::string& value);
  inline void set_strremarks(const char* value);
  inline void set_strremarks(const char* value, size_t size);
  inline ::std::string* mutable_strremarks();
  inline ::std::string* release_strremarks();
  
  // optional string compReason = 34;
  inline bool has_compreason() const;
  inline void clear_compreason();
  static const int kCompReasonFieldNumber = 34;
  inline const ::std::string& compreason() const;
  inline void set_compreason(const ::std::string& value);
  inline void set_compreason(const char* value);
  inline void set_compreason(const char* value, size_t size);
  inline ::std::string* mutable_compreason();
  inline ::std::string* release_compreason();
  
  // optional string complainTime = 35;
  inline bool has_complaintime() const;
  inline void clear_complaintime();
  static const int kComplainTimeFieldNumber = 35;
  inline const ::std::string& complaintime() const;
  inline void set_complaintime(const ::std::string& value);
  inline void set_complaintime(const char* value);
  inline void set_complaintime(const char* value, size_t size);
  inline ::std::string* mutable_complaintime();
  inline ::std::string* release_complaintime();
  
  // optional string proName = 36;
  inline bool has_proname() const;
  inline void clear_proname();
  static const int kProNameFieldNumber = 36;
  inline const ::std::string& proname() const;
  inline void set_proname(const ::std::string& value);
  inline void set_proname(const char* value);
  inline void set_proname(const char* value, size_t size);
  inline ::std::string* mutable_proname();
  inline ::std::string* release_proname();
  
  // optional string proUserNo = 37;
  inline bool has_prouserno() const;
  inline void clear_prouserno();
  static const int kProUserNoFieldNumber = 37;
  inline const ::std::string& prouserno() const;
  inline void set_prouserno(const ::std::string& value);
  inline void set_prouserno(const char* value);
  inline void set_prouserno(const char* value, size_t size);
  inline ::std::string* mutable_prouserno();
  inline ::std::string* release_prouserno();
  
  // @@protoc_insertion_point(class_scope:cms_8120.BusinessOrder)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_inputregionid();
  inline void clear_has_inputregionid();
  inline void set_has_nuserid();
  inline void clear_has_nuserid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_producttypeid();
  inline void clear_has_producttypeid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_creditcode();
  inline void clear_has_creditcode();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_nproid();
  inline void clear_has_nproid();
  inline void set_has_businesstime();
  inline void clear_has_businesstime();
  inline void set_has_customername();
  inline void clear_has_customername();
  inline void set_has_creditid();
  inline void clear_has_creditid();
  inline void set_has_producttypename();
  inline void clear_has_producttypename();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_strenddate();
  inline void clear_has_strenddate();
  inline void set_has_guaranteeyears();
  inline void clear_has_guaranteeyears();
  inline void set_has_productsavemonth();
  inline void clear_has_productsavemonth();
  inline void set_has_strgrade();
  inline void clear_has_strgrade();
  inline void set_has_strrisklevel();
  inline void clear_has_strrisklevel();
  inline void set_has_strbankno();
  inline void clear_has_strbankno();
  inline void set_has_strbuymoney();
  inline void clear_has_strbuymoney();
  inline void set_has_strcreditphone();
  inline void clear_has_strcreditphone();
  inline void set_has_strremarks();
  inline void clear_has_strremarks();
  inline void set_has_compreason();
  inline void clear_has_compreason();
  inline void set_has_complaintime();
  inline void clear_has_complaintime();
  inline void set_has_proname();
  inline void clear_has_proname();
  inline void set_has_prouserno();
  inline void clear_has_prouserno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 inputregionid_;
  ::google::protobuf::int32 nuserid_;
  ::google::protobuf::int32 clientid_;
  ::google::protobuf::int32 producttypeid_;
  ::google::protobuf::int32 productid_;
  ::google::protobuf::int32 creditcode_;
  ::google::protobuf::int32 status_;
  ::std::string* nproid_;
  ::std::string* businesstime_;
  ::std::string* customername_;
  ::std::string* creditid_;
  ::std::string* productname_;
  ::std::string* productcode_;
  ::google::protobuf::int32 producttypename_;
  ::google::protobuf::int32 guaranteeyears_;
  ::std::string* strenddate_;
  ::std::string* strgrade_;
  ::std::string* strrisklevel_;
  ::std::string* strbankno_;
  ::std::string* strbuymoney_;
  ::std::string* strcreditphone_;
  ::std::string* strremarks_;
  ::std::string* compreason_;
  ::std::string* complaintime_;
  ::std::string* proname_;
  ::std::string* prouserno_;
  ::google::protobuf::int32 productsavemonth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fBusinessOrder_2eProto();
  friend void protobuf_AssignDesc_center_2fBusinessOrder_2eProto();
  friend void protobuf_ShutdownFile_center_2fBusinessOrder_2eProto();
  
  void InitAsDefaultInstance();
  static BusinessOrder* default_instance_;
};
// -------------------------------------------------------------------

class BusinessOrderInfo : public ::google::protobuf::Message {
 public:
  BusinessOrderInfo();
  virtual ~BusinessOrderInfo();
  
  BusinessOrderInfo(const BusinessOrderInfo& from);
  
  inline BusinessOrderInfo& operator=(const BusinessOrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessOrderInfo& default_instance();
  
  void Swap(BusinessOrderInfo* other);
  
  // implements Message ----------------------------------------------
  
  BusinessOrderInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BusinessOrderInfo& from);
  void MergeFrom(const BusinessOrderInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional .cms_8120.BusinessOrder businessOrder = 2;
  inline bool has_businessorder() const;
  inline void clear_businessorder();
  static const int kBusinessOrderFieldNumber = 2;
  inline const ::cms_8120::BusinessOrder& businessorder() const;
  inline ::cms_8120::BusinessOrder* mutable_businessorder();
  inline ::cms_8120::BusinessOrder* release_businessorder();
  
  // @@protoc_insertion_point(class_scope:cms_8120.BusinessOrderInfo)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_businessorder();
  inline void clear_has_businessorder();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::cms_8120::BusinessOrder* businessorder_;
  ::google::protobuf::int32 cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fBusinessOrder_2eProto();
  friend void protobuf_AssignDesc_center_2fBusinessOrder_2eProto();
  friend void protobuf_ShutdownFile_center_2fBusinessOrder_2eProto();
  
  void InitAsDefaultInstance();
  static BusinessOrderInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// BusinessOrder

// optional int32 id = 1;
inline bool BusinessOrder::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessOrder::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessOrder::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessOrder::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BusinessOrder::id() const {
  return id_;
}
inline void BusinessOrder::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 inputRegionId = 2;
inline bool BusinessOrder::has_inputregionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessOrder::set_has_inputregionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessOrder::clear_has_inputregionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessOrder::clear_inputregionid() {
  inputregionid_ = 0;
  clear_has_inputregionid();
}
inline ::google::protobuf::int32 BusinessOrder::inputregionid() const {
  return inputregionid_;
}
inline void BusinessOrder::set_inputregionid(::google::protobuf::int32 value) {
  set_has_inputregionid();
  inputregionid_ = value;
}

// optional int32 nUserId = 3;
inline bool BusinessOrder::has_nuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BusinessOrder::set_has_nuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BusinessOrder::clear_has_nuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BusinessOrder::clear_nuserid() {
  nuserid_ = 0;
  clear_has_nuserid();
}
inline ::google::protobuf::int32 BusinessOrder::nuserid() const {
  return nuserid_;
}
inline void BusinessOrder::set_nuserid(::google::protobuf::int32 value) {
  set_has_nuserid();
  nuserid_ = value;
}

// optional int32 clientId = 4;
inline bool BusinessOrder::has_clientid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BusinessOrder::set_has_clientid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BusinessOrder::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BusinessOrder::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 BusinessOrder::clientid() const {
  return clientid_;
}
inline void BusinessOrder::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional int32 productTypeId = 5;
inline bool BusinessOrder::has_producttypeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BusinessOrder::set_has_producttypeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BusinessOrder::clear_has_producttypeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BusinessOrder::clear_producttypeid() {
  producttypeid_ = 0;
  clear_has_producttypeid();
}
inline ::google::protobuf::int32 BusinessOrder::producttypeid() const {
  return producttypeid_;
}
inline void BusinessOrder::set_producttypeid(::google::protobuf::int32 value) {
  set_has_producttypeid();
  producttypeid_ = value;
}

// optional int32 productId = 6;
inline bool BusinessOrder::has_productid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BusinessOrder::set_has_productid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BusinessOrder::clear_has_productid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BusinessOrder::clear_productid() {
  productid_ = 0;
  clear_has_productid();
}
inline ::google::protobuf::int32 BusinessOrder::productid() const {
  return productid_;
}
inline void BusinessOrder::set_productid(::google::protobuf::int32 value) {
  set_has_productid();
  productid_ = value;
}

// optional int32 creditCode = 7;
inline bool BusinessOrder::has_creditcode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BusinessOrder::set_has_creditcode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BusinessOrder::clear_has_creditcode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BusinessOrder::clear_creditcode() {
  creditcode_ = 0;
  clear_has_creditcode();
}
inline ::google::protobuf::int32 BusinessOrder::creditcode() const {
  return creditcode_;
}
inline void BusinessOrder::set_creditcode(::google::protobuf::int32 value) {
  set_has_creditcode();
  creditcode_ = value;
}

// optional int32 status = 8;
inline bool BusinessOrder::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BusinessOrder::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BusinessOrder::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BusinessOrder::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 BusinessOrder::status() const {
  return status_;
}
inline void BusinessOrder::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string nProId = 9;
inline bool BusinessOrder::has_nproid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BusinessOrder::set_has_nproid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BusinessOrder::clear_has_nproid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BusinessOrder::clear_nproid() {
  if (nproid_ != &::google::protobuf::internal::kEmptyString) {
    nproid_->clear();
  }
  clear_has_nproid();
}
inline const ::std::string& BusinessOrder::nproid() const {
  return *nproid_;
}
inline void BusinessOrder::set_nproid(const ::std::string& value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void BusinessOrder::set_nproid(const char* value) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(value);
}
inline void BusinessOrder::set_nproid(const char* value, size_t size) {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  nproid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_nproid() {
  set_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    nproid_ = new ::std::string;
  }
  return nproid_;
}
inline ::std::string* BusinessOrder::release_nproid() {
  clear_has_nproid();
  if (nproid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nproid_;
    nproid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string businessTime = 10;
inline bool BusinessOrder::has_businesstime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BusinessOrder::set_has_businesstime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BusinessOrder::clear_has_businesstime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BusinessOrder::clear_businesstime() {
  if (businesstime_ != &::google::protobuf::internal::kEmptyString) {
    businesstime_->clear();
  }
  clear_has_businesstime();
}
inline const ::std::string& BusinessOrder::businesstime() const {
  return *businesstime_;
}
inline void BusinessOrder::set_businesstime(const ::std::string& value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void BusinessOrder::set_businesstime(const char* value) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(value);
}
inline void BusinessOrder::set_businesstime(const char* value, size_t size) {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  businesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_businesstime() {
  set_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    businesstime_ = new ::std::string;
  }
  return businesstime_;
}
inline ::std::string* BusinessOrder::release_businesstime() {
  clear_has_businesstime();
  if (businesstime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = businesstime_;
    businesstime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string customerName = 11;
inline bool BusinessOrder::has_customername() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BusinessOrder::set_has_customername() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BusinessOrder::clear_has_customername() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BusinessOrder::clear_customername() {
  if (customername_ != &::google::protobuf::internal::kEmptyString) {
    customername_->clear();
  }
  clear_has_customername();
}
inline const ::std::string& BusinessOrder::customername() const {
  return *customername_;
}
inline void BusinessOrder::set_customername(const ::std::string& value) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  customername_->assign(value);
}
inline void BusinessOrder::set_customername(const char* value) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  customername_->assign(value);
}
inline void BusinessOrder::set_customername(const char* value, size_t size) {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  customername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_customername() {
  set_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    customername_ = new ::std::string;
  }
  return customername_;
}
inline ::std::string* BusinessOrder::release_customername() {
  clear_has_customername();
  if (customername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customername_;
    customername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string creditId = 12;
inline bool BusinessOrder::has_creditid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BusinessOrder::set_has_creditid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BusinessOrder::clear_has_creditid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BusinessOrder::clear_creditid() {
  if (creditid_ != &::google::protobuf::internal::kEmptyString) {
    creditid_->clear();
  }
  clear_has_creditid();
}
inline const ::std::string& BusinessOrder::creditid() const {
  return *creditid_;
}
inline void BusinessOrder::set_creditid(const ::std::string& value) {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  creditid_->assign(value);
}
inline void BusinessOrder::set_creditid(const char* value) {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  creditid_->assign(value);
}
inline void BusinessOrder::set_creditid(const char* value, size_t size) {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  creditid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_creditid() {
  set_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    creditid_ = new ::std::string;
  }
  return creditid_;
}
inline ::std::string* BusinessOrder::release_creditid() {
  clear_has_creditid();
  if (creditid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creditid_;
    creditid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 productTypeName = 13;
inline bool BusinessOrder::has_producttypename() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BusinessOrder::set_has_producttypename() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BusinessOrder::clear_has_producttypename() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BusinessOrder::clear_producttypename() {
  producttypename_ = 0;
  clear_has_producttypename();
}
inline ::google::protobuf::int32 BusinessOrder::producttypename() const {
  return producttypename_;
}
inline void BusinessOrder::set_producttypename(::google::protobuf::int32 value) {
  set_has_producttypename();
  producttypename_ = value;
}

// optional string productName = 14;
inline bool BusinessOrder::has_productname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BusinessOrder::set_has_productname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BusinessOrder::clear_has_productname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BusinessOrder::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& BusinessOrder::productname() const {
  return *productname_;
}
inline void BusinessOrder::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void BusinessOrder::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void BusinessOrder::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* BusinessOrder::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string productCode = 15;
inline bool BusinessOrder::has_productcode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BusinessOrder::set_has_productcode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BusinessOrder::clear_has_productcode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BusinessOrder::clear_productcode() {
  if (productcode_ != &::google::protobuf::internal::kEmptyString) {
    productcode_->clear();
  }
  clear_has_productcode();
}
inline const ::std::string& BusinessOrder::productcode() const {
  return *productcode_;
}
inline void BusinessOrder::set_productcode(const ::std::string& value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void BusinessOrder::set_productcode(const char* value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
}
inline void BusinessOrder::set_productcode(const char* value, size_t size) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_productcode() {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    productcode_ = new ::std::string;
  }
  return productcode_;
}
inline ::std::string* BusinessOrder::release_productcode() {
  clear_has_productcode();
  if (productcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productcode_;
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strEndDate = 16;
inline bool BusinessOrder::has_strenddate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BusinessOrder::set_has_strenddate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BusinessOrder::clear_has_strenddate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BusinessOrder::clear_strenddate() {
  if (strenddate_ != &::google::protobuf::internal::kEmptyString) {
    strenddate_->clear();
  }
  clear_has_strenddate();
}
inline const ::std::string& BusinessOrder::strenddate() const {
  return *strenddate_;
}
inline void BusinessOrder::set_strenddate(const ::std::string& value) {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  strenddate_->assign(value);
}
inline void BusinessOrder::set_strenddate(const char* value) {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  strenddate_->assign(value);
}
inline void BusinessOrder::set_strenddate(const char* value, size_t size) {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  strenddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strenddate() {
  set_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    strenddate_ = new ::std::string;
  }
  return strenddate_;
}
inline ::std::string* BusinessOrder::release_strenddate() {
  clear_has_strenddate();
  if (strenddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strenddate_;
    strenddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 guaranteeYears = 17;
inline bool BusinessOrder::has_guaranteeyears() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BusinessOrder::set_has_guaranteeyears() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BusinessOrder::clear_has_guaranteeyears() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BusinessOrder::clear_guaranteeyears() {
  guaranteeyears_ = 0;
  clear_has_guaranteeyears();
}
inline ::google::protobuf::int32 BusinessOrder::guaranteeyears() const {
  return guaranteeyears_;
}
inline void BusinessOrder::set_guaranteeyears(::google::protobuf::int32 value) {
  set_has_guaranteeyears();
  guaranteeyears_ = value;
}

// optional int32 productSaveMonth = 18;
inline bool BusinessOrder::has_productsavemonth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BusinessOrder::set_has_productsavemonth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BusinessOrder::clear_has_productsavemonth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BusinessOrder::clear_productsavemonth() {
  productsavemonth_ = 0;
  clear_has_productsavemonth();
}
inline ::google::protobuf::int32 BusinessOrder::productsavemonth() const {
  return productsavemonth_;
}
inline void BusinessOrder::set_productsavemonth(::google::protobuf::int32 value) {
  set_has_productsavemonth();
  productsavemonth_ = value;
}

// optional string strGrade = 19;
inline bool BusinessOrder::has_strgrade() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BusinessOrder::set_has_strgrade() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BusinessOrder::clear_has_strgrade() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BusinessOrder::clear_strgrade() {
  if (strgrade_ != &::google::protobuf::internal::kEmptyString) {
    strgrade_->clear();
  }
  clear_has_strgrade();
}
inline const ::std::string& BusinessOrder::strgrade() const {
  return *strgrade_;
}
inline void BusinessOrder::set_strgrade(const ::std::string& value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void BusinessOrder::set_strgrade(const char* value) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(value);
}
inline void BusinessOrder::set_strgrade(const char* value, size_t size) {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  strgrade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strgrade() {
  set_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    strgrade_ = new ::std::string;
  }
  return strgrade_;
}
inline ::std::string* BusinessOrder::release_strgrade() {
  clear_has_strgrade();
  if (strgrade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strgrade_;
    strgrade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strRisklevel = 20;
inline bool BusinessOrder::has_strrisklevel() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BusinessOrder::set_has_strrisklevel() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BusinessOrder::clear_has_strrisklevel() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BusinessOrder::clear_strrisklevel() {
  if (strrisklevel_ != &::google::protobuf::internal::kEmptyString) {
    strrisklevel_->clear();
  }
  clear_has_strrisklevel();
}
inline const ::std::string& BusinessOrder::strrisklevel() const {
  return *strrisklevel_;
}
inline void BusinessOrder::set_strrisklevel(const ::std::string& value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void BusinessOrder::set_strrisklevel(const char* value) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(value);
}
inline void BusinessOrder::set_strrisklevel(const char* value, size_t size) {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  strrisklevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strrisklevel() {
  set_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    strrisklevel_ = new ::std::string;
  }
  return strrisklevel_;
}
inline ::std::string* BusinessOrder::release_strrisklevel() {
  clear_has_strrisklevel();
  if (strrisklevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrisklevel_;
    strrisklevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBankNo = 21;
inline bool BusinessOrder::has_strbankno() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BusinessOrder::set_has_strbankno() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BusinessOrder::clear_has_strbankno() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BusinessOrder::clear_strbankno() {
  if (strbankno_ != &::google::protobuf::internal::kEmptyString) {
    strbankno_->clear();
  }
  clear_has_strbankno();
}
inline const ::std::string& BusinessOrder::strbankno() const {
  return *strbankno_;
}
inline void BusinessOrder::set_strbankno(const ::std::string& value) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(value);
}
inline void BusinessOrder::set_strbankno(const char* value) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(value);
}
inline void BusinessOrder::set_strbankno(const char* value, size_t size) {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  strbankno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strbankno() {
  set_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    strbankno_ = new ::std::string;
  }
  return strbankno_;
}
inline ::std::string* BusinessOrder::release_strbankno() {
  clear_has_strbankno();
  if (strbankno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbankno_;
    strbankno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBuyMoney = 22;
inline bool BusinessOrder::has_strbuymoney() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BusinessOrder::set_has_strbuymoney() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BusinessOrder::clear_has_strbuymoney() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BusinessOrder::clear_strbuymoney() {
  if (strbuymoney_ != &::google::protobuf::internal::kEmptyString) {
    strbuymoney_->clear();
  }
  clear_has_strbuymoney();
}
inline const ::std::string& BusinessOrder::strbuymoney() const {
  return *strbuymoney_;
}
inline void BusinessOrder::set_strbuymoney(const ::std::string& value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void BusinessOrder::set_strbuymoney(const char* value) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(value);
}
inline void BusinessOrder::set_strbuymoney(const char* value, size_t size) {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  strbuymoney_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strbuymoney() {
  set_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    strbuymoney_ = new ::std::string;
  }
  return strbuymoney_;
}
inline ::std::string* BusinessOrder::release_strbuymoney() {
  clear_has_strbuymoney();
  if (strbuymoney_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbuymoney_;
    strbuymoney_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCreditPhone = 23;
inline bool BusinessOrder::has_strcreditphone() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BusinessOrder::set_has_strcreditphone() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BusinessOrder::clear_has_strcreditphone() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BusinessOrder::clear_strcreditphone() {
  if (strcreditphone_ != &::google::protobuf::internal::kEmptyString) {
    strcreditphone_->clear();
  }
  clear_has_strcreditphone();
}
inline const ::std::string& BusinessOrder::strcreditphone() const {
  return *strcreditphone_;
}
inline void BusinessOrder::set_strcreditphone(const ::std::string& value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void BusinessOrder::set_strcreditphone(const char* value) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(value);
}
inline void BusinessOrder::set_strcreditphone(const char* value, size_t size) {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  strcreditphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strcreditphone() {
  set_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    strcreditphone_ = new ::std::string;
  }
  return strcreditphone_;
}
inline ::std::string* BusinessOrder::release_strcreditphone() {
  clear_has_strcreditphone();
  if (strcreditphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcreditphone_;
    strcreditphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strRemarks = 33;
inline bool BusinessOrder::has_strremarks() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BusinessOrder::set_has_strremarks() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BusinessOrder::clear_has_strremarks() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BusinessOrder::clear_strremarks() {
  if (strremarks_ != &::google::protobuf::internal::kEmptyString) {
    strremarks_->clear();
  }
  clear_has_strremarks();
}
inline const ::std::string& BusinessOrder::strremarks() const {
  return *strremarks_;
}
inline void BusinessOrder::set_strremarks(const ::std::string& value) {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  strremarks_->assign(value);
}
inline void BusinessOrder::set_strremarks(const char* value) {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  strremarks_->assign(value);
}
inline void BusinessOrder::set_strremarks(const char* value, size_t size) {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  strremarks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_strremarks() {
  set_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    strremarks_ = new ::std::string;
  }
  return strremarks_;
}
inline ::std::string* BusinessOrder::release_strremarks() {
  clear_has_strremarks();
  if (strremarks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strremarks_;
    strremarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string compReason = 34;
inline bool BusinessOrder::has_compreason() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BusinessOrder::set_has_compreason() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BusinessOrder::clear_has_compreason() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BusinessOrder::clear_compreason() {
  if (compreason_ != &::google::protobuf::internal::kEmptyString) {
    compreason_->clear();
  }
  clear_has_compreason();
}
inline const ::std::string& BusinessOrder::compreason() const {
  return *compreason_;
}
inline void BusinessOrder::set_compreason(const ::std::string& value) {
  set_has_compreason();
  if (compreason_ == &::google::protobuf::internal::kEmptyString) {
    compreason_ = new ::std::string;
  }
  compreason_->assign(value);
}
inline void BusinessOrder::set_compreason(const char* value) {
  set_has_compreason();
  if (compreason_ == &::google::protobuf::internal::kEmptyString) {
    compreason_ = new ::std::string;
  }
  compreason_->assign(value);
}
inline void BusinessOrder::set_compreason(const char* value, size_t size) {
  set_has_compreason();
  if (compreason_ == &::google::protobuf::internal::kEmptyString) {
    compreason_ = new ::std::string;
  }
  compreason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_compreason() {
  set_has_compreason();
  if (compreason_ == &::google::protobuf::internal::kEmptyString) {
    compreason_ = new ::std::string;
  }
  return compreason_;
}
inline ::std::string* BusinessOrder::release_compreason() {
  clear_has_compreason();
  if (compreason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compreason_;
    compreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string complainTime = 35;
inline bool BusinessOrder::has_complaintime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BusinessOrder::set_has_complaintime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BusinessOrder::clear_has_complaintime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BusinessOrder::clear_complaintime() {
  if (complaintime_ != &::google::protobuf::internal::kEmptyString) {
    complaintime_->clear();
  }
  clear_has_complaintime();
}
inline const ::std::string& BusinessOrder::complaintime() const {
  return *complaintime_;
}
inline void BusinessOrder::set_complaintime(const ::std::string& value) {
  set_has_complaintime();
  if (complaintime_ == &::google::protobuf::internal::kEmptyString) {
    complaintime_ = new ::std::string;
  }
  complaintime_->assign(value);
}
inline void BusinessOrder::set_complaintime(const char* value) {
  set_has_complaintime();
  if (complaintime_ == &::google::protobuf::internal::kEmptyString) {
    complaintime_ = new ::std::string;
  }
  complaintime_->assign(value);
}
inline void BusinessOrder::set_complaintime(const char* value, size_t size) {
  set_has_complaintime();
  if (complaintime_ == &::google::protobuf::internal::kEmptyString) {
    complaintime_ = new ::std::string;
  }
  complaintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_complaintime() {
  set_has_complaintime();
  if (complaintime_ == &::google::protobuf::internal::kEmptyString) {
    complaintime_ = new ::std::string;
  }
  return complaintime_;
}
inline ::std::string* BusinessOrder::release_complaintime() {
  clear_has_complaintime();
  if (complaintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = complaintime_;
    complaintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proName = 36;
inline bool BusinessOrder::has_proname() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BusinessOrder::set_has_proname() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BusinessOrder::clear_has_proname() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BusinessOrder::clear_proname() {
  if (proname_ != &::google::protobuf::internal::kEmptyString) {
    proname_->clear();
  }
  clear_has_proname();
}
inline const ::std::string& BusinessOrder::proname() const {
  return *proname_;
}
inline void BusinessOrder::set_proname(const ::std::string& value) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(value);
}
inline void BusinessOrder::set_proname(const char* value) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(value);
}
inline void BusinessOrder::set_proname(const char* value, size_t size) {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  proname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_proname() {
  set_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    proname_ = new ::std::string;
  }
  return proname_;
}
inline ::std::string* BusinessOrder::release_proname() {
  clear_has_proname();
  if (proname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proname_;
    proname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string proUserNo = 37;
inline bool BusinessOrder::has_prouserno() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BusinessOrder::set_has_prouserno() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BusinessOrder::clear_has_prouserno() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BusinessOrder::clear_prouserno() {
  if (prouserno_ != &::google::protobuf::internal::kEmptyString) {
    prouserno_->clear();
  }
  clear_has_prouserno();
}
inline const ::std::string& BusinessOrder::prouserno() const {
  return *prouserno_;
}
inline void BusinessOrder::set_prouserno(const ::std::string& value) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(value);
}
inline void BusinessOrder::set_prouserno(const char* value) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(value);
}
inline void BusinessOrder::set_prouserno(const char* value, size_t size) {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  prouserno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BusinessOrder::mutable_prouserno() {
  set_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    prouserno_ = new ::std::string;
  }
  return prouserno_;
}
inline ::std::string* BusinessOrder::release_prouserno() {
  clear_has_prouserno();
  if (prouserno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prouserno_;
    prouserno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BusinessOrderInfo

// optional int32 cmd = 1;
inline bool BusinessOrderInfo::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BusinessOrderInfo::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BusinessOrderInfo::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BusinessOrderInfo::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 BusinessOrderInfo::cmd() const {
  return cmd_;
}
inline void BusinessOrderInfo::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .cms_8120.BusinessOrder businessOrder = 2;
inline bool BusinessOrderInfo::has_businessorder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BusinessOrderInfo::set_has_businessorder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BusinessOrderInfo::clear_has_businessorder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BusinessOrderInfo::clear_businessorder() {
  if (businessorder_ != NULL) businessorder_->::cms_8120::BusinessOrder::Clear();
  clear_has_businessorder();
}
inline const ::cms_8120::BusinessOrder& BusinessOrderInfo::businessorder() const {
  return businessorder_ != NULL ? *businessorder_ : *default_instance_->businessorder_;
}
inline ::cms_8120::BusinessOrder* BusinessOrderInfo::mutable_businessorder() {
  set_has_businessorder();
  if (businessorder_ == NULL) businessorder_ = new ::cms_8120::BusinessOrder;
  return businessorder_;
}
inline ::cms_8120::BusinessOrder* BusinessOrderInfo::release_businessorder() {
  clear_has_businessorder();
  ::cms_8120::BusinessOrder* temp = businessorder_;
  businessorder_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_center_2fBusinessOrder_2eProto__INCLUDED
