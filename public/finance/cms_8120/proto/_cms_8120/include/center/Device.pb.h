// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: center/Device.proto

#ifndef PROTOBUF_center_2fDevice_2eproto__INCLUDED
#define PROTOBUF_center_2fDevice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "type/cmd.pb.h"
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_center_2fDevice_2eproto();
void protobuf_AssignDesc_center_2fDevice_2eproto();
void protobuf_ShutdownFile_center_2fDevice_2eproto();

class Device;
class ReqDevice;
class DeviceList;

// ===================================================================

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();
  
  Device(const Device& from);
  
  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();
  
  void Swap(Device* other);
  
  // implements Message ----------------------------------------------
  
  Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 nType = 2;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);
  
  // optional string strName = 3;
  inline bool has_strname() const;
  inline void clear_strname();
  static const int kStrNameFieldNumber = 3;
  inline const ::std::string& strname() const;
  inline void set_strname(const ::std::string& value);
  inline void set_strname(const char* value);
  inline void set_strname(const char* value, size_t size);
  inline ::std::string* mutable_strname();
  inline ::std::string* release_strname();
  
  // optional string strIp = 4;
  inline bool has_strip() const;
  inline void clear_strip();
  static const int kStrIpFieldNumber = 4;
  inline const ::std::string& strip() const;
  inline void set_strip(const ::std::string& value);
  inline void set_strip(const char* value);
  inline void set_strip(const char* value, size_t size);
  inline ::std::string* mutable_strip();
  inline ::std::string* release_strip();
  
  // optional int32 nPort = 5;
  inline bool has_nport() const;
  inline void clear_nport();
  static const int kNPortFieldNumber = 5;
  inline ::google::protobuf::int32 nport() const;
  inline void set_nport(::google::protobuf::int32 value);
  
  // optional string strUser = 6;
  inline bool has_struser() const;
  inline void clear_struser();
  static const int kStrUserFieldNumber = 6;
  inline const ::std::string& struser() const;
  inline void set_struser(const ::std::string& value);
  inline void set_struser(const char* value);
  inline void set_struser(const char* value, size_t size);
  inline ::std::string* mutable_struser();
  inline ::std::string* release_struser();
  
  // optional string strPassword = 7;
  inline bool has_strpassword() const;
  inline void clear_strpassword();
  static const int kStrPasswordFieldNumber = 7;
  inline const ::std::string& strpassword() const;
  inline void set_strpassword(const ::std::string& value);
  inline void set_strpassword(const char* value);
  inline void set_strpassword(const char* value, size_t size);
  inline ::std::string* mutable_strpassword();
  inline ::std::string* release_strpassword();
  
  // optional string strPasswordLevel = 8;
  inline bool has_strpasswordlevel() const;
  inline void clear_strpasswordlevel();
  static const int kStrPasswordLevelFieldNumber = 8;
  inline const ::std::string& strpasswordlevel() const;
  inline void set_strpasswordlevel(const ::std::string& value);
  inline void set_strpasswordlevel(const char* value);
  inline void set_strpasswordlevel(const char* value, size_t size);
  inline ::std::string* mutable_strpasswordlevel();
  inline ::std::string* release_strpasswordlevel();
  
  // optional int32 nDevType = 9;
  inline bool has_ndevtype() const;
  inline void clear_ndevtype();
  static const int kNDevTypeFieldNumber = 9;
  inline ::google::protobuf::int32 ndevtype() const;
  inline void set_ndevtype(::google::protobuf::int32 value);
  
  // optional int32 nProductType = 10;
  inline bool has_nproducttype() const;
  inline void clear_nproducttype();
  static const int kNProductTypeFieldNumber = 10;
  inline ::google::protobuf::int32 nproducttype() const;
  inline void set_nproducttype(::google::protobuf::int32 value);
  
  // optional int32 nChanNum = 11;
  inline bool has_nchannum() const;
  inline void clear_nchannum();
  static const int kNChanNumFieldNumber = 11;
  inline ::google::protobuf::int32 nchannum() const;
  inline void set_nchannum(::google::protobuf::int32 value);
  
  // optional string strDeviceId = 12;
  inline bool has_strdeviceid() const;
  inline void clear_strdeviceid();
  static const int kStrDeviceIdFieldNumber = 12;
  inline const ::std::string& strdeviceid() const;
  inline void set_strdeviceid(const ::std::string& value);
  inline void set_strdeviceid(const char* value);
  inline void set_strdeviceid(const char* value, size_t size);
  inline ::std::string* mutable_strdeviceid();
  inline ::std::string* release_strdeviceid();
  
  // optional int32 telChanNum = 13;
  inline bool has_telchannum() const;
  inline void clear_telchannum();
  static const int kTelChanNumFieldNumber = 13;
  inline ::google::protobuf::int32 telchannum() const;
  inline void set_telchannum(::google::protobuf::int32 value);
  
  // optional int32 nRegionId = 14;
  inline bool has_nregionid() const;
  inline void clear_nregionid();
  static const int kNRegionIdFieldNumber = 14;
  inline ::google::protobuf::int32 nregionid() const;
  inline void set_nregionid(::google::protobuf::int32 value);
  
  // optional int32 nStreamType = 15;
  inline bool has_nstreamtype() const;
  inline void clear_nstreamtype();
  static const int kNStreamTypeFieldNumber = 15;
  inline ::google::protobuf::int32 nstreamtype() const;
  inline void set_nstreamtype(::google::protobuf::int32 value);
  
  // optional int32 dvrType = 16;
  inline bool has_dvrtype() const;
  inline void clear_dvrtype();
  static const int kDvrTypeFieldNumber = 16;
  inline ::google::protobuf::int32 dvrtype() const;
  inline void set_dvrtype(::google::protobuf::int32 value);
  
  // optional int32 nConfigPort = 17;
  inline bool has_nconfigport() const;
  inline void clear_nconfigport();
  static const int kNConfigPortFieldNumber = 17;
  inline ::google::protobuf::int32 nconfigport() const;
  inline void set_nconfigport(::google::protobuf::int32 value);
  
  // optional string strConfigUser = 18;
  inline bool has_strconfiguser() const;
  inline void clear_strconfiguser();
  static const int kStrConfigUserFieldNumber = 18;
  inline const ::std::string& strconfiguser() const;
  inline void set_strconfiguser(const ::std::string& value);
  inline void set_strconfiguser(const char* value);
  inline void set_strconfiguser(const char* value, size_t size);
  inline ::std::string* mutable_strconfiguser();
  inline ::std::string* release_strconfiguser();
  
  // optional string strConfigPassword = 19;
  inline bool has_strconfigpassword() const;
  inline void clear_strconfigpassword();
  static const int kStrConfigPasswordFieldNumber = 19;
  inline const ::std::string& strconfigpassword() const;
  inline void set_strconfigpassword(const ::std::string& value);
  inline void set_strconfigpassword(const char* value);
  inline void set_strconfigpassword(const char* value, size_t size);
  inline ::std::string* mutable_strconfigpassword();
  inline ::std::string* release_strconfigpassword();
  
  // optional int32 online = 20;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 20;
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);
  
  // optional int32 uiTotalSpace = 21;
  inline bool has_uitotalspace() const;
  inline void clear_uitotalspace();
  static const int kUiTotalSpaceFieldNumber = 21;
  inline ::google::protobuf::int32 uitotalspace() const;
  inline void set_uitotalspace(::google::protobuf::int32 value);
  
  // optional int32 uiFreeSpace = 22;
  inline bool has_uifreespace() const;
  inline void clear_uifreespace();
  static const int kUiFreeSpaceFieldNumber = 22;
  inline ::google::protobuf::int32 uifreespace() const;
  inline void set_uifreespace(::google::protobuf::int32 value);
  
  // optional string strIndexCode = 23;
  inline bool has_strindexcode() const;
  inline void clear_strindexcode();
  static const int kStrIndexCodeFieldNumber = 23;
  inline const ::std::string& strindexcode() const;
  inline void set_strindexcode(const ::std::string& value);
  inline void set_strindexcode(const char* value);
  inline void set_strindexcode(const char* value, size_t size);
  inline ::std::string* mutable_strindexcode();
  inline ::std::string* release_strindexcode();
  
  // optional string strManufacture = 24;
  inline bool has_strmanufacture() const;
  inline void clear_strmanufacture();
  static const int kStrManufactureFieldNumber = 24;
  inline const ::std::string& strmanufacture() const;
  inline void set_strmanufacture(const ::std::string& value);
  inline void set_strmanufacture(const char* value);
  inline void set_strmanufacture(const char* value, size_t size);
  inline ::std::string* mutable_strmanufacture();
  inline ::std::string* release_strmanufacture();
  
  // optional string strAccessKey = 25;
  inline bool has_straccesskey() const;
  inline void clear_straccesskey();
  static const int kStrAccessKeyFieldNumber = 25;
  inline const ::std::string& straccesskey() const;
  inline void set_straccesskey(const ::std::string& value);
  inline void set_straccesskey(const char* value);
  inline void set_straccesskey(const char* value, size_t size);
  inline ::std::string* mutable_straccesskey();
  inline ::std::string* release_straccesskey();
  
  // optional string strSecretKey = 26;
  inline bool has_strsecretkey() const;
  inline void clear_strsecretkey();
  static const int kStrSecretKeyFieldNumber = 26;
  inline const ::std::string& strsecretkey() const;
  inline void set_strsecretkey(const ::std::string& value);
  inline void set_strsecretkey(const char* value);
  inline void set_strsecretkey(const char* value, size_t size);
  inline ::std::string* mutable_strsecretkey();
  inline ::std::string* release_strsecretkey();
  
  // @@protoc_insertion_point(class_scope:cms_8120.Device)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_strname();
  inline void clear_has_strname();
  inline void set_has_strip();
  inline void clear_has_strip();
  inline void set_has_nport();
  inline void clear_has_nport();
  inline void set_has_struser();
  inline void clear_has_struser();
  inline void set_has_strpassword();
  inline void clear_has_strpassword();
  inline void set_has_strpasswordlevel();
  inline void clear_has_strpasswordlevel();
  inline void set_has_ndevtype();
  inline void clear_has_ndevtype();
  inline void set_has_nproducttype();
  inline void clear_has_nproducttype();
  inline void set_has_nchannum();
  inline void clear_has_nchannum();
  inline void set_has_strdeviceid();
  inline void clear_has_strdeviceid();
  inline void set_has_telchannum();
  inline void clear_has_telchannum();
  inline void set_has_nregionid();
  inline void clear_has_nregionid();
  inline void set_has_nstreamtype();
  inline void clear_has_nstreamtype();
  inline void set_has_dvrtype();
  inline void clear_has_dvrtype();
  inline void set_has_nconfigport();
  inline void clear_has_nconfigport();
  inline void set_has_strconfiguser();
  inline void clear_has_strconfiguser();
  inline void set_has_strconfigpassword();
  inline void clear_has_strconfigpassword();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_uitotalspace();
  inline void clear_has_uitotalspace();
  inline void set_has_uifreespace();
  inline void clear_has_uifreespace();
  inline void set_has_strindexcode();
  inline void clear_has_strindexcode();
  inline void set_has_strmanufacture();
  inline void clear_has_strmanufacture();
  inline void set_has_straccesskey();
  inline void clear_has_straccesskey();
  inline void set_has_strsecretkey();
  inline void clear_has_strsecretkey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 ntype_;
  ::std::string* strname_;
  ::std::string* strip_;
  ::std::string* struser_;
  ::std::string* strpassword_;
  ::google::protobuf::int32 nport_;
  ::google::protobuf::int32 ndevtype_;
  ::std::string* strpasswordlevel_;
  ::google::protobuf::int32 nproducttype_;
  ::google::protobuf::int32 nchannum_;
  ::std::string* strdeviceid_;
  ::google::protobuf::int32 telchannum_;
  ::google::protobuf::int32 nregionid_;
  ::google::protobuf::int32 nstreamtype_;
  ::google::protobuf::int32 dvrtype_;
  ::std::string* strconfiguser_;
  ::google::protobuf::int32 nconfigport_;
  ::google::protobuf::int32 online_;
  ::std::string* strconfigpassword_;
  ::google::protobuf::int32 uitotalspace_;
  ::google::protobuf::int32 uifreespace_;
  ::std::string* strindexcode_;
  ::std::string* strmanufacture_;
  ::std::string* straccesskey_;
  ::std::string* strsecretkey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fDevice_2eproto();
  friend void protobuf_AssignDesc_center_2fDevice_2eproto();
  friend void protobuf_ShutdownFile_center_2fDevice_2eproto();
  
  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class ReqDevice : public ::google::protobuf::Message {
 public:
  ReqDevice();
  virtual ~ReqDevice();
  
  ReqDevice(const ReqDevice& from);
  
  inline ReqDevice& operator=(const ReqDevice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDevice& default_instance();
  
  void Swap(ReqDevice* other);
  
  // implements Message ----------------------------------------------
  
  ReqDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqDevice& from);
  void MergeFrom(const ReqDevice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 nType = 2;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ntype() const;
  inline void set_ntype(::google::protobuf::int32 value);
  
  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string strIp = 4;
  inline bool has_strip() const;
  inline void clear_strip();
  static const int kStrIpFieldNumber = 4;
  inline const ::std::string& strip() const;
  inline void set_strip(const ::std::string& value);
  inline void set_strip(const char* value);
  inline void set_strip(const char* value, size_t size);
  inline ::std::string* mutable_strip();
  inline ::std::string* release_strip();
  
  // optional int32 nPort = 5;
  inline bool has_nport() const;
  inline void clear_nport();
  static const int kNPortFieldNumber = 5;
  inline ::google::protobuf::int32 nport() const;
  inline void set_nport(::google::protobuf::int32 value);
  
  // optional int32 online = 6;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 6;
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);
  
  // optional int32 uiTotalSpace = 7;
  inline bool has_uitotalspace() const;
  inline void clear_uitotalspace();
  static const int kUiTotalSpaceFieldNumber = 7;
  inline ::google::protobuf::int32 uitotalspace() const;
  inline void set_uitotalspace(::google::protobuf::int32 value);
  
  // optional int32 uiFreeSpace = 8;
  inline bool has_uifreespace() const;
  inline void clear_uifreespace();
  static const int kUiFreeSpaceFieldNumber = 8;
  inline ::google::protobuf::int32 uifreespace() const;
  inline void set_uifreespace(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqDevice)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_strip();
  inline void clear_has_strip();
  inline void set_has_nport();
  inline void clear_has_nport();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_uitotalspace();
  inline void clear_has_uitotalspace();
  inline void set_has_uifreespace();
  inline void clear_has_uifreespace();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 ntype_;
  ::std::string* strip_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nport_;
  ::google::protobuf::int32 online_;
  ::google::protobuf::int32 uitotalspace_;
  ::google::protobuf::int32 uifreespace_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fDevice_2eproto();
  friend void protobuf_AssignDesc_center_2fDevice_2eproto();
  friend void protobuf_ShutdownFile_center_2fDevice_2eproto();
  
  void InitAsDefaultInstance();
  static ReqDevice* default_instance_;
};
// -------------------------------------------------------------------

class DeviceList : public ::google::protobuf::Message {
 public:
  DeviceList();
  virtual ~DeviceList();
  
  DeviceList(const DeviceList& from);
  
  inline DeviceList& operator=(const DeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceList& default_instance();
  
  void Swap(DeviceList* other);
  
  // implements Message ----------------------------------------------
  
  DeviceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceList& from);
  void MergeFrom(const DeviceList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // repeated .cms_8120.Device device = 2;
  inline int device_size() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 2;
  inline const ::cms_8120::Device& device(int index) const;
  inline ::cms_8120::Device* mutable_device(int index);
  inline ::cms_8120::Device* add_device();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::Device >&
      device() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::Device >*
      mutable_device();
  
  // @@protoc_insertion_point(class_scope:cms_8120.DeviceList)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::cms_8120::Device > device_;
  ::google::protobuf::int32 cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fDevice_2eproto();
  friend void protobuf_AssignDesc_center_2fDevice_2eproto();
  friend void protobuf_ShutdownFile_center_2fDevice_2eproto();
  
  void InitAsDefaultInstance();
  static DeviceList* default_instance_;
};
// ===================================================================


// ===================================================================

// Device

// optional int32 id = 1;
inline bool Device::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Device::id() const {
  return id_;
}
inline void Device::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 nType = 2;
inline bool Device::has_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Device::set_has_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Device::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Device::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 Device::ntype() const {
  return ntype_;
}
inline void Device::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// optional string strName = 3;
inline bool Device::has_strname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Device::set_has_strname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Device::clear_has_strname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Device::clear_strname() {
  if (strname_ != &::google::protobuf::internal::kEmptyString) {
    strname_->clear();
  }
  clear_has_strname();
}
inline const ::std::string& Device::strname() const {
  return *strname_;
}
inline void Device::set_strname(const ::std::string& value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void Device::set_strname(const char* value) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(value);
}
inline void Device::set_strname(const char* value, size_t size) {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  strname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strname() {
  set_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    strname_ = new ::std::string;
  }
  return strname_;
}
inline ::std::string* Device::release_strname() {
  clear_has_strname();
  if (strname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strname_;
    strname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strIp = 4;
inline bool Device::has_strip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Device::set_has_strip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Device::clear_has_strip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Device::clear_strip() {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    strip_->clear();
  }
  clear_has_strip();
}
inline const ::std::string& Device::strip() const {
  return *strip_;
}
inline void Device::set_strip(const ::std::string& value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void Device::set_strip(const char* value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void Device::set_strip(const char* value, size_t size) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strip() {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  return strip_;
}
inline ::std::string* Device::release_strip() {
  clear_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strip_;
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nPort = 5;
inline bool Device::has_nport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Device::set_has_nport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Device::clear_has_nport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Device::clear_nport() {
  nport_ = 0;
  clear_has_nport();
}
inline ::google::protobuf::int32 Device::nport() const {
  return nport_;
}
inline void Device::set_nport(::google::protobuf::int32 value) {
  set_has_nport();
  nport_ = value;
}

// optional string strUser = 6;
inline bool Device::has_struser() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Device::set_has_struser() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Device::clear_has_struser() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Device::clear_struser() {
  if (struser_ != &::google::protobuf::internal::kEmptyString) {
    struser_->clear();
  }
  clear_has_struser();
}
inline const ::std::string& Device::struser() const {
  return *struser_;
}
inline void Device::set_struser(const ::std::string& value) {
  set_has_struser();
  if (struser_ == &::google::protobuf::internal::kEmptyString) {
    struser_ = new ::std::string;
  }
  struser_->assign(value);
}
inline void Device::set_struser(const char* value) {
  set_has_struser();
  if (struser_ == &::google::protobuf::internal::kEmptyString) {
    struser_ = new ::std::string;
  }
  struser_->assign(value);
}
inline void Device::set_struser(const char* value, size_t size) {
  set_has_struser();
  if (struser_ == &::google::protobuf::internal::kEmptyString) {
    struser_ = new ::std::string;
  }
  struser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_struser() {
  set_has_struser();
  if (struser_ == &::google::protobuf::internal::kEmptyString) {
    struser_ = new ::std::string;
  }
  return struser_;
}
inline ::std::string* Device::release_struser() {
  clear_has_struser();
  if (struser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = struser_;
    struser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strPassword = 7;
inline bool Device::has_strpassword() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Device::set_has_strpassword() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Device::clear_has_strpassword() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Device::clear_strpassword() {
  if (strpassword_ != &::google::protobuf::internal::kEmptyString) {
    strpassword_->clear();
  }
  clear_has_strpassword();
}
inline const ::std::string& Device::strpassword() const {
  return *strpassword_;
}
inline void Device::set_strpassword(const ::std::string& value) {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  strpassword_->assign(value);
}
inline void Device::set_strpassword(const char* value) {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  strpassword_->assign(value);
}
inline void Device::set_strpassword(const char* value, size_t size) {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  strpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strpassword() {
  set_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    strpassword_ = new ::std::string;
  }
  return strpassword_;
}
inline ::std::string* Device::release_strpassword() {
  clear_has_strpassword();
  if (strpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpassword_;
    strpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strPasswordLevel = 8;
inline bool Device::has_strpasswordlevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Device::set_has_strpasswordlevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Device::clear_has_strpasswordlevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Device::clear_strpasswordlevel() {
  if (strpasswordlevel_ != &::google::protobuf::internal::kEmptyString) {
    strpasswordlevel_->clear();
  }
  clear_has_strpasswordlevel();
}
inline const ::std::string& Device::strpasswordlevel() const {
  return *strpasswordlevel_;
}
inline void Device::set_strpasswordlevel(const ::std::string& value) {
  set_has_strpasswordlevel();
  if (strpasswordlevel_ == &::google::protobuf::internal::kEmptyString) {
    strpasswordlevel_ = new ::std::string;
  }
  strpasswordlevel_->assign(value);
}
inline void Device::set_strpasswordlevel(const char* value) {
  set_has_strpasswordlevel();
  if (strpasswordlevel_ == &::google::protobuf::internal::kEmptyString) {
    strpasswordlevel_ = new ::std::string;
  }
  strpasswordlevel_->assign(value);
}
inline void Device::set_strpasswordlevel(const char* value, size_t size) {
  set_has_strpasswordlevel();
  if (strpasswordlevel_ == &::google::protobuf::internal::kEmptyString) {
    strpasswordlevel_ = new ::std::string;
  }
  strpasswordlevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strpasswordlevel() {
  set_has_strpasswordlevel();
  if (strpasswordlevel_ == &::google::protobuf::internal::kEmptyString) {
    strpasswordlevel_ = new ::std::string;
  }
  return strpasswordlevel_;
}
inline ::std::string* Device::release_strpasswordlevel() {
  clear_has_strpasswordlevel();
  if (strpasswordlevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpasswordlevel_;
    strpasswordlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nDevType = 9;
inline bool Device::has_ndevtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Device::set_has_ndevtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Device::clear_has_ndevtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Device::clear_ndevtype() {
  ndevtype_ = 0;
  clear_has_ndevtype();
}
inline ::google::protobuf::int32 Device::ndevtype() const {
  return ndevtype_;
}
inline void Device::set_ndevtype(::google::protobuf::int32 value) {
  set_has_ndevtype();
  ndevtype_ = value;
}

// optional int32 nProductType = 10;
inline bool Device::has_nproducttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Device::set_has_nproducttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Device::clear_has_nproducttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Device::clear_nproducttype() {
  nproducttype_ = 0;
  clear_has_nproducttype();
}
inline ::google::protobuf::int32 Device::nproducttype() const {
  return nproducttype_;
}
inline void Device::set_nproducttype(::google::protobuf::int32 value) {
  set_has_nproducttype();
  nproducttype_ = value;
}

// optional int32 nChanNum = 11;
inline bool Device::has_nchannum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Device::set_has_nchannum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Device::clear_has_nchannum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Device::clear_nchannum() {
  nchannum_ = 0;
  clear_has_nchannum();
}
inline ::google::protobuf::int32 Device::nchannum() const {
  return nchannum_;
}
inline void Device::set_nchannum(::google::protobuf::int32 value) {
  set_has_nchannum();
  nchannum_ = value;
}

// optional string strDeviceId = 12;
inline bool Device::has_strdeviceid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Device::set_has_strdeviceid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Device::clear_has_strdeviceid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Device::clear_strdeviceid() {
  if (strdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    strdeviceid_->clear();
  }
  clear_has_strdeviceid();
}
inline const ::std::string& Device::strdeviceid() const {
  return *strdeviceid_;
}
inline void Device::set_strdeviceid(const ::std::string& value) {
  set_has_strdeviceid();
  if (strdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    strdeviceid_ = new ::std::string;
  }
  strdeviceid_->assign(value);
}
inline void Device::set_strdeviceid(const char* value) {
  set_has_strdeviceid();
  if (strdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    strdeviceid_ = new ::std::string;
  }
  strdeviceid_->assign(value);
}
inline void Device::set_strdeviceid(const char* value, size_t size) {
  set_has_strdeviceid();
  if (strdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    strdeviceid_ = new ::std::string;
  }
  strdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strdeviceid() {
  set_has_strdeviceid();
  if (strdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    strdeviceid_ = new ::std::string;
  }
  return strdeviceid_;
}
inline ::std::string* Device::release_strdeviceid() {
  clear_has_strdeviceid();
  if (strdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strdeviceid_;
    strdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 telChanNum = 13;
inline bool Device::has_telchannum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Device::set_has_telchannum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Device::clear_has_telchannum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Device::clear_telchannum() {
  telchannum_ = 0;
  clear_has_telchannum();
}
inline ::google::protobuf::int32 Device::telchannum() const {
  return telchannum_;
}
inline void Device::set_telchannum(::google::protobuf::int32 value) {
  set_has_telchannum();
  telchannum_ = value;
}

// optional int32 nRegionId = 14;
inline bool Device::has_nregionid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Device::set_has_nregionid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Device::clear_has_nregionid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Device::clear_nregionid() {
  nregionid_ = 0;
  clear_has_nregionid();
}
inline ::google::protobuf::int32 Device::nregionid() const {
  return nregionid_;
}
inline void Device::set_nregionid(::google::protobuf::int32 value) {
  set_has_nregionid();
  nregionid_ = value;
}

// optional int32 nStreamType = 15;
inline bool Device::has_nstreamtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Device::set_has_nstreamtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Device::clear_has_nstreamtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Device::clear_nstreamtype() {
  nstreamtype_ = 0;
  clear_has_nstreamtype();
}
inline ::google::protobuf::int32 Device::nstreamtype() const {
  return nstreamtype_;
}
inline void Device::set_nstreamtype(::google::protobuf::int32 value) {
  set_has_nstreamtype();
  nstreamtype_ = value;
}

// optional int32 dvrType = 16;
inline bool Device::has_dvrtype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Device::set_has_dvrtype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Device::clear_has_dvrtype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Device::clear_dvrtype() {
  dvrtype_ = 0;
  clear_has_dvrtype();
}
inline ::google::protobuf::int32 Device::dvrtype() const {
  return dvrtype_;
}
inline void Device::set_dvrtype(::google::protobuf::int32 value) {
  set_has_dvrtype();
  dvrtype_ = value;
}

// optional int32 nConfigPort = 17;
inline bool Device::has_nconfigport() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Device::set_has_nconfigport() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Device::clear_has_nconfigport() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Device::clear_nconfigport() {
  nconfigport_ = 0;
  clear_has_nconfigport();
}
inline ::google::protobuf::int32 Device::nconfigport() const {
  return nconfigport_;
}
inline void Device::set_nconfigport(::google::protobuf::int32 value) {
  set_has_nconfigport();
  nconfigport_ = value;
}

// optional string strConfigUser = 18;
inline bool Device::has_strconfiguser() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Device::set_has_strconfiguser() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Device::clear_has_strconfiguser() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Device::clear_strconfiguser() {
  if (strconfiguser_ != &::google::protobuf::internal::kEmptyString) {
    strconfiguser_->clear();
  }
  clear_has_strconfiguser();
}
inline const ::std::string& Device::strconfiguser() const {
  return *strconfiguser_;
}
inline void Device::set_strconfiguser(const ::std::string& value) {
  set_has_strconfiguser();
  if (strconfiguser_ == &::google::protobuf::internal::kEmptyString) {
    strconfiguser_ = new ::std::string;
  }
  strconfiguser_->assign(value);
}
inline void Device::set_strconfiguser(const char* value) {
  set_has_strconfiguser();
  if (strconfiguser_ == &::google::protobuf::internal::kEmptyString) {
    strconfiguser_ = new ::std::string;
  }
  strconfiguser_->assign(value);
}
inline void Device::set_strconfiguser(const char* value, size_t size) {
  set_has_strconfiguser();
  if (strconfiguser_ == &::google::protobuf::internal::kEmptyString) {
    strconfiguser_ = new ::std::string;
  }
  strconfiguser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strconfiguser() {
  set_has_strconfiguser();
  if (strconfiguser_ == &::google::protobuf::internal::kEmptyString) {
    strconfiguser_ = new ::std::string;
  }
  return strconfiguser_;
}
inline ::std::string* Device::release_strconfiguser() {
  clear_has_strconfiguser();
  if (strconfiguser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strconfiguser_;
    strconfiguser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strConfigPassword = 19;
inline bool Device::has_strconfigpassword() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Device::set_has_strconfigpassword() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Device::clear_has_strconfigpassword() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Device::clear_strconfigpassword() {
  if (strconfigpassword_ != &::google::protobuf::internal::kEmptyString) {
    strconfigpassword_->clear();
  }
  clear_has_strconfigpassword();
}
inline const ::std::string& Device::strconfigpassword() const {
  return *strconfigpassword_;
}
inline void Device::set_strconfigpassword(const ::std::string& value) {
  set_has_strconfigpassword();
  if (strconfigpassword_ == &::google::protobuf::internal::kEmptyString) {
    strconfigpassword_ = new ::std::string;
  }
  strconfigpassword_->assign(value);
}
inline void Device::set_strconfigpassword(const char* value) {
  set_has_strconfigpassword();
  if (strconfigpassword_ == &::google::protobuf::internal::kEmptyString) {
    strconfigpassword_ = new ::std::string;
  }
  strconfigpassword_->assign(value);
}
inline void Device::set_strconfigpassword(const char* value, size_t size) {
  set_has_strconfigpassword();
  if (strconfigpassword_ == &::google::protobuf::internal::kEmptyString) {
    strconfigpassword_ = new ::std::string;
  }
  strconfigpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strconfigpassword() {
  set_has_strconfigpassword();
  if (strconfigpassword_ == &::google::protobuf::internal::kEmptyString) {
    strconfigpassword_ = new ::std::string;
  }
  return strconfigpassword_;
}
inline ::std::string* Device::release_strconfigpassword() {
  clear_has_strconfigpassword();
  if (strconfigpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strconfigpassword_;
    strconfigpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 online = 20;
inline bool Device::has_online() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Device::set_has_online() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Device::clear_has_online() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Device::clear_online() {
  online_ = 0;
  clear_has_online();
}
inline ::google::protobuf::int32 Device::online() const {
  return online_;
}
inline void Device::set_online(::google::protobuf::int32 value) {
  set_has_online();
  online_ = value;
}

// optional int32 uiTotalSpace = 21;
inline bool Device::has_uitotalspace() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Device::set_has_uitotalspace() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Device::clear_has_uitotalspace() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Device::clear_uitotalspace() {
  uitotalspace_ = 0;
  clear_has_uitotalspace();
}
inline ::google::protobuf::int32 Device::uitotalspace() const {
  return uitotalspace_;
}
inline void Device::set_uitotalspace(::google::protobuf::int32 value) {
  set_has_uitotalspace();
  uitotalspace_ = value;
}

// optional int32 uiFreeSpace = 22;
inline bool Device::has_uifreespace() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Device::set_has_uifreespace() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Device::clear_has_uifreespace() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Device::clear_uifreespace() {
  uifreespace_ = 0;
  clear_has_uifreespace();
}
inline ::google::protobuf::int32 Device::uifreespace() const {
  return uifreespace_;
}
inline void Device::set_uifreespace(::google::protobuf::int32 value) {
  set_has_uifreespace();
  uifreespace_ = value;
}

// optional string strIndexCode = 23;
inline bool Device::has_strindexcode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Device::set_has_strindexcode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Device::clear_has_strindexcode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Device::clear_strindexcode() {
  if (strindexcode_ != &::google::protobuf::internal::kEmptyString) {
    strindexcode_->clear();
  }
  clear_has_strindexcode();
}
inline const ::std::string& Device::strindexcode() const {
  return *strindexcode_;
}
inline void Device::set_strindexcode(const ::std::string& value) {
  set_has_strindexcode();
  if (strindexcode_ == &::google::protobuf::internal::kEmptyString) {
    strindexcode_ = new ::std::string;
  }
  strindexcode_->assign(value);
}
inline void Device::set_strindexcode(const char* value) {
  set_has_strindexcode();
  if (strindexcode_ == &::google::protobuf::internal::kEmptyString) {
    strindexcode_ = new ::std::string;
  }
  strindexcode_->assign(value);
}
inline void Device::set_strindexcode(const char* value, size_t size) {
  set_has_strindexcode();
  if (strindexcode_ == &::google::protobuf::internal::kEmptyString) {
    strindexcode_ = new ::std::string;
  }
  strindexcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strindexcode() {
  set_has_strindexcode();
  if (strindexcode_ == &::google::protobuf::internal::kEmptyString) {
    strindexcode_ = new ::std::string;
  }
  return strindexcode_;
}
inline ::std::string* Device::release_strindexcode() {
  clear_has_strindexcode();
  if (strindexcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strindexcode_;
    strindexcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strManufacture = 24;
inline bool Device::has_strmanufacture() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Device::set_has_strmanufacture() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Device::clear_has_strmanufacture() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Device::clear_strmanufacture() {
  if (strmanufacture_ != &::google::protobuf::internal::kEmptyString) {
    strmanufacture_->clear();
  }
  clear_has_strmanufacture();
}
inline const ::std::string& Device::strmanufacture() const {
  return *strmanufacture_;
}
inline void Device::set_strmanufacture(const ::std::string& value) {
  set_has_strmanufacture();
  if (strmanufacture_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacture_ = new ::std::string;
  }
  strmanufacture_->assign(value);
}
inline void Device::set_strmanufacture(const char* value) {
  set_has_strmanufacture();
  if (strmanufacture_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacture_ = new ::std::string;
  }
  strmanufacture_->assign(value);
}
inline void Device::set_strmanufacture(const char* value, size_t size) {
  set_has_strmanufacture();
  if (strmanufacture_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacture_ = new ::std::string;
  }
  strmanufacture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strmanufacture() {
  set_has_strmanufacture();
  if (strmanufacture_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacture_ = new ::std::string;
  }
  return strmanufacture_;
}
inline ::std::string* Device::release_strmanufacture() {
  clear_has_strmanufacture();
  if (strmanufacture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmanufacture_;
    strmanufacture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strAccessKey = 25;
inline bool Device::has_straccesskey() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Device::set_has_straccesskey() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Device::clear_has_straccesskey() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Device::clear_straccesskey() {
  if (straccesskey_ != &::google::protobuf::internal::kEmptyString) {
    straccesskey_->clear();
  }
  clear_has_straccesskey();
}
inline const ::std::string& Device::straccesskey() const {
  return *straccesskey_;
}
inline void Device::set_straccesskey(const ::std::string& value) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(value);
}
inline void Device::set_straccesskey(const char* value) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(value);
}
inline void Device::set_straccesskey(const char* value, size_t size) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_straccesskey() {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  return straccesskey_;
}
inline ::std::string* Device::release_straccesskey() {
  clear_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccesskey_;
    straccesskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strSecretKey = 26;
inline bool Device::has_strsecretkey() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Device::set_has_strsecretkey() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Device::clear_has_strsecretkey() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Device::clear_strsecretkey() {
  if (strsecretkey_ != &::google::protobuf::internal::kEmptyString) {
    strsecretkey_->clear();
  }
  clear_has_strsecretkey();
}
inline const ::std::string& Device::strsecretkey() const {
  return *strsecretkey_;
}
inline void Device::set_strsecretkey(const ::std::string& value) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(value);
}
inline void Device::set_strsecretkey(const char* value) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(value);
}
inline void Device::set_strsecretkey(const char* value, size_t size) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_strsecretkey() {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  return strsecretkey_;
}
inline ::std::string* Device::release_strsecretkey() {
  clear_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsecretkey_;
    strsecretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqDevice

// optional int32 cmd = 1;
inline bool ReqDevice::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqDevice::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqDevice::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqDevice::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqDevice::cmd() const {
  return cmd_;
}
inline void ReqDevice::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 nType = 2;
inline bool ReqDevice::has_ntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqDevice::set_has_ntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqDevice::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqDevice::clear_ntype() {
  ntype_ = 0;
  clear_has_ntype();
}
inline ::google::protobuf::int32 ReqDevice::ntype() const {
  return ntype_;
}
inline void ReqDevice::set_ntype(::google::protobuf::int32 value) {
  set_has_ntype();
  ntype_ = value;
}

// optional int32 id = 3;
inline bool ReqDevice::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqDevice::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqDevice::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqDevice::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqDevice::id() const {
  return id_;
}
inline void ReqDevice::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string strIp = 4;
inline bool ReqDevice::has_strip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqDevice::set_has_strip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqDevice::clear_has_strip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqDevice::clear_strip() {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    strip_->clear();
  }
  clear_has_strip();
}
inline const ::std::string& ReqDevice::strip() const {
  return *strip_;
}
inline void ReqDevice::set_strip(const ::std::string& value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void ReqDevice::set_strip(const char* value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void ReqDevice::set_strip(const char* value, size_t size) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqDevice::mutable_strip() {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  return strip_;
}
inline ::std::string* ReqDevice::release_strip() {
  clear_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strip_;
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nPort = 5;
inline bool ReqDevice::has_nport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqDevice::set_has_nport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqDevice::clear_has_nport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqDevice::clear_nport() {
  nport_ = 0;
  clear_has_nport();
}
inline ::google::protobuf::int32 ReqDevice::nport() const {
  return nport_;
}
inline void ReqDevice::set_nport(::google::protobuf::int32 value) {
  set_has_nport();
  nport_ = value;
}

// optional int32 online = 6;
inline bool ReqDevice::has_online() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqDevice::set_has_online() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqDevice::clear_has_online() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqDevice::clear_online() {
  online_ = 0;
  clear_has_online();
}
inline ::google::protobuf::int32 ReqDevice::online() const {
  return online_;
}
inline void ReqDevice::set_online(::google::protobuf::int32 value) {
  set_has_online();
  online_ = value;
}

// optional int32 uiTotalSpace = 7;
inline bool ReqDevice::has_uitotalspace() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqDevice::set_has_uitotalspace() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqDevice::clear_has_uitotalspace() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqDevice::clear_uitotalspace() {
  uitotalspace_ = 0;
  clear_has_uitotalspace();
}
inline ::google::protobuf::int32 ReqDevice::uitotalspace() const {
  return uitotalspace_;
}
inline void ReqDevice::set_uitotalspace(::google::protobuf::int32 value) {
  set_has_uitotalspace();
  uitotalspace_ = value;
}

// optional int32 uiFreeSpace = 8;
inline bool ReqDevice::has_uifreespace() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqDevice::set_has_uifreespace() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqDevice::clear_has_uifreespace() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqDevice::clear_uifreespace() {
  uifreespace_ = 0;
  clear_has_uifreespace();
}
inline ::google::protobuf::int32 ReqDevice::uifreespace() const {
  return uifreespace_;
}
inline void ReqDevice::set_uifreespace(::google::protobuf::int32 value) {
  set_has_uifreespace();
  uifreespace_ = value;
}

// -------------------------------------------------------------------

// DeviceList

// optional int32 cmd = 1;
inline bool DeviceList::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceList::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceList::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceList::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 DeviceList::cmd() const {
  return cmd_;
}
inline void DeviceList::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// repeated .cms_8120.Device device = 2;
inline int DeviceList::device_size() const {
  return device_.size();
}
inline void DeviceList::clear_device() {
  device_.Clear();
}
inline const ::cms_8120::Device& DeviceList::device(int index) const {
  return device_.Get(index);
}
inline ::cms_8120::Device* DeviceList::mutable_device(int index) {
  return device_.Mutable(index);
}
inline ::cms_8120::Device* DeviceList::add_device() {
  return device_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::Device >&
DeviceList::device() const {
  return device_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::Device >*
DeviceList::mutable_device() {
  return &device_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_center_2fDevice_2eproto__INCLUDED
