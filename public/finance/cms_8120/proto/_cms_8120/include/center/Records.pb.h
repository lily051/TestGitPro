// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: center/Records.proto

#ifndef PROTOBUF_center_2fRecords_2eproto__INCLUDED
#define PROTOBUF_center_2fRecords_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "server/RspServerData.pb.h"
// @@protoc_insertion_point(includes)

namespace cms_8120 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_center_2fRecords_2eproto();
void protobuf_AssignDesc_center_2fRecords_2eproto();
void protobuf_ShutdownFile_center_2fRecords_2eproto();

class Records;
class ReqRecords;
class RecordsList;

// ===================================================================

class Records : public ::google::protobuf::Message {
 public:
  Records();
  virtual ~Records();
  
  Records(const Records& from);
  
  inline Records& operator=(const Records& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Records& default_instance();
  
  void Swap(Records* other);
  
  // implements Message ----------------------------------------------
  
  Records* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Records& from);
  void MergeFrom(const Records& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 nCollectRegionId = 2;
  inline bool has_ncollectregionid() const;
  inline void clear_ncollectregionid();
  static const int kNCollectRegionIdFieldNumber = 2;
  inline ::google::protobuf::int32 ncollectregionid() const;
  inline void set_ncollectregionid(::google::protobuf::int32 value);
  
  // optional int32 nUserID = 3;
  inline bool has_nuserid() const;
  inline void clear_nuserid();
  static const int kNUserIDFieldNumber = 3;
  inline ::google::protobuf::int32 nuserid() const;
  inline void set_nuserid(::google::protobuf::int32 value);
  
  // optional string strRecordName = 4;
  inline bool has_strrecordname() const;
  inline void clear_strrecordname();
  static const int kStrRecordNameFieldNumber = 4;
  inline const ::std::string& strrecordname() const;
  inline void set_strrecordname(const ::std::string& value);
  inline void set_strrecordname(const char* value);
  inline void set_strrecordname(const char* value, size_t size);
  inline ::std::string* mutable_strrecordname();
  inline ::std::string* release_strrecordname();
  
  // optional int32 nRecordType = 5;
  inline bool has_nrecordtype() const;
  inline void clear_nrecordtype();
  static const int kNRecordTypeFieldNumber = 5;
  inline ::google::protobuf::int32 nrecordtype() const;
  inline void set_nrecordtype(::google::protobuf::int32 value);
  
  // optional int32 nRecordFileType = 6;
  inline bool has_nrecordfiletype() const;
  inline void clear_nrecordfiletype();
  static const int kNRecordFileTypeFieldNumber = 6;
  inline ::google::protobuf::int32 nrecordfiletype() const;
  inline void set_nrecordfiletype(::google::protobuf::int32 value);
  
  // optional int32 nRecordStatus = 7;
  inline bool has_nrecordstatus() const;
  inline void clear_nrecordstatus();
  static const int kNRecordStatusFieldNumber = 7;
  inline ::google::protobuf::int32 nrecordstatus() const;
  inline void set_nrecordstatus(::google::protobuf::int32 value);
  
  // optional int32 nUploadPercent = 8;
  inline bool has_nuploadpercent() const;
  inline void clear_nuploadpercent();
  static const int kNUploadPercentFieldNumber = 8;
  inline ::google::protobuf::int32 nuploadpercent() const;
  inline void set_nuploadpercent(::google::protobuf::int32 value);
  
  // optional string startTime = 9 [default = "1970-01-01 00:00:00"];
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 9;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  
  // optional string endTime = 10 [default = "1970-01-01 00:00:00"];
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 10;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  
  // optional int32 nRecordBeginTime = 11;
  inline bool has_nrecordbegintime() const;
  inline void clear_nrecordbegintime();
  static const int kNRecordBeginTimeFieldNumber = 11;
  inline ::google::protobuf::int32 nrecordbegintime() const;
  inline void set_nrecordbegintime(::google::protobuf::int32 value);
  
  // optional int32 nRecordEndTime = 12;
  inline bool has_nrecordendtime() const;
  inline void clear_nrecordendtime();
  static const int kNRecordEndTimeFieldNumber = 12;
  inline ::google::protobuf::int32 nrecordendtime() const;
  inline void set_nrecordendtime(::google::protobuf::int32 value);
  
  // optional string streamNo = 13;
  inline bool has_streamno() const;
  inline void clear_streamno();
  static const int kStreamNoFieldNumber = 13;
  inline const ::std::string& streamno() const;
  inline void set_streamno(const ::std::string& value);
  inline void set_streamno(const char* value);
  inline void set_streamno(const char* value, size_t size);
  inline ::std::string* mutable_streamno();
  inline ::std::string* release_streamno();
  
  // optional int32 nRepairDevId = 14;
  inline bool has_nrepairdevid() const;
  inline void clear_nrepairdevid();
  static const int kNRepairDevIdFieldNumber = 14;
  inline ::google::protobuf::int32 nrepairdevid() const;
  inline void set_nrepairdevid(::google::protobuf::int32 value);
  
  // optional string strCollectIp = 15;
  inline bool has_strcollectip() const;
  inline void clear_strcollectip();
  static const int kStrCollectIpFieldNumber = 15;
  inline const ::std::string& strcollectip() const;
  inline void set_strcollectip(const ::std::string& value);
  inline void set_strcollectip(const char* value);
  inline void set_strcollectip(const char* value, size_t size);
  inline ::std::string* mutable_strcollectip();
  inline ::std::string* release_strcollectip();
  
  // optional int32 dvrPort = 16;
  inline bool has_dvrport() const;
  inline void clear_dvrport();
  static const int kDvrPortFieldNumber = 16;
  inline ::google::protobuf::int32 dvrport() const;
  inline void set_dvrport(::google::protobuf::int32 value);
  
  // optional string dvrUserName = 17;
  inline bool has_dvrusername() const;
  inline void clear_dvrusername();
  static const int kDvrUserNameFieldNumber = 17;
  inline const ::std::string& dvrusername() const;
  inline void set_dvrusername(const ::std::string& value);
  inline void set_dvrusername(const char* value);
  inline void set_dvrusername(const char* value, size_t size);
  inline ::std::string* mutable_dvrusername();
  inline ::std::string* release_dvrusername();
  
  // optional string dvrPwd = 18;
  inline bool has_dvrpwd() const;
  inline void clear_dvrpwd();
  static const int kDvrPwdFieldNumber = 18;
  inline const ::std::string& dvrpwd() const;
  inline void set_dvrpwd(const ::std::string& value);
  inline void set_dvrpwd(const char* value);
  inline void set_dvrpwd(const char* value, size_t size);
  inline ::std::string* mutable_dvrpwd();
  inline ::std::string* release_dvrpwd();
  
  // optional int32 nCollectChan = 19;
  inline bool has_ncollectchan() const;
  inline void clear_ncollectchan();
  static const int kNCollectChanFieldNumber = 19;
  inline ::google::protobuf::int32 ncollectchan() const;
  inline void set_ncollectchan(::google::protobuf::int32 value);
  
  // optional string strUrl = 20;
  inline bool has_strurl() const;
  inline void clear_strurl();
  static const int kStrUrlFieldNumber = 20;
  inline const ::std::string& strurl() const;
  inline void set_strurl(const ::std::string& value);
  inline void set_strurl(const char* value);
  inline void set_strurl(const char* value, size_t size);
  inline ::std::string* mutable_strurl();
  inline ::std::string* release_strurl();
  
  // optional string screenshotSrc = 21;
  inline bool has_screenshotsrc() const;
  inline void clear_screenshotsrc();
  static const int kScreenshotSrcFieldNumber = 21;
  inline const ::std::string& screenshotsrc() const;
  inline void set_screenshotsrc(const ::std::string& value);
  inline void set_screenshotsrc(const char* value);
  inline void set_screenshotsrc(const char* value, size_t size);
  inline ::std::string* mutable_screenshotsrc();
  inline ::std::string* release_screenshotsrc();
  
  // optional string dtBusinessTime = 22 [default = "1970-01-01 00:00:00"];
  inline bool has_dtbusinesstime() const;
  inline void clear_dtbusinesstime();
  static const int kDtBusinessTimeFieldNumber = 22;
  inline const ::std::string& dtbusinesstime() const;
  inline void set_dtbusinesstime(const ::std::string& value);
  inline void set_dtbusinesstime(const char* value);
  inline void set_dtbusinesstime(const char* value, size_t size);
  inline ::std::string* mutable_dtbusinesstime();
  inline ::std::string* release_dtbusinesstime();
  
  // optional int32 nRecordLocalTime = 23;
  inline bool has_nrecordlocaltime() const;
  inline void clear_nrecordlocaltime();
  static const int kNRecordLocalTimeFieldNumber = 23;
  inline ::google::protobuf::int32 nrecordlocaltime() const;
  inline void set_nrecordlocaltime(::google::protobuf::int32 value);
  
  // optional int32 nFileHeadLen = 24;
  inline bool has_nfileheadlen() const;
  inline void clear_nfileheadlen();
  static const int kNFileHeadLenFieldNumber = 24;
  inline ::google::protobuf::int32 nfileheadlen() const;
  inline void set_nfileheadlen(::google::protobuf::int32 value);
  
  // optional int32 nCallerType = 25;
  inline bool has_ncallertype() const;
  inline void clear_ncallertype();
  static const int kNCallerTypeFieldNumber = 25;
  inline ::google::protobuf::int32 ncallertype() const;
  inline void set_ncallertype(::google::protobuf::int32 value);
  
  // optional string strCallerId = 26;
  inline bool has_strcallerid() const;
  inline void clear_strcallerid();
  static const int kStrCallerIdFieldNumber = 26;
  inline const ::std::string& strcallerid() const;
  inline void set_strcallerid(const ::std::string& value);
  inline void set_strcallerid(const char* value);
  inline void set_strcallerid(const char* value, size_t size);
  inline ::std::string* mutable_strcallerid();
  inline ::std::string* release_strcallerid();
  
  // optional int32 nRepairType = 27;
  inline bool has_nrepairtype() const;
  inline void clear_nrepairtype();
  static const int kNRepairTypeFieldNumber = 27;
  inline ::google::protobuf::int32 nrepairtype() const;
  inline void set_nrepairtype(::google::protobuf::int32 value);
  
  // optional int32 nRepairTime = 28;
  inline bool has_nrepairtime() const;
  inline void clear_nrepairtime();
  static const int kNRepairTimeFieldNumber = 28;
  inline ::google::protobuf::int32 nrepairtime() const;
  inline void set_nrepairtime(::google::protobuf::int32 value);
  
  // optional int32 nLinkOrderId = 29;
  inline bool has_nlinkorderid() const;
  inline void clear_nlinkorderid();
  static const int kNLinkOrderIdFieldNumber = 29;
  inline ::google::protobuf::int32 nlinkorderid() const;
  inline void set_nlinkorderid(::google::protobuf::int32 value);
  
  // optional int32 nLinkType = 30;
  inline bool has_nlinktype() const;
  inline void clear_nlinktype();
  static const int kNLinkTypeFieldNumber = 30;
  inline ::google::protobuf::int32 nlinktype() const;
  inline void set_nlinktype(::google::protobuf::int32 value);
  
  // optional int32 nManufacturerType = 31;
  inline bool has_nmanufacturertype() const;
  inline void clear_nmanufacturertype();
  static const int kNManufacturerTypeFieldNumber = 31;
  inline ::google::protobuf::int32 nmanufacturertype() const;
  inline void set_nmanufacturertype(::google::protobuf::int32 value);
  
  // optional int32 nFileSize = 32;
  inline bool has_nfilesize() const;
  inline void clear_nfilesize();
  static const int kNFileSizeFieldNumber = 32;
  inline ::google::protobuf::int32 nfilesize() const;
  inline void set_nfilesize(::google::protobuf::int32 value);
  
  // optional int32 nTaskId = 33;
  inline bool has_ntaskid() const;
  inline void clear_ntaskid();
  static const int kNTaskIdFieldNumber = 33;
  inline ::google::protobuf::int32 ntaskid() const;
  inline void set_ntaskid(::google::protobuf::int32 value);
  
  // optional string strIp = 34;
  inline bool has_strip() const;
  inline void clear_strip();
  static const int kStrIpFieldNumber = 34;
  inline const ::std::string& strip() const;
  inline void set_strip(const ::std::string& value);
  inline void set_strip(const char* value);
  inline void set_strip(const char* value, size_t size);
  inline ::std::string* mutable_strip();
  inline ::std::string* release_strip();
  
  // optional string strCloudIp = 35;
  inline bool has_strcloudip() const;
  inline void clear_strcloudip();
  static const int kStrCloudIpFieldNumber = 35;
  inline const ::std::string& strcloudip() const;
  inline void set_strcloudip(const ::std::string& value);
  inline void set_strcloudip(const char* value);
  inline void set_strcloudip(const char* value, size_t size);
  inline ::std::string* mutable_strcloudip();
  inline ::std::string* release_strcloudip();
  
  // optional int32 nCloudPort = 36;
  inline bool has_ncloudport() const;
  inline void clear_ncloudport();
  static const int kNCloudPortFieldNumber = 36;
  inline ::google::protobuf::int32 ncloudport() const;
  inline void set_ncloudport(::google::protobuf::int32 value);
  
  // optional string strAccessKey = 37;
  inline bool has_straccesskey() const;
  inline void clear_straccesskey();
  static const int kStrAccessKeyFieldNumber = 37;
  inline const ::std::string& straccesskey() const;
  inline void set_straccesskey(const ::std::string& value);
  inline void set_straccesskey(const char* value);
  inline void set_straccesskey(const char* value, size_t size);
  inline ::std::string* mutable_straccesskey();
  inline ::std::string* release_straccesskey();
  
  // optional string strSecretKey = 38;
  inline bool has_strsecretkey() const;
  inline void clear_strsecretkey();
  static const int kStrSecretKeyFieldNumber = 38;
  inline const ::std::string& strsecretkey() const;
  inline void set_strsecretkey(const ::std::string& value);
  inline void set_strsecretkey(const char* value);
  inline void set_strsecretkey(const char* value, size_t size);
  inline ::std::string* mutable_strsecretkey();
  inline ::std::string* release_strsecretkey();
  
  // optional string strBucket = 39;
  inline bool has_strbucket() const;
  inline void clear_strbucket();
  static const int kStrBucketFieldNumber = 39;
  inline const ::std::string& strbucket() const;
  inline void set_strbucket(const ::std::string& value);
  inline void set_strbucket(const char* value);
  inline void set_strbucket(const char* value, size_t size);
  inline ::std::string* mutable_strbucket();
  inline ::std::string* release_strbucket();
  
  // @@protoc_insertion_point(class_scope:cms_8120.Records)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ncollectregionid();
  inline void clear_has_ncollectregionid();
  inline void set_has_nuserid();
  inline void clear_has_nuserid();
  inline void set_has_strrecordname();
  inline void clear_has_strrecordname();
  inline void set_has_nrecordtype();
  inline void clear_has_nrecordtype();
  inline void set_has_nrecordfiletype();
  inline void clear_has_nrecordfiletype();
  inline void set_has_nrecordstatus();
  inline void clear_has_nrecordstatus();
  inline void set_has_nuploadpercent();
  inline void clear_has_nuploadpercent();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_nrecordbegintime();
  inline void clear_has_nrecordbegintime();
  inline void set_has_nrecordendtime();
  inline void clear_has_nrecordendtime();
  inline void set_has_streamno();
  inline void clear_has_streamno();
  inline void set_has_nrepairdevid();
  inline void clear_has_nrepairdevid();
  inline void set_has_strcollectip();
  inline void clear_has_strcollectip();
  inline void set_has_dvrport();
  inline void clear_has_dvrport();
  inline void set_has_dvrusername();
  inline void clear_has_dvrusername();
  inline void set_has_dvrpwd();
  inline void clear_has_dvrpwd();
  inline void set_has_ncollectchan();
  inline void clear_has_ncollectchan();
  inline void set_has_strurl();
  inline void clear_has_strurl();
  inline void set_has_screenshotsrc();
  inline void clear_has_screenshotsrc();
  inline void set_has_dtbusinesstime();
  inline void clear_has_dtbusinesstime();
  inline void set_has_nrecordlocaltime();
  inline void clear_has_nrecordlocaltime();
  inline void set_has_nfileheadlen();
  inline void clear_has_nfileheadlen();
  inline void set_has_ncallertype();
  inline void clear_has_ncallertype();
  inline void set_has_strcallerid();
  inline void clear_has_strcallerid();
  inline void set_has_nrepairtype();
  inline void clear_has_nrepairtype();
  inline void set_has_nrepairtime();
  inline void clear_has_nrepairtime();
  inline void set_has_nlinkorderid();
  inline void clear_has_nlinkorderid();
  inline void set_has_nlinktype();
  inline void clear_has_nlinktype();
  inline void set_has_nmanufacturertype();
  inline void clear_has_nmanufacturertype();
  inline void set_has_nfilesize();
  inline void clear_has_nfilesize();
  inline void set_has_ntaskid();
  inline void clear_has_ntaskid();
  inline void set_has_strip();
  inline void clear_has_strip();
  inline void set_has_strcloudip();
  inline void clear_has_strcloudip();
  inline void set_has_ncloudport();
  inline void clear_has_ncloudport();
  inline void set_has_straccesskey();
  inline void clear_has_straccesskey();
  inline void set_has_strsecretkey();
  inline void clear_has_strsecretkey();
  inline void set_has_strbucket();
  inline void clear_has_strbucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 ncollectregionid_;
  ::google::protobuf::int32 nuserid_;
  ::google::protobuf::int32 nrecordtype_;
  ::std::string* strrecordname_;
  ::google::protobuf::int32 nrecordfiletype_;
  ::google::protobuf::int32 nrecordstatus_;
  ::std::string* starttime_;
  static const ::std::string _default_starttime_;
  ::google::protobuf::int32 nuploadpercent_;
  ::google::protobuf::int32 nrecordbegintime_;
  ::std::string* endtime_;
  static const ::std::string _default_endtime_;
  ::std::string* streamno_;
  ::google::protobuf::int32 nrecordendtime_;
  ::google::protobuf::int32 nrepairdevid_;
  ::std::string* strcollectip_;
  ::std::string* dvrusername_;
  ::google::protobuf::int32 dvrport_;
  ::google::protobuf::int32 ncollectchan_;
  ::std::string* dvrpwd_;
  ::std::string* strurl_;
  ::std::string* screenshotsrc_;
  ::std::string* dtbusinesstime_;
  static const ::std::string _default_dtbusinesstime_;
  ::google::protobuf::int32 nrecordlocaltime_;
  ::google::protobuf::int32 nfileheadlen_;
  ::std::string* strcallerid_;
  ::google::protobuf::int32 ncallertype_;
  ::google::protobuf::int32 nrepairtype_;
  ::google::protobuf::int32 nrepairtime_;
  ::google::protobuf::int32 nlinkorderid_;
  ::google::protobuf::int32 nlinktype_;
  ::google::protobuf::int32 nmanufacturertype_;
  ::google::protobuf::int32 nfilesize_;
  ::google::protobuf::int32 ntaskid_;
  ::std::string* strip_;
  ::std::string* strcloudip_;
  ::std::string* straccesskey_;
  ::std::string* strsecretkey_;
  ::std::string* strbucket_;
  ::google::protobuf::int32 ncloudport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fRecords_2eproto();
  friend void protobuf_AssignDesc_center_2fRecords_2eproto();
  friend void protobuf_ShutdownFile_center_2fRecords_2eproto();
  
  void InitAsDefaultInstance();
  static Records* default_instance_;
};
// -------------------------------------------------------------------

class ReqRecords : public ::google::protobuf::Message {
 public:
  ReqRecords();
  virtual ~ReqRecords();
  
  ReqRecords(const ReqRecords& from);
  
  inline ReqRecords& operator=(const ReqRecords& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqRecords& default_instance();
  
  void Swap(ReqRecords* other);
  
  // implements Message ----------------------------------------------
  
  ReqRecords* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqRecords& from);
  void MergeFrom(const ReqRecords& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 nRecordStatus = 3;
  inline bool has_nrecordstatus() const;
  inline void clear_nrecordstatus();
  static const int kNRecordStatusFieldNumber = 3;
  inline ::google::protobuf::int32 nrecordstatus() const;
  inline void set_nrecordstatus(::google::protobuf::int32 value);
  
  // optional int32 nUpLoadPercent = 4;
  inline bool has_nuploadpercent() const;
  inline void clear_nuploadpercent();
  static const int kNUpLoadPercentFieldNumber = 4;
  inline ::google::protobuf::int32 nuploadpercent() const;
  inline void set_nuploadpercent(::google::protobuf::int32 value);
  
  // optional int32 nTaskId = 5;
  inline bool has_ntaskid() const;
  inline void clear_ntaskid();
  static const int kNTaskIdFieldNumber = 5;
  inline ::google::protobuf::int32 ntaskid() const;
  inline void set_ntaskid(::google::protobuf::int32 value);
  
  // optional string streamNo = 6;
  inline bool has_streamno() const;
  inline void clear_streamno();
  static const int kStreamNoFieldNumber = 6;
  inline const ::std::string& streamno() const;
  inline void set_streamno(const ::std::string& value);
  inline void set_streamno(const char* value);
  inline void set_streamno(const char* value, size_t size);
  inline ::std::string* mutable_streamno();
  inline ::std::string* release_streamno();
  
  // optional string rtspPath = 7;
  inline bool has_rtsppath() const;
  inline void clear_rtsppath();
  static const int kRtspPathFieldNumber = 7;
  inline const ::std::string& rtsppath() const;
  inline void set_rtsppath(const ::std::string& value);
  inline void set_rtsppath(const char* value);
  inline void set_rtsppath(const char* value, size_t size);
  inline ::std::string* mutable_rtsppath();
  inline ::std::string* release_rtsppath();
  
  // optional int32 nFileSize = 8;
  inline bool has_nfilesize() const;
  inline void clear_nfilesize();
  static const int kNFileSizeFieldNumber = 8;
  inline ::google::protobuf::int32 nfilesize() const;
  inline void set_nfilesize(::google::protobuf::int32 value);
  
  // optional string errorMsg = 9;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 9;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  
  // optional string startTime = 10;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 10;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  
  // optional string endTime = 11;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 11;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  
  // @@protoc_insertion_point(class_scope:cms_8120.ReqRecords)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nrecordstatus();
  inline void clear_has_nrecordstatus();
  inline void set_has_nuploadpercent();
  inline void clear_has_nuploadpercent();
  inline void set_has_ntaskid();
  inline void clear_has_ntaskid();
  inline void set_has_streamno();
  inline void clear_has_streamno();
  inline void set_has_rtsppath();
  inline void clear_has_rtsppath();
  inline void set_has_nfilesize();
  inline void clear_has_nfilesize();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nrecordstatus_;
  ::google::protobuf::int32 nuploadpercent_;
  ::std::string* streamno_;
  ::google::protobuf::int32 ntaskid_;
  ::google::protobuf::int32 nfilesize_;
  ::std::string* rtsppath_;
  ::std::string* errormsg_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fRecords_2eproto();
  friend void protobuf_AssignDesc_center_2fRecords_2eproto();
  friend void protobuf_ShutdownFile_center_2fRecords_2eproto();
  
  void InitAsDefaultInstance();
  static ReqRecords* default_instance_;
};
// -------------------------------------------------------------------

class RecordsList : public ::google::protobuf::Message {
 public:
  RecordsList();
  virtual ~RecordsList();
  
  RecordsList(const RecordsList& from);
  
  inline RecordsList& operator=(const RecordsList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordsList& default_instance();
  
  void Swap(RecordsList* other);
  
  // implements Message ----------------------------------------------
  
  RecordsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordsList& from);
  void MergeFrom(const RecordsList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);
  
  // repeated .cms_8120.Records record = 2;
  inline int record_size() const;
  inline void clear_record();
  static const int kRecordFieldNumber = 2;
  inline const ::cms_8120::Records& record(int index) const;
  inline ::cms_8120::Records* mutable_record(int index);
  inline ::cms_8120::Records* add_record();
  inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::Records >&
      record() const;
  inline ::google::protobuf::RepeatedPtrField< ::cms_8120::Records >*
      mutable_record();
  
  // @@protoc_insertion_point(class_scope:cms_8120.RecordsList)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::cms_8120::Records > record_;
  ::google::protobuf::int32 cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_center_2fRecords_2eproto();
  friend void protobuf_AssignDesc_center_2fRecords_2eproto();
  friend void protobuf_ShutdownFile_center_2fRecords_2eproto();
  
  void InitAsDefaultInstance();
  static RecordsList* default_instance_;
};
// ===================================================================


// ===================================================================

// Records

// optional int32 id = 1;
inline bool Records::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Records::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Records::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Records::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Records::id() const {
  return id_;
}
inline void Records::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 nCollectRegionId = 2;
inline bool Records::has_ncollectregionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Records::set_has_ncollectregionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Records::clear_has_ncollectregionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Records::clear_ncollectregionid() {
  ncollectregionid_ = 0;
  clear_has_ncollectregionid();
}
inline ::google::protobuf::int32 Records::ncollectregionid() const {
  return ncollectregionid_;
}
inline void Records::set_ncollectregionid(::google::protobuf::int32 value) {
  set_has_ncollectregionid();
  ncollectregionid_ = value;
}

// optional int32 nUserID = 3;
inline bool Records::has_nuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Records::set_has_nuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Records::clear_has_nuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Records::clear_nuserid() {
  nuserid_ = 0;
  clear_has_nuserid();
}
inline ::google::protobuf::int32 Records::nuserid() const {
  return nuserid_;
}
inline void Records::set_nuserid(::google::protobuf::int32 value) {
  set_has_nuserid();
  nuserid_ = value;
}

// optional string strRecordName = 4;
inline bool Records::has_strrecordname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Records::set_has_strrecordname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Records::clear_has_strrecordname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Records::clear_strrecordname() {
  if (strrecordname_ != &::google::protobuf::internal::kEmptyString) {
    strrecordname_->clear();
  }
  clear_has_strrecordname();
}
inline const ::std::string& Records::strrecordname() const {
  return *strrecordname_;
}
inline void Records::set_strrecordname(const ::std::string& value) {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  strrecordname_->assign(value);
}
inline void Records::set_strrecordname(const char* value) {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  strrecordname_->assign(value);
}
inline void Records::set_strrecordname(const char* value, size_t size) {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  strrecordname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strrecordname() {
  set_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    strrecordname_ = new ::std::string;
  }
  return strrecordname_;
}
inline ::std::string* Records::release_strrecordname() {
  clear_has_strrecordname();
  if (strrecordname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrecordname_;
    strrecordname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nRecordType = 5;
inline bool Records::has_nrecordtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Records::set_has_nrecordtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Records::clear_has_nrecordtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Records::clear_nrecordtype() {
  nrecordtype_ = 0;
  clear_has_nrecordtype();
}
inline ::google::protobuf::int32 Records::nrecordtype() const {
  return nrecordtype_;
}
inline void Records::set_nrecordtype(::google::protobuf::int32 value) {
  set_has_nrecordtype();
  nrecordtype_ = value;
}

// optional int32 nRecordFileType = 6;
inline bool Records::has_nrecordfiletype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Records::set_has_nrecordfiletype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Records::clear_has_nrecordfiletype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Records::clear_nrecordfiletype() {
  nrecordfiletype_ = 0;
  clear_has_nrecordfiletype();
}
inline ::google::protobuf::int32 Records::nrecordfiletype() const {
  return nrecordfiletype_;
}
inline void Records::set_nrecordfiletype(::google::protobuf::int32 value) {
  set_has_nrecordfiletype();
  nrecordfiletype_ = value;
}

// optional int32 nRecordStatus = 7;
inline bool Records::has_nrecordstatus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Records::set_has_nrecordstatus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Records::clear_has_nrecordstatus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Records::clear_nrecordstatus() {
  nrecordstatus_ = 0;
  clear_has_nrecordstatus();
}
inline ::google::protobuf::int32 Records::nrecordstatus() const {
  return nrecordstatus_;
}
inline void Records::set_nrecordstatus(::google::protobuf::int32 value) {
  set_has_nrecordstatus();
  nrecordstatus_ = value;
}

// optional int32 nUploadPercent = 8;
inline bool Records::has_nuploadpercent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Records::set_has_nuploadpercent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Records::clear_has_nuploadpercent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Records::clear_nuploadpercent() {
  nuploadpercent_ = 0;
  clear_has_nuploadpercent();
}
inline ::google::protobuf::int32 Records::nuploadpercent() const {
  return nuploadpercent_;
}
inline void Records::set_nuploadpercent(::google::protobuf::int32 value) {
  set_has_nuploadpercent();
  nuploadpercent_ = value;
}

// optional string startTime = 9 [default = "1970-01-01 00:00:00"];
inline bool Records::has_starttime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Records::set_has_starttime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Records::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Records::clear_starttime() {
  if (starttime_ != &_default_starttime_) {
    starttime_->assign(_default_starttime_);
  }
  clear_has_starttime();
}
inline const ::std::string& Records::starttime() const {
  return *starttime_;
}
inline void Records::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void Records::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void Records::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &_default_starttime_) {
    starttime_ = new ::std::string(_default_starttime_);
  }
  return starttime_;
}
inline ::std::string* Records::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &_default_starttime_) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&_default_starttime_);
    return temp;
  }
}

// optional string endTime = 10 [default = "1970-01-01 00:00:00"];
inline bool Records::has_endtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Records::set_has_endtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Records::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Records::clear_endtime() {
  if (endtime_ != &_default_endtime_) {
    endtime_->assign(_default_endtime_);
  }
  clear_has_endtime();
}
inline const ::std::string& Records::endtime() const {
  return *endtime_;
}
inline void Records::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void Records::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void Records::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &_default_endtime_) {
    endtime_ = new ::std::string(_default_endtime_);
  }
  return endtime_;
}
inline ::std::string* Records::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &_default_endtime_) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&_default_endtime_);
    return temp;
  }
}

// optional int32 nRecordBeginTime = 11;
inline bool Records::has_nrecordbegintime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Records::set_has_nrecordbegintime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Records::clear_has_nrecordbegintime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Records::clear_nrecordbegintime() {
  nrecordbegintime_ = 0;
  clear_has_nrecordbegintime();
}
inline ::google::protobuf::int32 Records::nrecordbegintime() const {
  return nrecordbegintime_;
}
inline void Records::set_nrecordbegintime(::google::protobuf::int32 value) {
  set_has_nrecordbegintime();
  nrecordbegintime_ = value;
}

// optional int32 nRecordEndTime = 12;
inline bool Records::has_nrecordendtime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Records::set_has_nrecordendtime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Records::clear_has_nrecordendtime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Records::clear_nrecordendtime() {
  nrecordendtime_ = 0;
  clear_has_nrecordendtime();
}
inline ::google::protobuf::int32 Records::nrecordendtime() const {
  return nrecordendtime_;
}
inline void Records::set_nrecordendtime(::google::protobuf::int32 value) {
  set_has_nrecordendtime();
  nrecordendtime_ = value;
}

// optional string streamNo = 13;
inline bool Records::has_streamno() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Records::set_has_streamno() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Records::clear_has_streamno() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Records::clear_streamno() {
  if (streamno_ != &::google::protobuf::internal::kEmptyString) {
    streamno_->clear();
  }
  clear_has_streamno();
}
inline const ::std::string& Records::streamno() const {
  return *streamno_;
}
inline void Records::set_streamno(const ::std::string& value) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(value);
}
inline void Records::set_streamno(const char* value) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(value);
}
inline void Records::set_streamno(const char* value, size_t size) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_streamno() {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  return streamno_;
}
inline ::std::string* Records::release_streamno() {
  clear_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamno_;
    streamno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nRepairDevId = 14;
inline bool Records::has_nrepairdevid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Records::set_has_nrepairdevid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Records::clear_has_nrepairdevid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Records::clear_nrepairdevid() {
  nrepairdevid_ = 0;
  clear_has_nrepairdevid();
}
inline ::google::protobuf::int32 Records::nrepairdevid() const {
  return nrepairdevid_;
}
inline void Records::set_nrepairdevid(::google::protobuf::int32 value) {
  set_has_nrepairdevid();
  nrepairdevid_ = value;
}

// optional string strCollectIp = 15;
inline bool Records::has_strcollectip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Records::set_has_strcollectip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Records::clear_has_strcollectip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Records::clear_strcollectip() {
  if (strcollectip_ != &::google::protobuf::internal::kEmptyString) {
    strcollectip_->clear();
  }
  clear_has_strcollectip();
}
inline const ::std::string& Records::strcollectip() const {
  return *strcollectip_;
}
inline void Records::set_strcollectip(const ::std::string& value) {
  set_has_strcollectip();
  if (strcollectip_ == &::google::protobuf::internal::kEmptyString) {
    strcollectip_ = new ::std::string;
  }
  strcollectip_->assign(value);
}
inline void Records::set_strcollectip(const char* value) {
  set_has_strcollectip();
  if (strcollectip_ == &::google::protobuf::internal::kEmptyString) {
    strcollectip_ = new ::std::string;
  }
  strcollectip_->assign(value);
}
inline void Records::set_strcollectip(const char* value, size_t size) {
  set_has_strcollectip();
  if (strcollectip_ == &::google::protobuf::internal::kEmptyString) {
    strcollectip_ = new ::std::string;
  }
  strcollectip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strcollectip() {
  set_has_strcollectip();
  if (strcollectip_ == &::google::protobuf::internal::kEmptyString) {
    strcollectip_ = new ::std::string;
  }
  return strcollectip_;
}
inline ::std::string* Records::release_strcollectip() {
  clear_has_strcollectip();
  if (strcollectip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcollectip_;
    strcollectip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 dvrPort = 16;
inline bool Records::has_dvrport() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Records::set_has_dvrport() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Records::clear_has_dvrport() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Records::clear_dvrport() {
  dvrport_ = 0;
  clear_has_dvrport();
}
inline ::google::protobuf::int32 Records::dvrport() const {
  return dvrport_;
}
inline void Records::set_dvrport(::google::protobuf::int32 value) {
  set_has_dvrport();
  dvrport_ = value;
}

// optional string dvrUserName = 17;
inline bool Records::has_dvrusername() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Records::set_has_dvrusername() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Records::clear_has_dvrusername() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Records::clear_dvrusername() {
  if (dvrusername_ != &::google::protobuf::internal::kEmptyString) {
    dvrusername_->clear();
  }
  clear_has_dvrusername();
}
inline const ::std::string& Records::dvrusername() const {
  return *dvrusername_;
}
inline void Records::set_dvrusername(const ::std::string& value) {
  set_has_dvrusername();
  if (dvrusername_ == &::google::protobuf::internal::kEmptyString) {
    dvrusername_ = new ::std::string;
  }
  dvrusername_->assign(value);
}
inline void Records::set_dvrusername(const char* value) {
  set_has_dvrusername();
  if (dvrusername_ == &::google::protobuf::internal::kEmptyString) {
    dvrusername_ = new ::std::string;
  }
  dvrusername_->assign(value);
}
inline void Records::set_dvrusername(const char* value, size_t size) {
  set_has_dvrusername();
  if (dvrusername_ == &::google::protobuf::internal::kEmptyString) {
    dvrusername_ = new ::std::string;
  }
  dvrusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_dvrusername() {
  set_has_dvrusername();
  if (dvrusername_ == &::google::protobuf::internal::kEmptyString) {
    dvrusername_ = new ::std::string;
  }
  return dvrusername_;
}
inline ::std::string* Records::release_dvrusername() {
  clear_has_dvrusername();
  if (dvrusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dvrusername_;
    dvrusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dvrPwd = 18;
inline bool Records::has_dvrpwd() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Records::set_has_dvrpwd() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Records::clear_has_dvrpwd() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Records::clear_dvrpwd() {
  if (dvrpwd_ != &::google::protobuf::internal::kEmptyString) {
    dvrpwd_->clear();
  }
  clear_has_dvrpwd();
}
inline const ::std::string& Records::dvrpwd() const {
  return *dvrpwd_;
}
inline void Records::set_dvrpwd(const ::std::string& value) {
  set_has_dvrpwd();
  if (dvrpwd_ == &::google::protobuf::internal::kEmptyString) {
    dvrpwd_ = new ::std::string;
  }
  dvrpwd_->assign(value);
}
inline void Records::set_dvrpwd(const char* value) {
  set_has_dvrpwd();
  if (dvrpwd_ == &::google::protobuf::internal::kEmptyString) {
    dvrpwd_ = new ::std::string;
  }
  dvrpwd_->assign(value);
}
inline void Records::set_dvrpwd(const char* value, size_t size) {
  set_has_dvrpwd();
  if (dvrpwd_ == &::google::protobuf::internal::kEmptyString) {
    dvrpwd_ = new ::std::string;
  }
  dvrpwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_dvrpwd() {
  set_has_dvrpwd();
  if (dvrpwd_ == &::google::protobuf::internal::kEmptyString) {
    dvrpwd_ = new ::std::string;
  }
  return dvrpwd_;
}
inline ::std::string* Records::release_dvrpwd() {
  clear_has_dvrpwd();
  if (dvrpwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dvrpwd_;
    dvrpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nCollectChan = 19;
inline bool Records::has_ncollectchan() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Records::set_has_ncollectchan() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Records::clear_has_ncollectchan() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Records::clear_ncollectchan() {
  ncollectchan_ = 0;
  clear_has_ncollectchan();
}
inline ::google::protobuf::int32 Records::ncollectchan() const {
  return ncollectchan_;
}
inline void Records::set_ncollectchan(::google::protobuf::int32 value) {
  set_has_ncollectchan();
  ncollectchan_ = value;
}

// optional string strUrl = 20;
inline bool Records::has_strurl() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Records::set_has_strurl() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Records::clear_has_strurl() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Records::clear_strurl() {
  if (strurl_ != &::google::protobuf::internal::kEmptyString) {
    strurl_->clear();
  }
  clear_has_strurl();
}
inline const ::std::string& Records::strurl() const {
  return *strurl_;
}
inline void Records::set_strurl(const ::std::string& value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void Records::set_strurl(const char* value) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(value);
}
inline void Records::set_strurl(const char* value, size_t size) {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  strurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strurl() {
  set_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    strurl_ = new ::std::string;
  }
  return strurl_;
}
inline ::std::string* Records::release_strurl() {
  clear_has_strurl();
  if (strurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strurl_;
    strurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string screenshotSrc = 21;
inline bool Records::has_screenshotsrc() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Records::set_has_screenshotsrc() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Records::clear_has_screenshotsrc() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Records::clear_screenshotsrc() {
  if (screenshotsrc_ != &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_->clear();
  }
  clear_has_screenshotsrc();
}
inline const ::std::string& Records::screenshotsrc() const {
  return *screenshotsrc_;
}
inline void Records::set_screenshotsrc(const ::std::string& value) {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  screenshotsrc_->assign(value);
}
inline void Records::set_screenshotsrc(const char* value) {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  screenshotsrc_->assign(value);
}
inline void Records::set_screenshotsrc(const char* value, size_t size) {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  screenshotsrc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_screenshotsrc() {
  set_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    screenshotsrc_ = new ::std::string;
  }
  return screenshotsrc_;
}
inline ::std::string* Records::release_screenshotsrc() {
  clear_has_screenshotsrc();
  if (screenshotsrc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = screenshotsrc_;
    screenshotsrc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dtBusinessTime = 22 [default = "1970-01-01 00:00:00"];
inline bool Records::has_dtbusinesstime() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Records::set_has_dtbusinesstime() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Records::clear_has_dtbusinesstime() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Records::clear_dtbusinesstime() {
  if (dtbusinesstime_ != &_default_dtbusinesstime_) {
    dtbusinesstime_->assign(_default_dtbusinesstime_);
  }
  clear_has_dtbusinesstime();
}
inline const ::std::string& Records::dtbusinesstime() const {
  return *dtbusinesstime_;
}
inline void Records::set_dtbusinesstime(const ::std::string& value) {
  set_has_dtbusinesstime();
  if (dtbusinesstime_ == &_default_dtbusinesstime_) {
    dtbusinesstime_ = new ::std::string;
  }
  dtbusinesstime_->assign(value);
}
inline void Records::set_dtbusinesstime(const char* value) {
  set_has_dtbusinesstime();
  if (dtbusinesstime_ == &_default_dtbusinesstime_) {
    dtbusinesstime_ = new ::std::string;
  }
  dtbusinesstime_->assign(value);
}
inline void Records::set_dtbusinesstime(const char* value, size_t size) {
  set_has_dtbusinesstime();
  if (dtbusinesstime_ == &_default_dtbusinesstime_) {
    dtbusinesstime_ = new ::std::string;
  }
  dtbusinesstime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_dtbusinesstime() {
  set_has_dtbusinesstime();
  if (dtbusinesstime_ == &_default_dtbusinesstime_) {
    dtbusinesstime_ = new ::std::string(_default_dtbusinesstime_);
  }
  return dtbusinesstime_;
}
inline ::std::string* Records::release_dtbusinesstime() {
  clear_has_dtbusinesstime();
  if (dtbusinesstime_ == &_default_dtbusinesstime_) {
    return NULL;
  } else {
    ::std::string* temp = dtbusinesstime_;
    dtbusinesstime_ = const_cast< ::std::string*>(&_default_dtbusinesstime_);
    return temp;
  }
}

// optional int32 nRecordLocalTime = 23;
inline bool Records::has_nrecordlocaltime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Records::set_has_nrecordlocaltime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Records::clear_has_nrecordlocaltime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Records::clear_nrecordlocaltime() {
  nrecordlocaltime_ = 0;
  clear_has_nrecordlocaltime();
}
inline ::google::protobuf::int32 Records::nrecordlocaltime() const {
  return nrecordlocaltime_;
}
inline void Records::set_nrecordlocaltime(::google::protobuf::int32 value) {
  set_has_nrecordlocaltime();
  nrecordlocaltime_ = value;
}

// optional int32 nFileHeadLen = 24;
inline bool Records::has_nfileheadlen() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Records::set_has_nfileheadlen() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Records::clear_has_nfileheadlen() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Records::clear_nfileheadlen() {
  nfileheadlen_ = 0;
  clear_has_nfileheadlen();
}
inline ::google::protobuf::int32 Records::nfileheadlen() const {
  return nfileheadlen_;
}
inline void Records::set_nfileheadlen(::google::protobuf::int32 value) {
  set_has_nfileheadlen();
  nfileheadlen_ = value;
}

// optional int32 nCallerType = 25;
inline bool Records::has_ncallertype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Records::set_has_ncallertype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Records::clear_has_ncallertype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Records::clear_ncallertype() {
  ncallertype_ = 0;
  clear_has_ncallertype();
}
inline ::google::protobuf::int32 Records::ncallertype() const {
  return ncallertype_;
}
inline void Records::set_ncallertype(::google::protobuf::int32 value) {
  set_has_ncallertype();
  ncallertype_ = value;
}

// optional string strCallerId = 26;
inline bool Records::has_strcallerid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Records::set_has_strcallerid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Records::clear_has_strcallerid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Records::clear_strcallerid() {
  if (strcallerid_ != &::google::protobuf::internal::kEmptyString) {
    strcallerid_->clear();
  }
  clear_has_strcallerid();
}
inline const ::std::string& Records::strcallerid() const {
  return *strcallerid_;
}
inline void Records::set_strcallerid(const ::std::string& value) {
  set_has_strcallerid();
  if (strcallerid_ == &::google::protobuf::internal::kEmptyString) {
    strcallerid_ = new ::std::string;
  }
  strcallerid_->assign(value);
}
inline void Records::set_strcallerid(const char* value) {
  set_has_strcallerid();
  if (strcallerid_ == &::google::protobuf::internal::kEmptyString) {
    strcallerid_ = new ::std::string;
  }
  strcallerid_->assign(value);
}
inline void Records::set_strcallerid(const char* value, size_t size) {
  set_has_strcallerid();
  if (strcallerid_ == &::google::protobuf::internal::kEmptyString) {
    strcallerid_ = new ::std::string;
  }
  strcallerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strcallerid() {
  set_has_strcallerid();
  if (strcallerid_ == &::google::protobuf::internal::kEmptyString) {
    strcallerid_ = new ::std::string;
  }
  return strcallerid_;
}
inline ::std::string* Records::release_strcallerid() {
  clear_has_strcallerid();
  if (strcallerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcallerid_;
    strcallerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nRepairType = 27;
inline bool Records::has_nrepairtype() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Records::set_has_nrepairtype() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Records::clear_has_nrepairtype() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Records::clear_nrepairtype() {
  nrepairtype_ = 0;
  clear_has_nrepairtype();
}
inline ::google::protobuf::int32 Records::nrepairtype() const {
  return nrepairtype_;
}
inline void Records::set_nrepairtype(::google::protobuf::int32 value) {
  set_has_nrepairtype();
  nrepairtype_ = value;
}

// optional int32 nRepairTime = 28;
inline bool Records::has_nrepairtime() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Records::set_has_nrepairtime() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Records::clear_has_nrepairtime() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Records::clear_nrepairtime() {
  nrepairtime_ = 0;
  clear_has_nrepairtime();
}
inline ::google::protobuf::int32 Records::nrepairtime() const {
  return nrepairtime_;
}
inline void Records::set_nrepairtime(::google::protobuf::int32 value) {
  set_has_nrepairtime();
  nrepairtime_ = value;
}

// optional int32 nLinkOrderId = 29;
inline bool Records::has_nlinkorderid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Records::set_has_nlinkorderid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Records::clear_has_nlinkorderid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Records::clear_nlinkorderid() {
  nlinkorderid_ = 0;
  clear_has_nlinkorderid();
}
inline ::google::protobuf::int32 Records::nlinkorderid() const {
  return nlinkorderid_;
}
inline void Records::set_nlinkorderid(::google::protobuf::int32 value) {
  set_has_nlinkorderid();
  nlinkorderid_ = value;
}

// optional int32 nLinkType = 30;
inline bool Records::has_nlinktype() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Records::set_has_nlinktype() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Records::clear_has_nlinktype() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Records::clear_nlinktype() {
  nlinktype_ = 0;
  clear_has_nlinktype();
}
inline ::google::protobuf::int32 Records::nlinktype() const {
  return nlinktype_;
}
inline void Records::set_nlinktype(::google::protobuf::int32 value) {
  set_has_nlinktype();
  nlinktype_ = value;
}

// optional int32 nManufacturerType = 31;
inline bool Records::has_nmanufacturertype() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Records::set_has_nmanufacturertype() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Records::clear_has_nmanufacturertype() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Records::clear_nmanufacturertype() {
  nmanufacturertype_ = 0;
  clear_has_nmanufacturertype();
}
inline ::google::protobuf::int32 Records::nmanufacturertype() const {
  return nmanufacturertype_;
}
inline void Records::set_nmanufacturertype(::google::protobuf::int32 value) {
  set_has_nmanufacturertype();
  nmanufacturertype_ = value;
}

// optional int32 nFileSize = 32;
inline bool Records::has_nfilesize() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Records::set_has_nfilesize() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Records::clear_has_nfilesize() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Records::clear_nfilesize() {
  nfilesize_ = 0;
  clear_has_nfilesize();
}
inline ::google::protobuf::int32 Records::nfilesize() const {
  return nfilesize_;
}
inline void Records::set_nfilesize(::google::protobuf::int32 value) {
  set_has_nfilesize();
  nfilesize_ = value;
}

// optional int32 nTaskId = 33;
inline bool Records::has_ntaskid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Records::set_has_ntaskid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Records::clear_has_ntaskid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Records::clear_ntaskid() {
  ntaskid_ = 0;
  clear_has_ntaskid();
}
inline ::google::protobuf::int32 Records::ntaskid() const {
  return ntaskid_;
}
inline void Records::set_ntaskid(::google::protobuf::int32 value) {
  set_has_ntaskid();
  ntaskid_ = value;
}

// optional string strIp = 34;
inline bool Records::has_strip() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Records::set_has_strip() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Records::clear_has_strip() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Records::clear_strip() {
  if (strip_ != &::google::protobuf::internal::kEmptyString) {
    strip_->clear();
  }
  clear_has_strip();
}
inline const ::std::string& Records::strip() const {
  return *strip_;
}
inline void Records::set_strip(const ::std::string& value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void Records::set_strip(const char* value) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(value);
}
inline void Records::set_strip(const char* value, size_t size) {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  strip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strip() {
  set_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    strip_ = new ::std::string;
  }
  return strip_;
}
inline ::std::string* Records::release_strip() {
  clear_has_strip();
  if (strip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strip_;
    strip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCloudIp = 35;
inline bool Records::has_strcloudip() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Records::set_has_strcloudip() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Records::clear_has_strcloudip() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Records::clear_strcloudip() {
  if (strcloudip_ != &::google::protobuf::internal::kEmptyString) {
    strcloudip_->clear();
  }
  clear_has_strcloudip();
}
inline const ::std::string& Records::strcloudip() const {
  return *strcloudip_;
}
inline void Records::set_strcloudip(const ::std::string& value) {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  strcloudip_->assign(value);
}
inline void Records::set_strcloudip(const char* value) {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  strcloudip_->assign(value);
}
inline void Records::set_strcloudip(const char* value, size_t size) {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  strcloudip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strcloudip() {
  set_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    strcloudip_ = new ::std::string;
  }
  return strcloudip_;
}
inline ::std::string* Records::release_strcloudip() {
  clear_has_strcloudip();
  if (strcloudip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcloudip_;
    strcloudip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nCloudPort = 36;
inline bool Records::has_ncloudport() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Records::set_has_ncloudport() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Records::clear_has_ncloudport() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Records::clear_ncloudport() {
  ncloudport_ = 0;
  clear_has_ncloudport();
}
inline ::google::protobuf::int32 Records::ncloudport() const {
  return ncloudport_;
}
inline void Records::set_ncloudport(::google::protobuf::int32 value) {
  set_has_ncloudport();
  ncloudport_ = value;
}

// optional string strAccessKey = 37;
inline bool Records::has_straccesskey() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Records::set_has_straccesskey() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Records::clear_has_straccesskey() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Records::clear_straccesskey() {
  if (straccesskey_ != &::google::protobuf::internal::kEmptyString) {
    straccesskey_->clear();
  }
  clear_has_straccesskey();
}
inline const ::std::string& Records::straccesskey() const {
  return *straccesskey_;
}
inline void Records::set_straccesskey(const ::std::string& value) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(value);
}
inline void Records::set_straccesskey(const char* value) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(value);
}
inline void Records::set_straccesskey(const char* value, size_t size) {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  straccesskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_straccesskey() {
  set_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    straccesskey_ = new ::std::string;
  }
  return straccesskey_;
}
inline ::std::string* Records::release_straccesskey() {
  clear_has_straccesskey();
  if (straccesskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = straccesskey_;
    straccesskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strSecretKey = 38;
inline bool Records::has_strsecretkey() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Records::set_has_strsecretkey() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Records::clear_has_strsecretkey() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Records::clear_strsecretkey() {
  if (strsecretkey_ != &::google::protobuf::internal::kEmptyString) {
    strsecretkey_->clear();
  }
  clear_has_strsecretkey();
}
inline const ::std::string& Records::strsecretkey() const {
  return *strsecretkey_;
}
inline void Records::set_strsecretkey(const ::std::string& value) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(value);
}
inline void Records::set_strsecretkey(const char* value) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(value);
}
inline void Records::set_strsecretkey(const char* value, size_t size) {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  strsecretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strsecretkey() {
  set_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    strsecretkey_ = new ::std::string;
  }
  return strsecretkey_;
}
inline ::std::string* Records::release_strsecretkey() {
  clear_has_strsecretkey();
  if (strsecretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strsecretkey_;
    strsecretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strBucket = 39;
inline bool Records::has_strbucket() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Records::set_has_strbucket() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Records::clear_has_strbucket() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Records::clear_strbucket() {
  if (strbucket_ != &::google::protobuf::internal::kEmptyString) {
    strbucket_->clear();
  }
  clear_has_strbucket();
}
inline const ::std::string& Records::strbucket() const {
  return *strbucket_;
}
inline void Records::set_strbucket(const ::std::string& value) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(value);
}
inline void Records::set_strbucket(const char* value) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(value);
}
inline void Records::set_strbucket(const char* value, size_t size) {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  strbucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Records::mutable_strbucket() {
  set_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    strbucket_ = new ::std::string;
  }
  return strbucket_;
}
inline ::std::string* Records::release_strbucket() {
  clear_has_strbucket();
  if (strbucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strbucket_;
    strbucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqRecords

// optional int32 cmd = 1;
inline bool ReqRecords::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRecords::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRecords::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRecords::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ReqRecords::cmd() const {
  return cmd_;
}
inline void ReqRecords::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional int32 id = 2;
inline bool ReqRecords::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqRecords::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqRecords::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqRecords::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqRecords::id() const {
  return id_;
}
inline void ReqRecords::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 nRecordStatus = 3;
inline bool ReqRecords::has_nrecordstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqRecords::set_has_nrecordstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqRecords::clear_has_nrecordstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqRecords::clear_nrecordstatus() {
  nrecordstatus_ = 0;
  clear_has_nrecordstatus();
}
inline ::google::protobuf::int32 ReqRecords::nrecordstatus() const {
  return nrecordstatus_;
}
inline void ReqRecords::set_nrecordstatus(::google::protobuf::int32 value) {
  set_has_nrecordstatus();
  nrecordstatus_ = value;
}

// optional int32 nUpLoadPercent = 4;
inline bool ReqRecords::has_nuploadpercent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqRecords::set_has_nuploadpercent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqRecords::clear_has_nuploadpercent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqRecords::clear_nuploadpercent() {
  nuploadpercent_ = 0;
  clear_has_nuploadpercent();
}
inline ::google::protobuf::int32 ReqRecords::nuploadpercent() const {
  return nuploadpercent_;
}
inline void ReqRecords::set_nuploadpercent(::google::protobuf::int32 value) {
  set_has_nuploadpercent();
  nuploadpercent_ = value;
}

// optional int32 nTaskId = 5;
inline bool ReqRecords::has_ntaskid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqRecords::set_has_ntaskid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqRecords::clear_has_ntaskid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqRecords::clear_ntaskid() {
  ntaskid_ = 0;
  clear_has_ntaskid();
}
inline ::google::protobuf::int32 ReqRecords::ntaskid() const {
  return ntaskid_;
}
inline void ReqRecords::set_ntaskid(::google::protobuf::int32 value) {
  set_has_ntaskid();
  ntaskid_ = value;
}

// optional string streamNo = 6;
inline bool ReqRecords::has_streamno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqRecords::set_has_streamno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqRecords::clear_has_streamno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqRecords::clear_streamno() {
  if (streamno_ != &::google::protobuf::internal::kEmptyString) {
    streamno_->clear();
  }
  clear_has_streamno();
}
inline const ::std::string& ReqRecords::streamno() const {
  return *streamno_;
}
inline void ReqRecords::set_streamno(const ::std::string& value) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(value);
}
inline void ReqRecords::set_streamno(const char* value) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(value);
}
inline void ReqRecords::set_streamno(const char* value, size_t size) {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  streamno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecords::mutable_streamno() {
  set_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    streamno_ = new ::std::string;
  }
  return streamno_;
}
inline ::std::string* ReqRecords::release_streamno() {
  clear_has_streamno();
  if (streamno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamno_;
    streamno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rtspPath = 7;
inline bool ReqRecords::has_rtsppath() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqRecords::set_has_rtsppath() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqRecords::clear_has_rtsppath() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqRecords::clear_rtsppath() {
  if (rtsppath_ != &::google::protobuf::internal::kEmptyString) {
    rtsppath_->clear();
  }
  clear_has_rtsppath();
}
inline const ::std::string& ReqRecords::rtsppath() const {
  return *rtsppath_;
}
inline void ReqRecords::set_rtsppath(const ::std::string& value) {
  set_has_rtsppath();
  if (rtsppath_ == &::google::protobuf::internal::kEmptyString) {
    rtsppath_ = new ::std::string;
  }
  rtsppath_->assign(value);
}
inline void ReqRecords::set_rtsppath(const char* value) {
  set_has_rtsppath();
  if (rtsppath_ == &::google::protobuf::internal::kEmptyString) {
    rtsppath_ = new ::std::string;
  }
  rtsppath_->assign(value);
}
inline void ReqRecords::set_rtsppath(const char* value, size_t size) {
  set_has_rtsppath();
  if (rtsppath_ == &::google::protobuf::internal::kEmptyString) {
    rtsppath_ = new ::std::string;
  }
  rtsppath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecords::mutable_rtsppath() {
  set_has_rtsppath();
  if (rtsppath_ == &::google::protobuf::internal::kEmptyString) {
    rtsppath_ = new ::std::string;
  }
  return rtsppath_;
}
inline ::std::string* ReqRecords::release_rtsppath() {
  clear_has_rtsppath();
  if (rtsppath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rtsppath_;
    rtsppath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 nFileSize = 8;
inline bool ReqRecords::has_nfilesize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqRecords::set_has_nfilesize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqRecords::clear_has_nfilesize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqRecords::clear_nfilesize() {
  nfilesize_ = 0;
  clear_has_nfilesize();
}
inline ::google::protobuf::int32 ReqRecords::nfilesize() const {
  return nfilesize_;
}
inline void ReqRecords::set_nfilesize(::google::protobuf::int32 value) {
  set_has_nfilesize();
  nfilesize_ = value;
}

// optional string errorMsg = 9;
inline bool ReqRecords::has_errormsg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqRecords::set_has_errormsg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqRecords::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqRecords::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& ReqRecords::errormsg() const {
  return *errormsg_;
}
inline void ReqRecords::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void ReqRecords::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void ReqRecords::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecords::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* ReqRecords::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string startTime = 10;
inline bool ReqRecords::has_starttime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReqRecords::set_has_starttime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReqRecords::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReqRecords::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& ReqRecords::starttime() const {
  return *starttime_;
}
inline void ReqRecords::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void ReqRecords::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void ReqRecords::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecords::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* ReqRecords::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string endTime = 11;
inline bool ReqRecords::has_endtime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReqRecords::set_has_endtime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReqRecords::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReqRecords::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& ReqRecords::endtime() const {
  return *endtime_;
}
inline void ReqRecords::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void ReqRecords::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void ReqRecords::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqRecords::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* ReqRecords::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RecordsList

// optional int32 cmd = 1;
inline bool RecordsList::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordsList::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordsList::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordsList::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 RecordsList::cmd() const {
  return cmd_;
}
inline void RecordsList::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// repeated .cms_8120.Records record = 2;
inline int RecordsList::record_size() const {
  return record_.size();
}
inline void RecordsList::clear_record() {
  record_.Clear();
}
inline const ::cms_8120::Records& RecordsList::record(int index) const {
  return record_.Get(index);
}
inline ::cms_8120::Records* RecordsList::mutable_record(int index) {
  return record_.Mutable(index);
}
inline ::cms_8120::Records* RecordsList::add_record() {
  return record_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cms_8120::Records >&
RecordsList::record() const {
  return record_;
}
inline ::google::protobuf::RepeatedPtrField< ::cms_8120::Records >*
RecordsList::mutable_record() {
  return &record_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cms_8120

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_center_2fRecords_2eproto__INCLUDED
